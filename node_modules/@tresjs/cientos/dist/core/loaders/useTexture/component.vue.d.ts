import { LoadingManager, Texture } from 'three';
type __VLS_Props = {
    /**
     * The path to the texture file.
     *
     * @type {string}
     * @required
     * @memberof TextureProps
     */
    path: string;
    /**
     * Optional THREE.js LoadingManager
     */
    manager?: LoadingManager;
};
declare function __VLS_template(): {
    attrs: Partial<{}>;
    slots: {
        default?(_: {
            state: {
                readonly isTexture: true;
                readonly id: number;
                uuid: string;
                name: string;
                source: {
                    readonly isSource: true;
                    readonly id: number;
                    uuid: string;
                    data: any;
                    dataReady: boolean;
                    version: number;
                    getSize: (target: import('three').Vector3) => import('three').Vector3;
                    needsUpdate: boolean;
                    toJSON: (meta?: string | {}) => import('three').SourceJSON;
                };
                readonly width: number;
                readonly height: number;
                readonly depth: number;
                image: any;
                mipmaps: HTMLCanvasElement[] | {
                    data: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin?: number, end?: number) => ArrayBuffer;
                            readonly maxByteLength: number;
                            readonly resizable: boolean;
                            resize: (newByteLength?: number) => void;
                            readonly detached: boolean;
                            transfer: (newByteLength?: number) => ArrayBuffer;
                            transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin?: number, end?: number) => SharedArrayBuffer;
                            readonly growable: boolean;
                            readonly maxByteLength: number;
                            grow: (newByteLength?: number) => void;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number) => Int8Array<ArrayBufferLike>;
                        every: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number, end?: number) => Int8Array<ArrayBufferLike>;
                        filter: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => any, thisArg?: any) => Int8Array<ArrayBuffer>;
                        find: (predicate: (value: number, index: number, obj: Int8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Int8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number) => number;
                        join: (separator?: string) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => number, thisArg?: any) => Int8Array<ArrayBuffer>;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => U, initialValue: U): U;
                        };
                        reverse: () => Int8Array<ArrayBufferLike>;
                        set: (array: ArrayLike<number>, offset?: number) => void;
                        slice: (start?: number, end?: number) => Int8Array<ArrayBuffer>;
                        some: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Int8Array<ArrayBufferLike>;
                        subarray: (begin?: number, end?: number) => Int8Array<ArrayBufferLike>;
                        toLocaleString: {
                            (): string;
                            (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                        };
                        toString: () => string;
                        valueOf: () => Int8Array<ArrayBufferLike>;
                        entries: () => ArrayIterator<[number, number]>;
                        keys: () => ArrayIterator<number>;
                        values: () => ArrayIterator<number>;
                        includes: (searchElement: number, fromIndex?: number) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                        toReversed: () => Int8Array<ArrayBuffer>;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Int8Array<ArrayBuffer>;
                        with: (index: number, value: number) => Int8Array<ArrayBuffer>;
                        [Symbol.iterator]: () => ArrayIterator<number>;
                        readonly [Symbol.toStringTag]: "Int8Array";
                    } | {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin?: number, end?: number) => ArrayBuffer;
                            readonly maxByteLength: number;
                            readonly resizable: boolean;
                            resize: (newByteLength?: number) => void;
                            readonly detached: boolean;
                            transfer: (newByteLength?: number) => ArrayBuffer;
                            transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin?: number, end?: number) => SharedArrayBuffer;
                            readonly growable: boolean;
                            readonly maxByteLength: number;
                            grow: (newByteLength?: number) => void;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number) => Uint8Array<ArrayBufferLike>;
                        every: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number, end?: number) => Uint8Array<ArrayBufferLike>;
                        filter: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => any, thisArg?: any) => Uint8Array<ArrayBuffer>;
                        find: (predicate: (value: number, index: number, obj: Uint8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Uint8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number) => number;
                        join: (separator?: string) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => number, thisArg?: any) => Uint8Array<ArrayBuffer>;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => U, initialValue: U): U;
                        };
                        reverse: () => Uint8Array<ArrayBufferLike>;
                        set: (array: ArrayLike<number>, offset?: number) => void;
                        slice: (start?: number, end?: number) => Uint8Array<ArrayBuffer>;
                        some: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8Array<ArrayBufferLike>;
                        subarray: (begin?: number, end?: number) => Uint8Array<ArrayBufferLike>;
                        toLocaleString: {
                            (): string;
                            (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                        };
                        toString: () => string;
                        valueOf: () => Uint8Array<ArrayBufferLike>;
                        entries: () => ArrayIterator<[number, number]>;
                        keys: () => ArrayIterator<number>;
                        values: () => ArrayIterator<number>;
                        includes: (searchElement: number, fromIndex?: number) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                        toReversed: () => Uint8Array<ArrayBuffer>;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8Array<ArrayBuffer>;
                        with: (index: number, value: number) => Uint8Array<ArrayBuffer>;
                        [Symbol.iterator]: () => ArrayIterator<number>;
                        readonly [Symbol.toStringTag]: "Uint8Array";
                    } | {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin?: number, end?: number) => ArrayBuffer;
                            readonly maxByteLength: number;
                            readonly resizable: boolean;
                            resize: (newByteLength?: number) => void;
                            readonly detached: boolean;
                            transfer: (newByteLength?: number) => ArrayBuffer;
                            transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin?: number, end?: number) => SharedArrayBuffer;
                            readonly growable: boolean;
                            readonly maxByteLength: number;
                            grow: (newByteLength?: number) => void;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number) => Uint8ClampedArray<ArrayBufferLike>;
                        every: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number, end?: number) => Uint8ClampedArray<ArrayBufferLike>;
                        filter: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => any, thisArg?: any) => Uint8ClampedArray<ArrayBuffer>;
                        find: (predicate: (value: number, index: number, obj: Uint8ClampedArray<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Uint8ClampedArray<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number) => number;
                        join: (separator?: string) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => number, thisArg?: any) => Uint8ClampedArray<ArrayBuffer>;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => U, initialValue: U): U;
                        };
                        reverse: () => Uint8ClampedArray<ArrayBufferLike>;
                        set: (array: ArrayLike<number>, offset?: number) => void;
                        slice: (start?: number, end?: number) => Uint8ClampedArray<ArrayBuffer>;
                        some: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8ClampedArray<ArrayBufferLike>;
                        subarray: (begin?: number, end?: number) => Uint8ClampedArray<ArrayBufferLike>;
                        toLocaleString: {
                            (): string;
                            (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                        };
                        toString: () => string;
                        valueOf: () => Uint8ClampedArray<ArrayBufferLike>;
                        entries: () => ArrayIterator<[number, number]>;
                        keys: () => ArrayIterator<number>;
                        values: () => ArrayIterator<number>;
                        includes: (searchElement: number, fromIndex?: number) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                        toReversed: () => Uint8ClampedArray<ArrayBuffer>;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8ClampedArray<ArrayBuffer>;
                        with: (index: number, value: number) => Uint8ClampedArray<ArrayBuffer>;
                        [Symbol.iterator]: () => ArrayIterator<number>;
                        readonly [Symbol.toStringTag]: "Uint8ClampedArray";
                    } | {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin?: number, end?: number) => ArrayBuffer;
                            readonly maxByteLength: number;
                            readonly resizable: boolean;
                            resize: (newByteLength?: number) => void;
                            readonly detached: boolean;
                            transfer: (newByteLength?: number) => ArrayBuffer;
                            transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin?: number, end?: number) => SharedArrayBuffer;
                            readonly growable: boolean;
                            readonly maxByteLength: number;
                            grow: (newByteLength?: number) => void;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number) => Int16Array<ArrayBufferLike>;
                        every: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number, end?: number) => Int16Array<ArrayBufferLike>;
                        filter: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => any, thisArg?: any) => Int16Array<ArrayBuffer>;
                        find: (predicate: (value: number, index: number, obj: Int16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Int16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number) => number;
                        join: (separator?: string) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => number, thisArg?: any) => Int16Array<ArrayBuffer>;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => U, initialValue: U): U;
                        };
                        reverse: () => Int16Array<ArrayBufferLike>;
                        set: (array: ArrayLike<number>, offset?: number) => void;
                        slice: (start?: number, end?: number) => Int16Array<ArrayBuffer>;
                        some: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Int16Array<ArrayBufferLike>;
                        subarray: (begin?: number, end?: number) => Int16Array<ArrayBufferLike>;
                        toLocaleString: {
                            (): string;
                            (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                        };
                        toString: () => string;
                        valueOf: () => Int16Array<ArrayBufferLike>;
                        entries: () => ArrayIterator<[number, number]>;
                        keys: () => ArrayIterator<number>;
                        values: () => ArrayIterator<number>;
                        includes: (searchElement: number, fromIndex?: number) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                        toReversed: () => Int16Array<ArrayBuffer>;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Int16Array<ArrayBuffer>;
                        with: (index: number, value: number) => Int16Array<ArrayBuffer>;
                        [Symbol.iterator]: () => ArrayIterator<number>;
                        readonly [Symbol.toStringTag]: "Int16Array";
                    } | {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin?: number, end?: number) => ArrayBuffer;
                            readonly maxByteLength: number;
                            readonly resizable: boolean;
                            resize: (newByteLength?: number) => void;
                            readonly detached: boolean;
                            transfer: (newByteLength?: number) => ArrayBuffer;
                            transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin?: number, end?: number) => SharedArrayBuffer;
                            readonly growable: boolean;
                            readonly maxByteLength: number;
                            grow: (newByteLength?: number) => void;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number) => Uint16Array<ArrayBufferLike>;
                        every: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number, end?: number) => Uint16Array<ArrayBufferLike>;
                        filter: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => any, thisArg?: any) => Uint16Array<ArrayBuffer>;
                        find: (predicate: (value: number, index: number, obj: Uint16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Uint16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number) => number;
                        join: (separator?: string) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => number, thisArg?: any) => Uint16Array<ArrayBuffer>;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => U, initialValue: U): U;
                        };
                        reverse: () => Uint16Array<ArrayBufferLike>;
                        set: (array: ArrayLike<number>, offset?: number) => void;
                        slice: (start?: number, end?: number) => Uint16Array<ArrayBuffer>;
                        some: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint16Array<ArrayBufferLike>;
                        subarray: (begin?: number, end?: number) => Uint16Array<ArrayBufferLike>;
                        toLocaleString: {
                            (): string;
                            (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                        };
                        toString: () => string;
                        valueOf: () => Uint16Array<ArrayBufferLike>;
                        entries: () => ArrayIterator<[number, number]>;
                        keys: () => ArrayIterator<number>;
                        values: () => ArrayIterator<number>;
                        includes: (searchElement: number, fromIndex?: number) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                        toReversed: () => Uint16Array<ArrayBuffer>;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint16Array<ArrayBuffer>;
                        with: (index: number, value: number) => Uint16Array<ArrayBuffer>;
                        [Symbol.iterator]: () => ArrayIterator<number>;
                        readonly [Symbol.toStringTag]: "Uint16Array";
                    } | {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin?: number, end?: number) => ArrayBuffer;
                            readonly maxByteLength: number;
                            readonly resizable: boolean;
                            resize: (newByteLength?: number) => void;
                            readonly detached: boolean;
                            transfer: (newByteLength?: number) => ArrayBuffer;
                            transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin?: number, end?: number) => SharedArrayBuffer;
                            readonly growable: boolean;
                            readonly maxByteLength: number;
                            grow: (newByteLength?: number) => void;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number) => Int32Array<ArrayBufferLike>;
                        every: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number, end?: number) => Int32Array<ArrayBufferLike>;
                        filter: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => any, thisArg?: any) => Int32Array<ArrayBuffer>;
                        find: (predicate: (value: number, index: number, obj: Int32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Int32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number) => number;
                        join: (separator?: string) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => number, thisArg?: any) => Int32Array<ArrayBuffer>;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => U, initialValue: U): U;
                        };
                        reverse: () => Int32Array<ArrayBufferLike>;
                        set: (array: ArrayLike<number>, offset?: number) => void;
                        slice: (start?: number, end?: number) => Int32Array<ArrayBuffer>;
                        some: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Int32Array<ArrayBufferLike>;
                        subarray: (begin?: number, end?: number) => Int32Array<ArrayBufferLike>;
                        toLocaleString: {
                            (): string;
                            (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                        };
                        toString: () => string;
                        valueOf: () => Int32Array<ArrayBufferLike>;
                        entries: () => ArrayIterator<[number, number]>;
                        keys: () => ArrayIterator<number>;
                        values: () => ArrayIterator<number>;
                        includes: (searchElement: number, fromIndex?: number) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                        toReversed: () => Int32Array<ArrayBuffer>;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Int32Array<ArrayBuffer>;
                        with: (index: number, value: number) => Int32Array<ArrayBuffer>;
                        [Symbol.iterator]: () => ArrayIterator<number>;
                        readonly [Symbol.toStringTag]: "Int32Array";
                    } | {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin?: number, end?: number) => ArrayBuffer;
                            readonly maxByteLength: number;
                            readonly resizable: boolean;
                            resize: (newByteLength?: number) => void;
                            readonly detached: boolean;
                            transfer: (newByteLength?: number) => ArrayBuffer;
                            transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin?: number, end?: number) => SharedArrayBuffer;
                            readonly growable: boolean;
                            readonly maxByteLength: number;
                            grow: (newByteLength?: number) => void;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number) => Uint32Array<ArrayBufferLike>;
                        every: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number, end?: number) => Uint32Array<ArrayBufferLike>;
                        filter: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => any, thisArg?: any) => Uint32Array<ArrayBuffer>;
                        find: (predicate: (value: number, index: number, obj: Uint32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Uint32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number) => number;
                        join: (separator?: string) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => number, thisArg?: any) => Uint32Array<ArrayBuffer>;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => U, initialValue: U): U;
                        };
                        reverse: () => Uint32Array<ArrayBufferLike>;
                        set: (array: ArrayLike<number>, offset?: number) => void;
                        slice: (start?: number, end?: number) => Uint32Array<ArrayBuffer>;
                        some: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint32Array<ArrayBufferLike>;
                        subarray: (begin?: number, end?: number) => Uint32Array<ArrayBufferLike>;
                        toLocaleString: {
                            (): string;
                            (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                        };
                        toString: () => string;
                        valueOf: () => Uint32Array<ArrayBufferLike>;
                        entries: () => ArrayIterator<[number, number]>;
                        keys: () => ArrayIterator<number>;
                        values: () => ArrayIterator<number>;
                        includes: (searchElement: number, fromIndex?: number) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                        toReversed: () => Uint32Array<ArrayBuffer>;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint32Array<ArrayBuffer>;
                        with: (index: number, value: number) => Uint32Array<ArrayBuffer>;
                        [Symbol.iterator]: () => ArrayIterator<number>;
                        readonly [Symbol.toStringTag]: "Uint32Array";
                    } | {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin?: number, end?: number) => ArrayBuffer;
                            readonly maxByteLength: number;
                            readonly resizable: boolean;
                            resize: (newByteLength?: number) => void;
                            readonly detached: boolean;
                            transfer: (newByteLength?: number) => ArrayBuffer;
                            transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin?: number, end?: number) => SharedArrayBuffer;
                            readonly growable: boolean;
                            readonly maxByteLength: number;
                            grow: (newByteLength?: number) => void;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number) => Float32Array<ArrayBufferLike>;
                        every: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number, end?: number) => Float32Array<ArrayBufferLike>;
                        filter: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => any, thisArg?: any) => Float32Array<ArrayBuffer>;
                        find: (predicate: (value: number, index: number, obj: Float32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number) => number;
                        join: (separator?: string) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => number, thisArg?: any) => Float32Array<ArrayBuffer>;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => U, initialValue: U): U;
                        };
                        reverse: () => Float32Array<ArrayBufferLike>;
                        set: (array: ArrayLike<number>, offset?: number) => void;
                        slice: (start?: number, end?: number) => Float32Array<ArrayBuffer>;
                        some: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array<ArrayBufferLike>;
                        subarray: (begin?: number, end?: number) => Float32Array<ArrayBufferLike>;
                        toLocaleString: {
                            (): string;
                            (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                        };
                        toString: () => string;
                        valueOf: () => Float32Array<ArrayBufferLike>;
                        entries: () => ArrayIterator<[number, number]>;
                        keys: () => ArrayIterator<number>;
                        values: () => ArrayIterator<number>;
                        includes: (searchElement: number, fromIndex?: number) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                        toReversed: () => Float32Array<ArrayBuffer>;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array<ArrayBuffer>;
                        with: (index: number, value: number) => Float32Array<ArrayBuffer>;
                        [Symbol.iterator]: () => ArrayIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    } | {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin?: number, end?: number) => ArrayBuffer;
                            readonly maxByteLength: number;
                            readonly resizable: boolean;
                            resize: (newByteLength?: number) => void;
                            readonly detached: boolean;
                            transfer: (newByteLength?: number) => ArrayBuffer;
                            transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin?: number, end?: number) => SharedArrayBuffer;
                            readonly growable: boolean;
                            readonly maxByteLength: number;
                            grow: (newByteLength?: number) => void;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number) => Float64Array<ArrayBufferLike>;
                        every: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number, end?: number) => Float64Array<ArrayBufferLike>;
                        filter: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => any, thisArg?: any) => Float64Array<ArrayBuffer>;
                        find: (predicate: (value: number, index: number, obj: Float64Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float64Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number) => number;
                        join: (separator?: string) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => number, thisArg?: any) => Float64Array<ArrayBuffer>;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => U, initialValue: U): U;
                        };
                        reverse: () => Float64Array<ArrayBufferLike>;
                        set: (array: ArrayLike<number>, offset?: number) => void;
                        slice: (start?: number, end?: number) => Float64Array<ArrayBuffer>;
                        some: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float64Array<ArrayBufferLike>;
                        subarray: (begin?: number, end?: number) => Float64Array<ArrayBufferLike>;
                        toLocaleString: {
                            (): string;
                            (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                        };
                        toString: () => string;
                        valueOf: () => Float64Array<ArrayBufferLike>;
                        entries: () => ArrayIterator<[number, number]>;
                        keys: () => ArrayIterator<number>;
                        values: () => ArrayIterator<number>;
                        includes: (searchElement: number, fromIndex?: number) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                        toReversed: () => Float64Array<ArrayBuffer>;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float64Array<ArrayBuffer>;
                        with: (index: number, value: number) => Float64Array<ArrayBuffer>;
                        [Symbol.iterator]: () => ArrayIterator<number>;
                        readonly [Symbol.toStringTag]: "Float64Array";
                    };
                    width: number;
                    height: number;
                }[] | {
                    readonly isCubeTexture: true;
                    image: any;
                    images: any;
                    mapping: import('three').CubeTextureMapping;
                    flipY: boolean;
                    readonly isTexture: true;
                    readonly id: number;
                    uuid: string;
                    name: string;
                    source: {
                        readonly isSource: true;
                        readonly id: number;
                        uuid: string;
                        data: any;
                        dataReady: boolean;
                        version: number;
                        getSize: (target: import('three').Vector3) => import('three').Vector3;
                        needsUpdate: boolean;
                        toJSON: (meta?: string | {}) => import('three').SourceJSON;
                    };
                    readonly width: number;
                    readonly height: number;
                    readonly depth: number;
                    mipmaps: HTMLCanvasElement[] | {
                        data: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin?: number, end?: number) => ArrayBuffer;
                                readonly maxByteLength: number;
                                readonly resizable: boolean;
                                resize: (newByteLength?: number) => void;
                                readonly detached: boolean;
                                transfer: (newByteLength?: number) => ArrayBuffer;
                                transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin?: number, end?: number) => SharedArrayBuffer;
                                readonly growable: boolean;
                                readonly maxByteLength: number;
                                grow: (newByteLength?: number) => void;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number) => Int8Array<ArrayBufferLike>;
                            every: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number, end?: number) => Int8Array<ArrayBufferLike>;
                            filter: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => any, thisArg?: any) => Int8Array<ArrayBuffer>;
                            find: (predicate: (value: number, index: number, obj: Int8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Int8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number) => number;
                            join: (separator?: string) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => number, thisArg?: any) => Int8Array<ArrayBuffer>;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => U, initialValue: U): U;
                            };
                            reverse: () => Int8Array<ArrayBufferLike>;
                            set: (array: ArrayLike<number>, offset?: number) => void;
                            slice: (start?: number, end?: number) => Int8Array<ArrayBuffer>;
                            some: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Int8Array<ArrayBufferLike>;
                            subarray: (begin?: number, end?: number) => Int8Array<ArrayBufferLike>;
                            toLocaleString: {
                                (): string;
                                (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                            };
                            toString: () => string;
                            valueOf: () => Int8Array<ArrayBufferLike>;
                            entries: () => ArrayIterator<[number, number]>;
                            keys: () => ArrayIterator<number>;
                            values: () => ArrayIterator<number>;
                            includes: (searchElement: number, fromIndex?: number) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                            toReversed: () => Int8Array<ArrayBuffer>;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Int8Array<ArrayBuffer>;
                            with: (index: number, value: number) => Int8Array<ArrayBuffer>;
                            [Symbol.iterator]: () => ArrayIterator<number>;
                            readonly [Symbol.toStringTag]: "Int8Array";
                        } | {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin?: number, end?: number) => ArrayBuffer;
                                readonly maxByteLength: number;
                                readonly resizable: boolean;
                                resize: (newByteLength?: number) => void;
                                readonly detached: boolean;
                                transfer: (newByteLength?: number) => ArrayBuffer;
                                transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin?: number, end?: number) => SharedArrayBuffer;
                                readonly growable: boolean;
                                readonly maxByteLength: number;
                                grow: (newByteLength?: number) => void;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number) => Uint8Array<ArrayBufferLike>;
                            every: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number, end?: number) => Uint8Array<ArrayBufferLike>;
                            filter: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => any, thisArg?: any) => Uint8Array<ArrayBuffer>;
                            find: (predicate: (value: number, index: number, obj: Uint8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Uint8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number) => number;
                            join: (separator?: string) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => number, thisArg?: any) => Uint8Array<ArrayBuffer>;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => U, initialValue: U): U;
                            };
                            reverse: () => Uint8Array<ArrayBufferLike>;
                            set: (array: ArrayLike<number>, offset?: number) => void;
                            slice: (start?: number, end?: number) => Uint8Array<ArrayBuffer>;
                            some: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8Array<ArrayBufferLike>;
                            subarray: (begin?: number, end?: number) => Uint8Array<ArrayBufferLike>;
                            toLocaleString: {
                                (): string;
                                (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                            };
                            toString: () => string;
                            valueOf: () => Uint8Array<ArrayBufferLike>;
                            entries: () => ArrayIterator<[number, number]>;
                            keys: () => ArrayIterator<number>;
                            values: () => ArrayIterator<number>;
                            includes: (searchElement: number, fromIndex?: number) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                            toReversed: () => Uint8Array<ArrayBuffer>;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8Array<ArrayBuffer>;
                            with: (index: number, value: number) => Uint8Array<ArrayBuffer>;
                            [Symbol.iterator]: () => ArrayIterator<number>;
                            readonly [Symbol.toStringTag]: "Uint8Array";
                        } | {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin?: number, end?: number) => ArrayBuffer;
                                readonly maxByteLength: number;
                                readonly resizable: boolean;
                                resize: (newByteLength?: number) => void;
                                readonly detached: boolean;
                                transfer: (newByteLength?: number) => ArrayBuffer;
                                transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin?: number, end?: number) => SharedArrayBuffer;
                                readonly growable: boolean;
                                readonly maxByteLength: number;
                                grow: (newByteLength?: number) => void;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number) => Uint8ClampedArray<ArrayBufferLike>;
                            every: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number, end?: number) => Uint8ClampedArray<ArrayBufferLike>;
                            filter: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => any, thisArg?: any) => Uint8ClampedArray<ArrayBuffer>;
                            find: (predicate: (value: number, index: number, obj: Uint8ClampedArray<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Uint8ClampedArray<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number) => number;
                            join: (separator?: string) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => number, thisArg?: any) => Uint8ClampedArray<ArrayBuffer>;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => U, initialValue: U): U;
                            };
                            reverse: () => Uint8ClampedArray<ArrayBufferLike>;
                            set: (array: ArrayLike<number>, offset?: number) => void;
                            slice: (start?: number, end?: number) => Uint8ClampedArray<ArrayBuffer>;
                            some: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8ClampedArray<ArrayBufferLike>;
                            subarray: (begin?: number, end?: number) => Uint8ClampedArray<ArrayBufferLike>;
                            toLocaleString: {
                                (): string;
                                (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                            };
                            toString: () => string;
                            valueOf: () => Uint8ClampedArray<ArrayBufferLike>;
                            entries: () => ArrayIterator<[number, number]>;
                            keys: () => ArrayIterator<number>;
                            values: () => ArrayIterator<number>;
                            includes: (searchElement: number, fromIndex?: number) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                            toReversed: () => Uint8ClampedArray<ArrayBuffer>;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8ClampedArray<ArrayBuffer>;
                            with: (index: number, value: number) => Uint8ClampedArray<ArrayBuffer>;
                            [Symbol.iterator]: () => ArrayIterator<number>;
                            readonly [Symbol.toStringTag]: "Uint8ClampedArray";
                        } | {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin?: number, end?: number) => ArrayBuffer;
                                readonly maxByteLength: number;
                                readonly resizable: boolean;
                                resize: (newByteLength?: number) => void;
                                readonly detached: boolean;
                                transfer: (newByteLength?: number) => ArrayBuffer;
                                transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin?: number, end?: number) => SharedArrayBuffer;
                                readonly growable: boolean;
                                readonly maxByteLength: number;
                                grow: (newByteLength?: number) => void;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number) => Int16Array<ArrayBufferLike>;
                            every: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number, end?: number) => Int16Array<ArrayBufferLike>;
                            filter: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => any, thisArg?: any) => Int16Array<ArrayBuffer>;
                            find: (predicate: (value: number, index: number, obj: Int16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Int16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number) => number;
                            join: (separator?: string) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => number, thisArg?: any) => Int16Array<ArrayBuffer>;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => U, initialValue: U): U;
                            };
                            reverse: () => Int16Array<ArrayBufferLike>;
                            set: (array: ArrayLike<number>, offset?: number) => void;
                            slice: (start?: number, end?: number) => Int16Array<ArrayBuffer>;
                            some: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Int16Array<ArrayBufferLike>;
                            subarray: (begin?: number, end?: number) => Int16Array<ArrayBufferLike>;
                            toLocaleString: {
                                (): string;
                                (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                            };
                            toString: () => string;
                            valueOf: () => Int16Array<ArrayBufferLike>;
                            entries: () => ArrayIterator<[number, number]>;
                            keys: () => ArrayIterator<number>;
                            values: () => ArrayIterator<number>;
                            includes: (searchElement: number, fromIndex?: number) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                            toReversed: () => Int16Array<ArrayBuffer>;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Int16Array<ArrayBuffer>;
                            with: (index: number, value: number) => Int16Array<ArrayBuffer>;
                            [Symbol.iterator]: () => ArrayIterator<number>;
                            readonly [Symbol.toStringTag]: "Int16Array";
                        } | {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin?: number, end?: number) => ArrayBuffer;
                                readonly maxByteLength: number;
                                readonly resizable: boolean;
                                resize: (newByteLength?: number) => void;
                                readonly detached: boolean;
                                transfer: (newByteLength?: number) => ArrayBuffer;
                                transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin?: number, end?: number) => SharedArrayBuffer;
                                readonly growable: boolean;
                                readonly maxByteLength: number;
                                grow: (newByteLength?: number) => void;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number) => Uint16Array<ArrayBufferLike>;
                            every: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number, end?: number) => Uint16Array<ArrayBufferLike>;
                            filter: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => any, thisArg?: any) => Uint16Array<ArrayBuffer>;
                            find: (predicate: (value: number, index: number, obj: Uint16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Uint16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number) => number;
                            join: (separator?: string) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => number, thisArg?: any) => Uint16Array<ArrayBuffer>;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => U, initialValue: U): U;
                            };
                            reverse: () => Uint16Array<ArrayBufferLike>;
                            set: (array: ArrayLike<number>, offset?: number) => void;
                            slice: (start?: number, end?: number) => Uint16Array<ArrayBuffer>;
                            some: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint16Array<ArrayBufferLike>;
                            subarray: (begin?: number, end?: number) => Uint16Array<ArrayBufferLike>;
                            toLocaleString: {
                                (): string;
                                (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                            };
                            toString: () => string;
                            valueOf: () => Uint16Array<ArrayBufferLike>;
                            entries: () => ArrayIterator<[number, number]>;
                            keys: () => ArrayIterator<number>;
                            values: () => ArrayIterator<number>;
                            includes: (searchElement: number, fromIndex?: number) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                            toReversed: () => Uint16Array<ArrayBuffer>;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint16Array<ArrayBuffer>;
                            with: (index: number, value: number) => Uint16Array<ArrayBuffer>;
                            [Symbol.iterator]: () => ArrayIterator<number>;
                            readonly [Symbol.toStringTag]: "Uint16Array";
                        } | {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin?: number, end?: number) => ArrayBuffer;
                                readonly maxByteLength: number;
                                readonly resizable: boolean;
                                resize: (newByteLength?: number) => void;
                                readonly detached: boolean;
                                transfer: (newByteLength?: number) => ArrayBuffer;
                                transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin?: number, end?: number) => SharedArrayBuffer;
                                readonly growable: boolean;
                                readonly maxByteLength: number;
                                grow: (newByteLength?: number) => void;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number) => Int32Array<ArrayBufferLike>;
                            every: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number, end?: number) => Int32Array<ArrayBufferLike>;
                            filter: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => any, thisArg?: any) => Int32Array<ArrayBuffer>;
                            find: (predicate: (value: number, index: number, obj: Int32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Int32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number) => number;
                            join: (separator?: string) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => number, thisArg?: any) => Int32Array<ArrayBuffer>;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => U, initialValue: U): U;
                            };
                            reverse: () => Int32Array<ArrayBufferLike>;
                            set: (array: ArrayLike<number>, offset?: number) => void;
                            slice: (start?: number, end?: number) => Int32Array<ArrayBuffer>;
                            some: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Int32Array<ArrayBufferLike>;
                            subarray: (begin?: number, end?: number) => Int32Array<ArrayBufferLike>;
                            toLocaleString: {
                                (): string;
                                (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                            };
                            toString: () => string;
                            valueOf: () => Int32Array<ArrayBufferLike>;
                            entries: () => ArrayIterator<[number, number]>;
                            keys: () => ArrayIterator<number>;
                            values: () => ArrayIterator<number>;
                            includes: (searchElement: number, fromIndex?: number) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                            toReversed: () => Int32Array<ArrayBuffer>;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Int32Array<ArrayBuffer>;
                            with: (index: number, value: number) => Int32Array<ArrayBuffer>;
                            [Symbol.iterator]: () => ArrayIterator<number>;
                            readonly [Symbol.toStringTag]: "Int32Array";
                        } | {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin?: number, end?: number) => ArrayBuffer;
                                readonly maxByteLength: number;
                                readonly resizable: boolean;
                                resize: (newByteLength?: number) => void;
                                readonly detached: boolean;
                                transfer: (newByteLength?: number) => ArrayBuffer;
                                transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin?: number, end?: number) => SharedArrayBuffer;
                                readonly growable: boolean;
                                readonly maxByteLength: number;
                                grow: (newByteLength?: number) => void;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number) => Uint32Array<ArrayBufferLike>;
                            every: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number, end?: number) => Uint32Array<ArrayBufferLike>;
                            filter: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => any, thisArg?: any) => Uint32Array<ArrayBuffer>;
                            find: (predicate: (value: number, index: number, obj: Uint32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Uint32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number) => number;
                            join: (separator?: string) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => number, thisArg?: any) => Uint32Array<ArrayBuffer>;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => U, initialValue: U): U;
                            };
                            reverse: () => Uint32Array<ArrayBufferLike>;
                            set: (array: ArrayLike<number>, offset?: number) => void;
                            slice: (start?: number, end?: number) => Uint32Array<ArrayBuffer>;
                            some: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint32Array<ArrayBufferLike>;
                            subarray: (begin?: number, end?: number) => Uint32Array<ArrayBufferLike>;
                            toLocaleString: {
                                (): string;
                                (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                            };
                            toString: () => string;
                            valueOf: () => Uint32Array<ArrayBufferLike>;
                            entries: () => ArrayIterator<[number, number]>;
                            keys: () => ArrayIterator<number>;
                            values: () => ArrayIterator<number>;
                            includes: (searchElement: number, fromIndex?: number) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                            toReversed: () => Uint32Array<ArrayBuffer>;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint32Array<ArrayBuffer>;
                            with: (index: number, value: number) => Uint32Array<ArrayBuffer>;
                            [Symbol.iterator]: () => ArrayIterator<number>;
                            readonly [Symbol.toStringTag]: "Uint32Array";
                        } | {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin?: number, end?: number) => ArrayBuffer;
                                readonly maxByteLength: number;
                                readonly resizable: boolean;
                                resize: (newByteLength?: number) => void;
                                readonly detached: boolean;
                                transfer: (newByteLength?: number) => ArrayBuffer;
                                transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin?: number, end?: number) => SharedArrayBuffer;
                                readonly growable: boolean;
                                readonly maxByteLength: number;
                                grow: (newByteLength?: number) => void;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number) => Float32Array<ArrayBufferLike>;
                            every: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number, end?: number) => Float32Array<ArrayBufferLike>;
                            filter: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => any, thisArg?: any) => Float32Array<ArrayBuffer>;
                            find: (predicate: (value: number, index: number, obj: Float32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number) => number;
                            join: (separator?: string) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => number, thisArg?: any) => Float32Array<ArrayBuffer>;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => U, initialValue: U): U;
                            };
                            reverse: () => Float32Array<ArrayBufferLike>;
                            set: (array: ArrayLike<number>, offset?: number) => void;
                            slice: (start?: number, end?: number) => Float32Array<ArrayBuffer>;
                            some: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array<ArrayBufferLike>;
                            subarray: (begin?: number, end?: number) => Float32Array<ArrayBufferLike>;
                            toLocaleString: {
                                (): string;
                                (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                            };
                            toString: () => string;
                            valueOf: () => Float32Array<ArrayBufferLike>;
                            entries: () => ArrayIterator<[number, number]>;
                            keys: () => ArrayIterator<number>;
                            values: () => ArrayIterator<number>;
                            includes: (searchElement: number, fromIndex?: number) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                            toReversed: () => Float32Array<ArrayBuffer>;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array<ArrayBuffer>;
                            with: (index: number, value: number) => Float32Array<ArrayBuffer>;
                            [Symbol.iterator]: () => ArrayIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        } | {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin?: number, end?: number) => ArrayBuffer;
                                readonly maxByteLength: number;
                                readonly resizable: boolean;
                                resize: (newByteLength?: number) => void;
                                readonly detached: boolean;
                                transfer: (newByteLength?: number) => ArrayBuffer;
                                transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin?: number, end?: number) => SharedArrayBuffer;
                                readonly growable: boolean;
                                readonly maxByteLength: number;
                                grow: (newByteLength?: number) => void;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number) => Float64Array<ArrayBufferLike>;
                            every: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number, end?: number) => Float64Array<ArrayBufferLike>;
                            filter: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => any, thisArg?: any) => Float64Array<ArrayBuffer>;
                            find: (predicate: (value: number, index: number, obj: Float64Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float64Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number) => number;
                            join: (separator?: string) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => number, thisArg?: any) => Float64Array<ArrayBuffer>;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => U, initialValue: U): U;
                            };
                            reverse: () => Float64Array<ArrayBufferLike>;
                            set: (array: ArrayLike<number>, offset?: number) => void;
                            slice: (start?: number, end?: number) => Float64Array<ArrayBuffer>;
                            some: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float64Array<ArrayBufferLike>;
                            subarray: (begin?: number, end?: number) => Float64Array<ArrayBufferLike>;
                            toLocaleString: {
                                (): string;
                                (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                            };
                            toString: () => string;
                            valueOf: () => Float64Array<ArrayBufferLike>;
                            entries: () => ArrayIterator<[number, number]>;
                            keys: () => ArrayIterator<number>;
                            values: () => ArrayIterator<number>;
                            includes: (searchElement: number, fromIndex?: number) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                            toReversed: () => Float64Array<ArrayBuffer>;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float64Array<ArrayBuffer>;
                            with: (index: number, value: number) => Float64Array<ArrayBuffer>;
                            [Symbol.iterator]: () => ArrayIterator<number>;
                            readonly [Symbol.toStringTag]: "Float64Array";
                        };
                        width: number;
                        height: number;
                    }[] | /*elided*/ any[];
                    channel: number;
                    wrapS: import('three').Wrapping;
                    wrapT: import('three').Wrapping;
                    magFilter: import('three').MagnificationTextureFilter;
                    minFilter: import('three').MinificationTextureFilter;
                    anisotropy: number;
                    format: import('three').AnyPixelFormat;
                    type: import('three').TextureDataType;
                    internalFormat: import('three').PixelFormatGPU | null;
                    matrix: {
                        readonly isMatrix3: true;
                        elements: [n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number];
                        set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import('three').Matrix3;
                        identity: () => import('three').Matrix3;
                        copy: (m: import('three').Matrix3) => import('three').Matrix3;
                        extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix3;
                        setFromMatrix4: (m: import('three').Matrix4) => import('three').Matrix3;
                        multiply: (m: import('three').Matrix3) => import('three').Matrix3;
                        premultiply: (m: import('three').Matrix3) => import('three').Matrix3;
                        multiplyMatrices: (a: import('three').Matrix3, b: import('three').Matrix3) => import('three').Matrix3;
                        multiplyScalar: (s: number) => import('three').Matrix3;
                        determinant: () => number;
                        invert: () => import('three').Matrix3;
                        transpose: () => import('three').Matrix3;
                        getNormalMatrix: (matrix4: import('three').Matrix4) => import('three').Matrix3;
                        transposeIntoArray: (r: number[]) => import('three').Matrix3;
                        setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import('three').Matrix3;
                        scale: (sx: number, sy: number) => import('three').Matrix3;
                        rotate: (theta: number) => import('three').Matrix3;
                        translate: (tx: number, ty: number) => import('three').Matrix3;
                        makeTranslation: {
                            (v: import('three').Vector2): import('three').Matrix3;
                            (x: number, y: number): import('three').Matrix3;
                        };
                        makeRotation: (theta: number) => import('three').Matrix3;
                        makeScale: (x: number, y: number) => import('three').Matrix3;
                        equals: (matrix: import('three').Matrix3) => boolean;
                        fromArray: (array: ArrayLike<number>, offset?: number) => import('three').Matrix3;
                        toArray: {
                            (): import('three').Matrix3Tuple;
                            <TArray extends ArrayLike<number>>(array: TArray, offset?: number): TArray;
                        };
                        clone: () => import('three').Matrix3;
                    };
                    matrixAutoUpdate: boolean;
                    offset: {
                        x: number;
                        y: number;
                        width: number;
                        height: number;
                        readonly isVector2: true;
                        set: (x: number, y: number) => import('three').Vector2;
                        setScalar: (scalar: number) => import('three').Vector2;
                        setX: (x: number) => import('three').Vector2;
                        setY: (y: number) => import('three').Vector2;
                        setComponent: (index: number, value: number) => import('three').Vector2;
                        getComponent: (index: number) => number;
                        clone: () => import('three').Vector2;
                        copy: (v: import('three').Vector2Like) => import('three').Vector2;
                        add: (v: import('three').Vector2Like) => import('three').Vector2;
                        addScalar: (s: number) => import('three').Vector2;
                        addVectors: (a: import('three').Vector2Like, b: import('three').Vector2Like) => import('three').Vector2;
                        addScaledVector: (v: import('three').Vector2Like, s: number) => import('three').Vector2;
                        sub: (v: import('three').Vector2Like) => import('three').Vector2;
                        subScalar: (s: number) => import('three').Vector2;
                        subVectors: (a: import('three').Vector2Like, b: import('three').Vector2Like) => import('three').Vector2;
                        multiply: (v: import('three').Vector2Like) => import('three').Vector2;
                        multiplyScalar: (scalar: number) => import('three').Vector2;
                        divide: (v: import('three').Vector2Like) => import('three').Vector2;
                        divideScalar: (s: number) => import('three').Vector2;
                        applyMatrix3: (m: import('three').Matrix3) => import('three').Vector2;
                        min: (v: import('three').Vector2Like) => import('three').Vector2;
                        max: (v: import('three').Vector2Like) => import('three').Vector2;
                        clamp: (min: import('three').Vector2Like, max: import('three').Vector2Like) => import('three').Vector2;
                        clampScalar: (min: number, max: number) => import('three').Vector2;
                        clampLength: (min: number, max: number) => import('three').Vector2;
                        floor: () => import('three').Vector2;
                        ceil: () => import('three').Vector2;
                        round: () => import('three').Vector2;
                        roundToZero: () => import('three').Vector2;
                        negate: () => import('three').Vector2;
                        dot: (v: import('three').Vector2Like) => number;
                        cross: (v: import('three').Vector2Like) => number;
                        lengthSq: () => number;
                        length: () => number;
                        manhattanLength: () => number;
                        normalize: () => import('three').Vector2;
                        angle: () => number;
                        angleTo: (v: import('three').Vector2) => number;
                        distanceTo: (v: import('three').Vector2Like) => number;
                        distanceToSquared: (v: import('three').Vector2Like) => number;
                        manhattanDistanceTo: (v: import('three').Vector2Like) => number;
                        setLength: (length: number) => import('three').Vector2;
                        lerp: (v: import('three').Vector2Like, alpha: number) => import('three').Vector2;
                        lerpVectors: (v1: import('three').Vector2Like, v2: import('three').Vector2Like, alpha: number) => import('three').Vector2;
                        equals: (v: import('three').Vector2Like) => boolean;
                        fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector2;
                        toArray: {
                            (array?: number[], offset?: number): number[];
                            (array?: import('three').Vector2Tuple, offset?: 0): import('three').Vector2Tuple;
                            (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                        };
                        fromBufferAttribute: (attribute: import('three').BufferAttribute, index: number) => import('three').Vector2;
                        rotateAround: (center: import('three').Vector2Like, angle: number) => import('three').Vector2;
                        random: () => import('three').Vector2;
                        [Symbol.iterator]: () => Iterator<number>;
                    };
                    repeat: {
                        x: number;
                        y: number;
                        width: number;
                        height: number;
                        readonly isVector2: true;
                        set: (x: number, y: number) => import('three').Vector2;
                        setScalar: (scalar: number) => import('three').Vector2;
                        setX: (x: number) => import('three').Vector2;
                        setY: (y: number) => import('three').Vector2;
                        setComponent: (index: number, value: number) => import('three').Vector2;
                        getComponent: (index: number) => number;
                        clone: () => import('three').Vector2;
                        copy: (v: import('three').Vector2Like) => import('three').Vector2;
                        add: (v: import('three').Vector2Like) => import('three').Vector2;
                        addScalar: (s: number) => import('three').Vector2;
                        addVectors: (a: import('three').Vector2Like, b: import('three').Vector2Like) => import('three').Vector2;
                        addScaledVector: (v: import('three').Vector2Like, s: number) => import('three').Vector2;
                        sub: (v: import('three').Vector2Like) => import('three').Vector2;
                        subScalar: (s: number) => import('three').Vector2;
                        subVectors: (a: import('three').Vector2Like, b: import('three').Vector2Like) => import('three').Vector2;
                        multiply: (v: import('three').Vector2Like) => import('three').Vector2;
                        multiplyScalar: (scalar: number) => import('three').Vector2;
                        divide: (v: import('three').Vector2Like) => import('three').Vector2;
                        divideScalar: (s: number) => import('three').Vector2;
                        applyMatrix3: (m: import('three').Matrix3) => import('three').Vector2;
                        min: (v: import('three').Vector2Like) => import('three').Vector2;
                        max: (v: import('three').Vector2Like) => import('three').Vector2;
                        clamp: (min: import('three').Vector2Like, max: import('three').Vector2Like) => import('three').Vector2;
                        clampScalar: (min: number, max: number) => import('three').Vector2;
                        clampLength: (min: number, max: number) => import('three').Vector2;
                        floor: () => import('three').Vector2;
                        ceil: () => import('three').Vector2;
                        round: () => import('three').Vector2;
                        roundToZero: () => import('three').Vector2;
                        negate: () => import('three').Vector2;
                        dot: (v: import('three').Vector2Like) => number;
                        cross: (v: import('three').Vector2Like) => number;
                        lengthSq: () => number;
                        length: () => number;
                        manhattanLength: () => number;
                        normalize: () => import('three').Vector2;
                        angle: () => number;
                        angleTo: (v: import('three').Vector2) => number;
                        distanceTo: (v: import('three').Vector2Like) => number;
                        distanceToSquared: (v: import('three').Vector2Like) => number;
                        manhattanDistanceTo: (v: import('three').Vector2Like) => number;
                        setLength: (length: number) => import('three').Vector2;
                        lerp: (v: import('three').Vector2Like, alpha: number) => import('three').Vector2;
                        lerpVectors: (v1: import('three').Vector2Like, v2: import('three').Vector2Like, alpha: number) => import('three').Vector2;
                        equals: (v: import('three').Vector2Like) => boolean;
                        fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector2;
                        toArray: {
                            (array?: number[], offset?: number): number[];
                            (array?: import('three').Vector2Tuple, offset?: 0): import('three').Vector2Tuple;
                            (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                        };
                        fromBufferAttribute: (attribute: import('three').BufferAttribute, index: number) => import('three').Vector2;
                        rotateAround: (center: import('three').Vector2Like, angle: number) => import('three').Vector2;
                        random: () => import('three').Vector2;
                        [Symbol.iterator]: () => Iterator<number>;
                    };
                    center: {
                        x: number;
                        y: number;
                        width: number;
                        height: number;
                        readonly isVector2: true;
                        set: (x: number, y: number) => import('three').Vector2;
                        setScalar: (scalar: number) => import('three').Vector2;
                        setX: (x: number) => import('three').Vector2;
                        setY: (y: number) => import('three').Vector2;
                        setComponent: (index: number, value: number) => import('three').Vector2;
                        getComponent: (index: number) => number;
                        clone: () => import('three').Vector2;
                        copy: (v: import('three').Vector2Like) => import('three').Vector2;
                        add: (v: import('three').Vector2Like) => import('three').Vector2;
                        addScalar: (s: number) => import('three').Vector2;
                        addVectors: (a: import('three').Vector2Like, b: import('three').Vector2Like) => import('three').Vector2;
                        addScaledVector: (v: import('three').Vector2Like, s: number) => import('three').Vector2;
                        sub: (v: import('three').Vector2Like) => import('three').Vector2;
                        subScalar: (s: number) => import('three').Vector2;
                        subVectors: (a: import('three').Vector2Like, b: import('three').Vector2Like) => import('three').Vector2;
                        multiply: (v: import('three').Vector2Like) => import('three').Vector2;
                        multiplyScalar: (scalar: number) => import('three').Vector2;
                        divide: (v: import('three').Vector2Like) => import('three').Vector2;
                        divideScalar: (s: number) => import('three').Vector2;
                        applyMatrix3: (m: import('three').Matrix3) => import('three').Vector2;
                        min: (v: import('three').Vector2Like) => import('three').Vector2;
                        max: (v: import('three').Vector2Like) => import('three').Vector2;
                        clamp: (min: import('three').Vector2Like, max: import('three').Vector2Like) => import('three').Vector2;
                        clampScalar: (min: number, max: number) => import('three').Vector2;
                        clampLength: (min: number, max: number) => import('three').Vector2;
                        floor: () => import('three').Vector2;
                        ceil: () => import('three').Vector2;
                        round: () => import('three').Vector2;
                        roundToZero: () => import('three').Vector2;
                        negate: () => import('three').Vector2;
                        dot: (v: import('three').Vector2Like) => number;
                        cross: (v: import('three').Vector2Like) => number;
                        lengthSq: () => number;
                        length: () => number;
                        manhattanLength: () => number;
                        normalize: () => import('three').Vector2;
                        angle: () => number;
                        angleTo: (v: import('three').Vector2) => number;
                        distanceTo: (v: import('three').Vector2Like) => number;
                        distanceToSquared: (v: import('three').Vector2Like) => number;
                        manhattanDistanceTo: (v: import('three').Vector2Like) => number;
                        setLength: (length: number) => import('three').Vector2;
                        lerp: (v: import('three').Vector2Like, alpha: number) => import('three').Vector2;
                        lerpVectors: (v1: import('three').Vector2Like, v2: import('three').Vector2Like, alpha: number) => import('three').Vector2;
                        equals: (v: import('three').Vector2Like) => boolean;
                        fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector2;
                        toArray: {
                            (array?: number[], offset?: number): number[];
                            (array?: import('three').Vector2Tuple, offset?: 0): import('three').Vector2Tuple;
                            (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                        };
                        fromBufferAttribute: (attribute: import('three').BufferAttribute, index: number) => import('three').Vector2;
                        rotateAround: (center: import('three').Vector2Like, angle: number) => import('three').Vector2;
                        random: () => import('three').Vector2;
                        [Symbol.iterator]: () => Iterator<number>;
                    };
                    rotation: number;
                    generateMipmaps: boolean;
                    premultiplyAlpha: boolean;
                    unpackAlignment: number;
                    colorSpace: string;
                    isRenderTargetTexture: boolean;
                    isArrayTexture: boolean;
                    userData: Record<string, any>;
                    updateRanges: {
                        start: number;
                        count: number;
                    }[];
                    version: number;
                    pmremVersion: number;
                    needsUpdate: boolean;
                    needsPMREMUpdate: boolean;
                    renderTarget: {
                        readonly isRenderTarget: true;
                        width: number;
                        height: number;
                        depth: number;
                        scissor: {
                            x: number;
                            y: number;
                            z: number;
                            w: number;
                            width: number;
                            height: number;
                            readonly isVector4: true;
                            set: (x: number, y: number, z: number, w: number) => import('three').Vector4;
                            setScalar: (scalar: number) => import('three').Vector4;
                            setX: (x: number) => import('three').Vector4;
                            setY: (y: number) => import('three').Vector4;
                            setZ: (z: number) => import('three').Vector4;
                            setW: (w: number) => import('three').Vector4;
                            setComponent: (index: number, value: number) => import('three').Vector4;
                            getComponent: (index: number) => number;
                            clone: () => import('three').Vector4;
                            copy: (v: import('three').Vector4Like) => import('three').Vector4;
                            add: (v: import('three').Vector4Like) => import('three').Vector4;
                            addScalar: (scalar: number) => import('three').Vector4;
                            addVectors: (a: import('three').Vector4Like, b: import('three').Vector4Like) => import('three').Vector4;
                            addScaledVector: (v: import('three').Vector4Like, s: number) => import('three').Vector4;
                            sub: (v: import('three').Vector4Like) => import('three').Vector4;
                            subScalar: (s: number) => import('three').Vector4;
                            subVectors: (a: import('three').Vector4Like, b: import('three').Vector4Like) => import('three').Vector4;
                            multiply: (v: import('three').Vector4Like) => import('three').Vector4;
                            multiplyScalar: (s: number) => import('three').Vector4;
                            applyMatrix4: (m: import('three').Matrix4) => import('three').Vector4;
                            divide: (v: import('three').Vector4Like) => import('three').Vector4;
                            divideScalar: (s: number) => import('three').Vector4;
                            setAxisAngleFromQuaternion: (q: import('three').QuaternionLike) => import('three').Vector4;
                            setAxisAngleFromRotationMatrix: (m: import('three').Matrix4) => import('three').Vector4;
                            setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector4;
                            min: (v: import('three').Vector4Like) => import('three').Vector4;
                            max: (v: import('three').Vector4Like) => import('three').Vector4;
                            clamp: (min: import('three').Vector4Like, max: import('three').Vector4Like) => import('three').Vector4;
                            clampScalar: (min: number, max: number) => import('three').Vector4;
                            floor: () => import('three').Vector4;
                            ceil: () => import('three').Vector4;
                            round: () => import('three').Vector4;
                            roundToZero: () => import('three').Vector4;
                            negate: () => import('three').Vector4;
                            dot: (v: import('three').Vector4Like) => number;
                            lengthSq: () => number;
                            length: () => number;
                            manhattanLength: () => number;
                            normalize: () => import('three').Vector4;
                            setLength: (length: number) => import('three').Vector4;
                            lerp: (v: import('three').Vector4Like, alpha: number) => import('three').Vector4;
                            lerpVectors: (v1: import('three').Vector4Like, v2: import('three').Vector4Like, alpha: number) => import('three').Vector4;
                            equals: (v: import('three').Vector4Like) => boolean;
                            fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector4;
                            toArray: {
                                (array?: number[], offset?: number): number[];
                                (array?: import('three').Vector4Tuple, offset?: 0): import('three').Vector4Tuple;
                                (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                            };
                            fromBufferAttribute: (attribute: import('three').BufferAttribute, index: number) => import('three').Vector4;
                            random: () => import('three').Vector4;
                            [Symbol.iterator]: () => Iterator<number>;
                        };
                        scissorTest: boolean;
                        viewport: {
                            x: number;
                            y: number;
                            z: number;
                            w: number;
                            width: number;
                            height: number;
                            readonly isVector4: true;
                            set: (x: number, y: number, z: number, w: number) => import('three').Vector4;
                            setScalar: (scalar: number) => import('three').Vector4;
                            setX: (x: number) => import('three').Vector4;
                            setY: (y: number) => import('three').Vector4;
                            setZ: (z: number) => import('three').Vector4;
                            setW: (w: number) => import('three').Vector4;
                            setComponent: (index: number, value: number) => import('three').Vector4;
                            getComponent: (index: number) => number;
                            clone: () => import('three').Vector4;
                            copy: (v: import('three').Vector4Like) => import('three').Vector4;
                            add: (v: import('three').Vector4Like) => import('three').Vector4;
                            addScalar: (scalar: number) => import('three').Vector4;
                            addVectors: (a: import('three').Vector4Like, b: import('three').Vector4Like) => import('three').Vector4;
                            addScaledVector: (v: import('three').Vector4Like, s: number) => import('three').Vector4;
                            sub: (v: import('three').Vector4Like) => import('three').Vector4;
                            subScalar: (s: number) => import('three').Vector4;
                            subVectors: (a: import('three').Vector4Like, b: import('three').Vector4Like) => import('three').Vector4;
                            multiply: (v: import('three').Vector4Like) => import('three').Vector4;
                            multiplyScalar: (s: number) => import('three').Vector4;
                            applyMatrix4: (m: import('three').Matrix4) => import('three').Vector4;
                            divide: (v: import('three').Vector4Like) => import('three').Vector4;
                            divideScalar: (s: number) => import('three').Vector4;
                            setAxisAngleFromQuaternion: (q: import('three').QuaternionLike) => import('three').Vector4;
                            setAxisAngleFromRotationMatrix: (m: import('three').Matrix4) => import('three').Vector4;
                            setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector4;
                            min: (v: import('three').Vector4Like) => import('three').Vector4;
                            max: (v: import('three').Vector4Like) => import('three').Vector4;
                            clamp: (min: import('three').Vector4Like, max: import('three').Vector4Like) => import('three').Vector4;
                            clampScalar: (min: number, max: number) => import('three').Vector4;
                            floor: () => import('three').Vector4;
                            ceil: () => import('three').Vector4;
                            round: () => import('three').Vector4;
                            roundToZero: () => import('three').Vector4;
                            negate: () => import('three').Vector4;
                            dot: (v: import('three').Vector4Like) => number;
                            lengthSq: () => number;
                            length: () => number;
                            manhattanLength: () => number;
                            normalize: () => import('three').Vector4;
                            setLength: (length: number) => import('three').Vector4;
                            lerp: (v: import('three').Vector4Like, alpha: number) => import('three').Vector4;
                            lerpVectors: (v1: import('three').Vector4Like, v2: import('three').Vector4Like, alpha: number) => import('three').Vector4;
                            equals: (v: import('three').Vector4Like) => boolean;
                            fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector4;
                            toArray: {
                                (array?: number[], offset?: number): number[];
                                (array?: import('three').Vector4Tuple, offset?: 0): import('three').Vector4Tuple;
                                (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                            };
                            fromBufferAttribute: (attribute: import('three').BufferAttribute, index: number) => import('three').Vector4;
                            random: () => import('three').Vector4;
                            [Symbol.iterator]: () => Iterator<number>;
                        };
                        textures: /*elided*/ any[];
                        depthBuffer: boolean;
                        stencilBuffer: boolean;
                        resolveDepthBuffer: boolean;
                        resolveStencilBuffer: boolean;
                        samples: number;
                        multiview: boolean;
                        texture: /*elided*/ any;
                        depthTexture: {
                            readonly isDepthTexture: true;
                            image: {
                                width: number;
                                height: number;
                                depth: number;
                            };
                            flipY: boolean;
                            magFilter: import('three').MagnificationTextureFilter;
                            minFilter: import('three').MinificationTextureFilter;
                            generateMipmaps: boolean;
                            format: import('three').DepthTexturePixelFormat;
                            type: import('three').TextureDataType;
                            compareFunction: import('three').TextureComparisonFunction | null;
                            readonly isTexture: true;
                            readonly id: number;
                            uuid: string;
                            name: string;
                            source: {
                                readonly isSource: true;
                                readonly id: number;
                                uuid: string;
                                data: any;
                                dataReady: boolean;
                                version: number;
                                getSize: (target: import('three').Vector3) => import('three').Vector3;
                                needsUpdate: boolean;
                                toJSON: (meta?: string | {}) => import('three').SourceJSON;
                            };
                            readonly width: number;
                            readonly height: number;
                            readonly depth: number;
                            mipmaps: HTMLCanvasElement[] | {
                                data: {
                                    [x: number]: number;
                                    readonly BYTES_PER_ELEMENT: number;
                                    readonly buffer: {
                                        readonly byteLength: number;
                                        slice: (begin?: number, end?: number) => ArrayBuffer;
                                        readonly maxByteLength: number;
                                        readonly resizable: boolean;
                                        resize: (newByteLength?: number) => void;
                                        readonly detached: boolean;
                                        transfer: (newByteLength?: number) => ArrayBuffer;
                                        transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                                        readonly [Symbol.toStringTag]: string;
                                    } | {
                                        readonly byteLength: number;
                                        slice: (begin?: number, end?: number) => SharedArrayBuffer;
                                        readonly growable: boolean;
                                        readonly maxByteLength: number;
                                        grow: (newByteLength?: number) => void;
                                        readonly [Symbol.species]: SharedArrayBuffer;
                                        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                                    };
                                    readonly byteLength: number;
                                    readonly byteOffset: number;
                                    copyWithin: (target: number, start: number, end?: number) => Int8Array<ArrayBufferLike>;
                                    every: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                    fill: (value: number, start?: number, end?: number) => Int8Array<ArrayBufferLike>;
                                    filter: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => any, thisArg?: any) => Int8Array<ArrayBuffer>;
                                    find: (predicate: (value: number, index: number, obj: Int8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                                    findIndex: (predicate: (value: number, index: number, obj: Int8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                                    forEach: (callbackfn: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                                    indexOf: (searchElement: number, fromIndex?: number) => number;
                                    join: (separator?: string) => string;
                                    lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                                    readonly length: number;
                                    map: (callbackfn: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => number, thisArg?: any) => Int8Array<ArrayBuffer>;
                                    reduce: {
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number): number;
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number, initialValue: number): number;
                                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => U, initialValue: U): U;
                                    };
                                    reduceRight: {
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number): number;
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number, initialValue: number): number;
                                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => U, initialValue: U): U;
                                    };
                                    reverse: () => Int8Array<ArrayBufferLike>;
                                    set: (array: ArrayLike<number>, offset?: number) => void;
                                    slice: (start?: number, end?: number) => Int8Array<ArrayBuffer>;
                                    some: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                    sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Int8Array<ArrayBufferLike>;
                                    subarray: (begin?: number, end?: number) => Int8Array<ArrayBufferLike>;
                                    toLocaleString: {
                                        (): string;
                                        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                                    };
                                    toString: () => string;
                                    valueOf: () => Int8Array<ArrayBufferLike>;
                                    entries: () => ArrayIterator<[number, number]>;
                                    keys: () => ArrayIterator<number>;
                                    values: () => ArrayIterator<number>;
                                    includes: (searchElement: number, fromIndex?: number) => boolean;
                                    at: (index: number) => number | undefined;
                                    findLast: {
                                        <S extends number>(predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                                        (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                                    };
                                    findLastIndex: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                                    toReversed: () => Int8Array<ArrayBuffer>;
                                    toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Int8Array<ArrayBuffer>;
                                    with: (index: number, value: number) => Int8Array<ArrayBuffer>;
                                    [Symbol.iterator]: () => ArrayIterator<number>;
                                    readonly [Symbol.toStringTag]: "Int8Array";
                                } | {
                                    [x: number]: number;
                                    readonly BYTES_PER_ELEMENT: number;
                                    readonly buffer: {
                                        readonly byteLength: number;
                                        slice: (begin?: number, end?: number) => ArrayBuffer;
                                        readonly maxByteLength: number;
                                        readonly resizable: boolean;
                                        resize: (newByteLength?: number) => void;
                                        readonly detached: boolean;
                                        transfer: (newByteLength?: number) => ArrayBuffer;
                                        transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                                        readonly [Symbol.toStringTag]: string;
                                    } | {
                                        readonly byteLength: number;
                                        slice: (begin?: number, end?: number) => SharedArrayBuffer;
                                        readonly growable: boolean;
                                        readonly maxByteLength: number;
                                        grow: (newByteLength?: number) => void;
                                        readonly [Symbol.species]: SharedArrayBuffer;
                                        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                                    };
                                    readonly byteLength: number;
                                    readonly byteOffset: number;
                                    copyWithin: (target: number, start: number, end?: number) => Uint8Array<ArrayBufferLike>;
                                    every: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                    fill: (value: number, start?: number, end?: number) => Uint8Array<ArrayBufferLike>;
                                    filter: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => any, thisArg?: any) => Uint8Array<ArrayBuffer>;
                                    find: (predicate: (value: number, index: number, obj: Uint8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                                    findIndex: (predicate: (value: number, index: number, obj: Uint8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                                    forEach: (callbackfn: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                                    indexOf: (searchElement: number, fromIndex?: number) => number;
                                    join: (separator?: string) => string;
                                    lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                                    readonly length: number;
                                    map: (callbackfn: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => number, thisArg?: any) => Uint8Array<ArrayBuffer>;
                                    reduce: {
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number): number;
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number, initialValue: number): number;
                                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => U, initialValue: U): U;
                                    };
                                    reduceRight: {
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number): number;
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number, initialValue: number): number;
                                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => U, initialValue: U): U;
                                    };
                                    reverse: () => Uint8Array<ArrayBufferLike>;
                                    set: (array: ArrayLike<number>, offset?: number) => void;
                                    slice: (start?: number, end?: number) => Uint8Array<ArrayBuffer>;
                                    some: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                    sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8Array<ArrayBufferLike>;
                                    subarray: (begin?: number, end?: number) => Uint8Array<ArrayBufferLike>;
                                    toLocaleString: {
                                        (): string;
                                        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                                    };
                                    toString: () => string;
                                    valueOf: () => Uint8Array<ArrayBufferLike>;
                                    entries: () => ArrayIterator<[number, number]>;
                                    keys: () => ArrayIterator<number>;
                                    values: () => ArrayIterator<number>;
                                    includes: (searchElement: number, fromIndex?: number) => boolean;
                                    at: (index: number) => number | undefined;
                                    findLast: {
                                        <S extends number>(predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                                        (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                                    };
                                    findLastIndex: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                                    toReversed: () => Uint8Array<ArrayBuffer>;
                                    toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8Array<ArrayBuffer>;
                                    with: (index: number, value: number) => Uint8Array<ArrayBuffer>;
                                    [Symbol.iterator]: () => ArrayIterator<number>;
                                    readonly [Symbol.toStringTag]: "Uint8Array";
                                } | {
                                    [x: number]: number;
                                    readonly BYTES_PER_ELEMENT: number;
                                    readonly buffer: {
                                        readonly byteLength: number;
                                        slice: (begin?: number, end?: number) => ArrayBuffer;
                                        readonly maxByteLength: number;
                                        readonly resizable: boolean;
                                        resize: (newByteLength?: number) => void;
                                        readonly detached: boolean;
                                        transfer: (newByteLength?: number) => ArrayBuffer;
                                        transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                                        readonly [Symbol.toStringTag]: string;
                                    } | {
                                        readonly byteLength: number;
                                        slice: (begin?: number, end?: number) => SharedArrayBuffer;
                                        readonly growable: boolean;
                                        readonly maxByteLength: number;
                                        grow: (newByteLength?: number) => void;
                                        readonly [Symbol.species]: SharedArrayBuffer;
                                        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                                    };
                                    readonly byteLength: number;
                                    readonly byteOffset: number;
                                    copyWithin: (target: number, start: number, end?: number) => Uint8ClampedArray<ArrayBufferLike>;
                                    every: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                    fill: (value: number, start?: number, end?: number) => Uint8ClampedArray<ArrayBufferLike>;
                                    filter: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => any, thisArg?: any) => Uint8ClampedArray<ArrayBuffer>;
                                    find: (predicate: (value: number, index: number, obj: Uint8ClampedArray<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                                    findIndex: (predicate: (value: number, index: number, obj: Uint8ClampedArray<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                                    forEach: (callbackfn: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => void, thisArg?: any) => void;
                                    indexOf: (searchElement: number, fromIndex?: number) => number;
                                    join: (separator?: string) => string;
                                    lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                                    readonly length: number;
                                    map: (callbackfn: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => number, thisArg?: any) => Uint8ClampedArray<ArrayBuffer>;
                                    reduce: {
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number): number;
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number, initialValue: number): number;
                                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => U, initialValue: U): U;
                                    };
                                    reduceRight: {
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number): number;
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number, initialValue: number): number;
                                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => U, initialValue: U): U;
                                    };
                                    reverse: () => Uint8ClampedArray<ArrayBufferLike>;
                                    set: (array: ArrayLike<number>, offset?: number) => void;
                                    slice: (start?: number, end?: number) => Uint8ClampedArray<ArrayBuffer>;
                                    some: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                    sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8ClampedArray<ArrayBufferLike>;
                                    subarray: (begin?: number, end?: number) => Uint8ClampedArray<ArrayBufferLike>;
                                    toLocaleString: {
                                        (): string;
                                        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                                    };
                                    toString: () => string;
                                    valueOf: () => Uint8ClampedArray<ArrayBufferLike>;
                                    entries: () => ArrayIterator<[number, number]>;
                                    keys: () => ArrayIterator<number>;
                                    values: () => ArrayIterator<number>;
                                    includes: (searchElement: number, fromIndex?: number) => boolean;
                                    at: (index: number) => number | undefined;
                                    findLast: {
                                        <S extends number>(predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                                        (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                                    };
                                    findLastIndex: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                                    toReversed: () => Uint8ClampedArray<ArrayBuffer>;
                                    toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8ClampedArray<ArrayBuffer>;
                                    with: (index: number, value: number) => Uint8ClampedArray<ArrayBuffer>;
                                    [Symbol.iterator]: () => ArrayIterator<number>;
                                    readonly [Symbol.toStringTag]: "Uint8ClampedArray";
                                } | {
                                    [x: number]: number;
                                    readonly BYTES_PER_ELEMENT: number;
                                    readonly buffer: {
                                        readonly byteLength: number;
                                        slice: (begin?: number, end?: number) => ArrayBuffer;
                                        readonly maxByteLength: number;
                                        readonly resizable: boolean;
                                        resize: (newByteLength?: number) => void;
                                        readonly detached: boolean;
                                        transfer: (newByteLength?: number) => ArrayBuffer;
                                        transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                                        readonly [Symbol.toStringTag]: string;
                                    } | {
                                        readonly byteLength: number;
                                        slice: (begin?: number, end?: number) => SharedArrayBuffer;
                                        readonly growable: boolean;
                                        readonly maxByteLength: number;
                                        grow: (newByteLength?: number) => void;
                                        readonly [Symbol.species]: SharedArrayBuffer;
                                        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                                    };
                                    readonly byteLength: number;
                                    readonly byteOffset: number;
                                    copyWithin: (target: number, start: number, end?: number) => Int16Array<ArrayBufferLike>;
                                    every: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                    fill: (value: number, start?: number, end?: number) => Int16Array<ArrayBufferLike>;
                                    filter: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => any, thisArg?: any) => Int16Array<ArrayBuffer>;
                                    find: (predicate: (value: number, index: number, obj: Int16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                                    findIndex: (predicate: (value: number, index: number, obj: Int16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                                    forEach: (callbackfn: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                                    indexOf: (searchElement: number, fromIndex?: number) => number;
                                    join: (separator?: string) => string;
                                    lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                                    readonly length: number;
                                    map: (callbackfn: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => number, thisArg?: any) => Int16Array<ArrayBuffer>;
                                    reduce: {
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number): number;
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number, initialValue: number): number;
                                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => U, initialValue: U): U;
                                    };
                                    reduceRight: {
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number): number;
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number, initialValue: number): number;
                                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => U, initialValue: U): U;
                                    };
                                    reverse: () => Int16Array<ArrayBufferLike>;
                                    set: (array: ArrayLike<number>, offset?: number) => void;
                                    slice: (start?: number, end?: number) => Int16Array<ArrayBuffer>;
                                    some: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                    sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Int16Array<ArrayBufferLike>;
                                    subarray: (begin?: number, end?: number) => Int16Array<ArrayBufferLike>;
                                    toLocaleString: {
                                        (): string;
                                        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                                    };
                                    toString: () => string;
                                    valueOf: () => Int16Array<ArrayBufferLike>;
                                    entries: () => ArrayIterator<[number, number]>;
                                    keys: () => ArrayIterator<number>;
                                    values: () => ArrayIterator<number>;
                                    includes: (searchElement: number, fromIndex?: number) => boolean;
                                    at: (index: number) => number | undefined;
                                    findLast: {
                                        <S extends number>(predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                                        (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                                    };
                                    findLastIndex: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                                    toReversed: () => Int16Array<ArrayBuffer>;
                                    toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Int16Array<ArrayBuffer>;
                                    with: (index: number, value: number) => Int16Array<ArrayBuffer>;
                                    [Symbol.iterator]: () => ArrayIterator<number>;
                                    readonly [Symbol.toStringTag]: "Int16Array";
                                } | {
                                    [x: number]: number;
                                    readonly BYTES_PER_ELEMENT: number;
                                    readonly buffer: {
                                        readonly byteLength: number;
                                        slice: (begin?: number, end?: number) => ArrayBuffer;
                                        readonly maxByteLength: number;
                                        readonly resizable: boolean;
                                        resize: (newByteLength?: number) => void;
                                        readonly detached: boolean;
                                        transfer: (newByteLength?: number) => ArrayBuffer;
                                        transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                                        readonly [Symbol.toStringTag]: string;
                                    } | {
                                        readonly byteLength: number;
                                        slice: (begin?: number, end?: number) => SharedArrayBuffer;
                                        readonly growable: boolean;
                                        readonly maxByteLength: number;
                                        grow: (newByteLength?: number) => void;
                                        readonly [Symbol.species]: SharedArrayBuffer;
                                        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                                    };
                                    readonly byteLength: number;
                                    readonly byteOffset: number;
                                    copyWithin: (target: number, start: number, end?: number) => Uint16Array<ArrayBufferLike>;
                                    every: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                    fill: (value: number, start?: number, end?: number) => Uint16Array<ArrayBufferLike>;
                                    filter: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => any, thisArg?: any) => Uint16Array<ArrayBuffer>;
                                    find: (predicate: (value: number, index: number, obj: Uint16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                                    findIndex: (predicate: (value: number, index: number, obj: Uint16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                                    forEach: (callbackfn: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                                    indexOf: (searchElement: number, fromIndex?: number) => number;
                                    join: (separator?: string) => string;
                                    lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                                    readonly length: number;
                                    map: (callbackfn: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => number, thisArg?: any) => Uint16Array<ArrayBuffer>;
                                    reduce: {
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number): number;
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number, initialValue: number): number;
                                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => U, initialValue: U): U;
                                    };
                                    reduceRight: {
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number): number;
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number, initialValue: number): number;
                                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => U, initialValue: U): U;
                                    };
                                    reverse: () => Uint16Array<ArrayBufferLike>;
                                    set: (array: ArrayLike<number>, offset?: number) => void;
                                    slice: (start?: number, end?: number) => Uint16Array<ArrayBuffer>;
                                    some: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                    sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint16Array<ArrayBufferLike>;
                                    subarray: (begin?: number, end?: number) => Uint16Array<ArrayBufferLike>;
                                    toLocaleString: {
                                        (): string;
                                        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                                    };
                                    toString: () => string;
                                    valueOf: () => Uint16Array<ArrayBufferLike>;
                                    entries: () => ArrayIterator<[number, number]>;
                                    keys: () => ArrayIterator<number>;
                                    values: () => ArrayIterator<number>;
                                    includes: (searchElement: number, fromIndex?: number) => boolean;
                                    at: (index: number) => number | undefined;
                                    findLast: {
                                        <S extends number>(predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                                        (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                                    };
                                    findLastIndex: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                                    toReversed: () => Uint16Array<ArrayBuffer>;
                                    toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint16Array<ArrayBuffer>;
                                    with: (index: number, value: number) => Uint16Array<ArrayBuffer>;
                                    [Symbol.iterator]: () => ArrayIterator<number>;
                                    readonly [Symbol.toStringTag]: "Uint16Array";
                                } | {
                                    [x: number]: number;
                                    readonly BYTES_PER_ELEMENT: number;
                                    readonly buffer: {
                                        readonly byteLength: number;
                                        slice: (begin?: number, end?: number) => ArrayBuffer;
                                        readonly maxByteLength: number;
                                        readonly resizable: boolean;
                                        resize: (newByteLength?: number) => void;
                                        readonly detached: boolean;
                                        transfer: (newByteLength?: number) => ArrayBuffer;
                                        transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                                        readonly [Symbol.toStringTag]: string;
                                    } | {
                                        readonly byteLength: number;
                                        slice: (begin?: number, end?: number) => SharedArrayBuffer;
                                        readonly growable: boolean;
                                        readonly maxByteLength: number;
                                        grow: (newByteLength?: number) => void;
                                        readonly [Symbol.species]: SharedArrayBuffer;
                                        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                                    };
                                    readonly byteLength: number;
                                    readonly byteOffset: number;
                                    copyWithin: (target: number, start: number, end?: number) => Int32Array<ArrayBufferLike>;
                                    every: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                    fill: (value: number, start?: number, end?: number) => Int32Array<ArrayBufferLike>;
                                    filter: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => any, thisArg?: any) => Int32Array<ArrayBuffer>;
                                    find: (predicate: (value: number, index: number, obj: Int32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                                    findIndex: (predicate: (value: number, index: number, obj: Int32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                                    forEach: (callbackfn: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                                    indexOf: (searchElement: number, fromIndex?: number) => number;
                                    join: (separator?: string) => string;
                                    lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                                    readonly length: number;
                                    map: (callbackfn: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => number, thisArg?: any) => Int32Array<ArrayBuffer>;
                                    reduce: {
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number): number;
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number, initialValue: number): number;
                                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => U, initialValue: U): U;
                                    };
                                    reduceRight: {
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number): number;
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number, initialValue: number): number;
                                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => U, initialValue: U): U;
                                    };
                                    reverse: () => Int32Array<ArrayBufferLike>;
                                    set: (array: ArrayLike<number>, offset?: number) => void;
                                    slice: (start?: number, end?: number) => Int32Array<ArrayBuffer>;
                                    some: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                    sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Int32Array<ArrayBufferLike>;
                                    subarray: (begin?: number, end?: number) => Int32Array<ArrayBufferLike>;
                                    toLocaleString: {
                                        (): string;
                                        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                                    };
                                    toString: () => string;
                                    valueOf: () => Int32Array<ArrayBufferLike>;
                                    entries: () => ArrayIterator<[number, number]>;
                                    keys: () => ArrayIterator<number>;
                                    values: () => ArrayIterator<number>;
                                    includes: (searchElement: number, fromIndex?: number) => boolean;
                                    at: (index: number) => number | undefined;
                                    findLast: {
                                        <S extends number>(predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                                        (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                                    };
                                    findLastIndex: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                                    toReversed: () => Int32Array<ArrayBuffer>;
                                    toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Int32Array<ArrayBuffer>;
                                    with: (index: number, value: number) => Int32Array<ArrayBuffer>;
                                    [Symbol.iterator]: () => ArrayIterator<number>;
                                    readonly [Symbol.toStringTag]: "Int32Array";
                                } | {
                                    [x: number]: number;
                                    readonly BYTES_PER_ELEMENT: number;
                                    readonly buffer: {
                                        readonly byteLength: number;
                                        slice: (begin?: number, end?: number) => ArrayBuffer;
                                        readonly maxByteLength: number;
                                        readonly resizable: boolean;
                                        resize: (newByteLength?: number) => void;
                                        readonly detached: boolean;
                                        transfer: (newByteLength?: number) => ArrayBuffer;
                                        transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                                        readonly [Symbol.toStringTag]: string;
                                    } | {
                                        readonly byteLength: number;
                                        slice: (begin?: number, end?: number) => SharedArrayBuffer;
                                        readonly growable: boolean;
                                        readonly maxByteLength: number;
                                        grow: (newByteLength?: number) => void;
                                        readonly [Symbol.species]: SharedArrayBuffer;
                                        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                                    };
                                    readonly byteLength: number;
                                    readonly byteOffset: number;
                                    copyWithin: (target: number, start: number, end?: number) => Uint32Array<ArrayBufferLike>;
                                    every: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                    fill: (value: number, start?: number, end?: number) => Uint32Array<ArrayBufferLike>;
                                    filter: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => any, thisArg?: any) => Uint32Array<ArrayBuffer>;
                                    find: (predicate: (value: number, index: number, obj: Uint32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                                    findIndex: (predicate: (value: number, index: number, obj: Uint32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                                    forEach: (callbackfn: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                                    indexOf: (searchElement: number, fromIndex?: number) => number;
                                    join: (separator?: string) => string;
                                    lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                                    readonly length: number;
                                    map: (callbackfn: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => number, thisArg?: any) => Uint32Array<ArrayBuffer>;
                                    reduce: {
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number): number;
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number, initialValue: number): number;
                                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => U, initialValue: U): U;
                                    };
                                    reduceRight: {
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number): number;
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number, initialValue: number): number;
                                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => U, initialValue: U): U;
                                    };
                                    reverse: () => Uint32Array<ArrayBufferLike>;
                                    set: (array: ArrayLike<number>, offset?: number) => void;
                                    slice: (start?: number, end?: number) => Uint32Array<ArrayBuffer>;
                                    some: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                    sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint32Array<ArrayBufferLike>;
                                    subarray: (begin?: number, end?: number) => Uint32Array<ArrayBufferLike>;
                                    toLocaleString: {
                                        (): string;
                                        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                                    };
                                    toString: () => string;
                                    valueOf: () => Uint32Array<ArrayBufferLike>;
                                    entries: () => ArrayIterator<[number, number]>;
                                    keys: () => ArrayIterator<number>;
                                    values: () => ArrayIterator<number>;
                                    includes: (searchElement: number, fromIndex?: number) => boolean;
                                    at: (index: number) => number | undefined;
                                    findLast: {
                                        <S extends number>(predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                                        (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                                    };
                                    findLastIndex: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                                    toReversed: () => Uint32Array<ArrayBuffer>;
                                    toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint32Array<ArrayBuffer>;
                                    with: (index: number, value: number) => Uint32Array<ArrayBuffer>;
                                    [Symbol.iterator]: () => ArrayIterator<number>;
                                    readonly [Symbol.toStringTag]: "Uint32Array";
                                } | {
                                    [x: number]: number;
                                    readonly BYTES_PER_ELEMENT: number;
                                    readonly buffer: {
                                        readonly byteLength: number;
                                        slice: (begin?: number, end?: number) => ArrayBuffer;
                                        readonly maxByteLength: number;
                                        readonly resizable: boolean;
                                        resize: (newByteLength?: number) => void;
                                        readonly detached: boolean;
                                        transfer: (newByteLength?: number) => ArrayBuffer;
                                        transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                                        readonly [Symbol.toStringTag]: string;
                                    } | {
                                        readonly byteLength: number;
                                        slice: (begin?: number, end?: number) => SharedArrayBuffer;
                                        readonly growable: boolean;
                                        readonly maxByteLength: number;
                                        grow: (newByteLength?: number) => void;
                                        readonly [Symbol.species]: SharedArrayBuffer;
                                        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                                    };
                                    readonly byteLength: number;
                                    readonly byteOffset: number;
                                    copyWithin: (target: number, start: number, end?: number) => Float32Array<ArrayBufferLike>;
                                    every: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                    fill: (value: number, start?: number, end?: number) => Float32Array<ArrayBufferLike>;
                                    filter: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => any, thisArg?: any) => Float32Array<ArrayBuffer>;
                                    find: (predicate: (value: number, index: number, obj: Float32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                                    findIndex: (predicate: (value: number, index: number, obj: Float32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                                    forEach: (callbackfn: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                                    indexOf: (searchElement: number, fromIndex?: number) => number;
                                    join: (separator?: string) => string;
                                    lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                                    readonly length: number;
                                    map: (callbackfn: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => number, thisArg?: any) => Float32Array<ArrayBuffer>;
                                    reduce: {
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number): number;
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number, initialValue: number): number;
                                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => U, initialValue: U): U;
                                    };
                                    reduceRight: {
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number): number;
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number, initialValue: number): number;
                                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => U, initialValue: U): U;
                                    };
                                    reverse: () => Float32Array<ArrayBufferLike>;
                                    set: (array: ArrayLike<number>, offset?: number) => void;
                                    slice: (start?: number, end?: number) => Float32Array<ArrayBuffer>;
                                    some: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                    sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array<ArrayBufferLike>;
                                    subarray: (begin?: number, end?: number) => Float32Array<ArrayBufferLike>;
                                    toLocaleString: {
                                        (): string;
                                        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                                    };
                                    toString: () => string;
                                    valueOf: () => Float32Array<ArrayBufferLike>;
                                    entries: () => ArrayIterator<[number, number]>;
                                    keys: () => ArrayIterator<number>;
                                    values: () => ArrayIterator<number>;
                                    includes: (searchElement: number, fromIndex?: number) => boolean;
                                    at: (index: number) => number | undefined;
                                    findLast: {
                                        <S extends number>(predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                                        (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                                    };
                                    findLastIndex: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                                    toReversed: () => Float32Array<ArrayBuffer>;
                                    toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array<ArrayBuffer>;
                                    with: (index: number, value: number) => Float32Array<ArrayBuffer>;
                                    [Symbol.iterator]: () => ArrayIterator<number>;
                                    readonly [Symbol.toStringTag]: "Float32Array";
                                } | {
                                    [x: number]: number;
                                    readonly BYTES_PER_ELEMENT: number;
                                    readonly buffer: {
                                        readonly byteLength: number;
                                        slice: (begin?: number, end?: number) => ArrayBuffer;
                                        readonly maxByteLength: number;
                                        readonly resizable: boolean;
                                        resize: (newByteLength?: number) => void;
                                        readonly detached: boolean;
                                        transfer: (newByteLength?: number) => ArrayBuffer;
                                        transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                                        readonly [Symbol.toStringTag]: string;
                                    } | {
                                        readonly byteLength: number;
                                        slice: (begin?: number, end?: number) => SharedArrayBuffer;
                                        readonly growable: boolean;
                                        readonly maxByteLength: number;
                                        grow: (newByteLength?: number) => void;
                                        readonly [Symbol.species]: SharedArrayBuffer;
                                        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                                    };
                                    readonly byteLength: number;
                                    readonly byteOffset: number;
                                    copyWithin: (target: number, start: number, end?: number) => Float64Array<ArrayBufferLike>;
                                    every: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                    fill: (value: number, start?: number, end?: number) => Float64Array<ArrayBufferLike>;
                                    filter: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => any, thisArg?: any) => Float64Array<ArrayBuffer>;
                                    find: (predicate: (value: number, index: number, obj: Float64Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                                    findIndex: (predicate: (value: number, index: number, obj: Float64Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                                    forEach: (callbackfn: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                                    indexOf: (searchElement: number, fromIndex?: number) => number;
                                    join: (separator?: string) => string;
                                    lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                                    readonly length: number;
                                    map: (callbackfn: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => number, thisArg?: any) => Float64Array<ArrayBuffer>;
                                    reduce: {
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number): number;
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number, initialValue: number): number;
                                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => U, initialValue: U): U;
                                    };
                                    reduceRight: {
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number): number;
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number, initialValue: number): number;
                                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => U, initialValue: U): U;
                                    };
                                    reverse: () => Float64Array<ArrayBufferLike>;
                                    set: (array: ArrayLike<number>, offset?: number) => void;
                                    slice: (start?: number, end?: number) => Float64Array<ArrayBuffer>;
                                    some: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                    sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float64Array<ArrayBufferLike>;
                                    subarray: (begin?: number, end?: number) => Float64Array<ArrayBufferLike>;
                                    toLocaleString: {
                                        (): string;
                                        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                                    };
                                    toString: () => string;
                                    valueOf: () => Float64Array<ArrayBufferLike>;
                                    entries: () => ArrayIterator<[number, number]>;
                                    keys: () => ArrayIterator<number>;
                                    values: () => ArrayIterator<number>;
                                    includes: (searchElement: number, fromIndex?: number) => boolean;
                                    at: (index: number) => number | undefined;
                                    findLast: {
                                        <S extends number>(predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                                        (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                                    };
                                    findLastIndex: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                                    toReversed: () => Float64Array<ArrayBuffer>;
                                    toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float64Array<ArrayBuffer>;
                                    with: (index: number, value: number) => Float64Array<ArrayBuffer>;
                                    [Symbol.iterator]: () => ArrayIterator<number>;
                                    readonly [Symbol.toStringTag]: "Float64Array";
                                };
                                width: number;
                                height: number;
                            }[] | /*elided*/ any[];
                            mapping: import('three').AnyMapping;
                            channel: number;
                            wrapS: import('three').Wrapping;
                            wrapT: import('three').Wrapping;
                            anisotropy: number;
                            internalFormat: import('three').PixelFormatGPU | null;
                            matrix: {
                                readonly isMatrix3: true;
                                elements: [n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number];
                                set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import('three').Matrix3;
                                identity: () => import('three').Matrix3;
                                copy: (m: import('three').Matrix3) => import('three').Matrix3;
                                extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix3;
                                setFromMatrix4: (m: import('three').Matrix4) => import('three').Matrix3;
                                multiply: (m: import('three').Matrix3) => import('three').Matrix3;
                                premultiply: (m: import('three').Matrix3) => import('three').Matrix3;
                                multiplyMatrices: (a: import('three').Matrix3, b: import('three').Matrix3) => import('three').Matrix3;
                                multiplyScalar: (s: number) => import('three').Matrix3;
                                determinant: () => number;
                                invert: () => import('three').Matrix3;
                                transpose: () => import('three').Matrix3;
                                getNormalMatrix: (matrix4: import('three').Matrix4) => import('three').Matrix3;
                                transposeIntoArray: (r: number[]) => import('three').Matrix3;
                                setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import('three').Matrix3;
                                scale: (sx: number, sy: number) => import('three').Matrix3;
                                rotate: (theta: number) => import('three').Matrix3;
                                translate: (tx: number, ty: number) => import('three').Matrix3;
                                makeTranslation: {
                                    (v: import('three').Vector2): import('three').Matrix3;
                                    (x: number, y: number): import('three').Matrix3;
                                };
                                makeRotation: (theta: number) => import('three').Matrix3;
                                makeScale: (x: number, y: number) => import('three').Matrix3;
                                equals: (matrix: import('three').Matrix3) => boolean;
                                fromArray: (array: ArrayLike<number>, offset?: number) => import('three').Matrix3;
                                toArray: {
                                    (): import('three').Matrix3Tuple;
                                    <TArray extends ArrayLike<number>>(array: TArray, offset?: number): TArray;
                                };
                                clone: () => import('three').Matrix3;
                            };
                            matrixAutoUpdate: boolean;
                            offset: {
                                x: number;
                                y: number;
                                width: number;
                                height: number;
                                readonly isVector2: true;
                                set: (x: number, y: number) => import('three').Vector2;
                                setScalar: (scalar: number) => import('three').Vector2;
                                setX: (x: number) => import('three').Vector2;
                                setY: (y: number) => import('three').Vector2;
                                setComponent: (index: number, value: number) => import('three').Vector2;
                                getComponent: (index: number) => number;
                                clone: () => import('three').Vector2;
                                copy: (v: import('three').Vector2Like) => import('three').Vector2;
                                add: (v: import('three').Vector2Like) => import('three').Vector2;
                                addScalar: (s: number) => import('three').Vector2;
                                addVectors: (a: import('three').Vector2Like, b: import('three').Vector2Like) => import('three').Vector2;
                                addScaledVector: (v: import('three').Vector2Like, s: number) => import('three').Vector2;
                                sub: (v: import('three').Vector2Like) => import('three').Vector2;
                                subScalar: (s: number) => import('three').Vector2;
                                subVectors: (a: import('three').Vector2Like, b: import('three').Vector2Like) => import('three').Vector2;
                                multiply: (v: import('three').Vector2Like) => import('three').Vector2;
                                multiplyScalar: (scalar: number) => import('three').Vector2;
                                divide: (v: import('three').Vector2Like) => import('three').Vector2;
                                divideScalar: (s: number) => import('three').Vector2;
                                applyMatrix3: (m: import('three').Matrix3) => import('three').Vector2;
                                min: (v: import('three').Vector2Like) => import('three').Vector2;
                                max: (v: import('three').Vector2Like) => import('three').Vector2;
                                clamp: (min: import('three').Vector2Like, max: import('three').Vector2Like) => import('three').Vector2;
                                clampScalar: (min: number, max: number) => import('three').Vector2;
                                clampLength: (min: number, max: number) => import('three').Vector2;
                                floor: () => import('three').Vector2;
                                ceil: () => import('three').Vector2;
                                round: () => import('three').Vector2;
                                roundToZero: () => import('three').Vector2;
                                negate: () => import('three').Vector2;
                                dot: (v: import('three').Vector2Like) => number;
                                cross: (v: import('three').Vector2Like) => number;
                                lengthSq: () => number;
                                length: () => number;
                                manhattanLength: () => number;
                                normalize: () => import('three').Vector2;
                                angle: () => number;
                                angleTo: (v: import('three').Vector2) => number;
                                distanceTo: (v: import('three').Vector2Like) => number;
                                distanceToSquared: (v: import('three').Vector2Like) => number;
                                manhattanDistanceTo: (v: import('three').Vector2Like) => number;
                                setLength: (length: number) => import('three').Vector2;
                                lerp: (v: import('three').Vector2Like, alpha: number) => import('three').Vector2;
                                lerpVectors: (v1: import('three').Vector2Like, v2: import('three').Vector2Like, alpha: number) => import('three').Vector2;
                                equals: (v: import('three').Vector2Like) => boolean;
                                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector2;
                                toArray: {
                                    (array?: number[], offset?: number): number[];
                                    (array?: import('three').Vector2Tuple, offset?: 0): import('three').Vector2Tuple;
                                    (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                                };
                                fromBufferAttribute: (attribute: import('three').BufferAttribute, index: number) => import('three').Vector2;
                                rotateAround: (center: import('three').Vector2Like, angle: number) => import('three').Vector2;
                                random: () => import('three').Vector2;
                                [Symbol.iterator]: () => Iterator<number>;
                            };
                            repeat: {
                                x: number;
                                y: number;
                                width: number;
                                height: number;
                                readonly isVector2: true;
                                set: (x: number, y: number) => import('three').Vector2;
                                setScalar: (scalar: number) => import('three').Vector2;
                                setX: (x: number) => import('three').Vector2;
                                setY: (y: number) => import('three').Vector2;
                                setComponent: (index: number, value: number) => import('three').Vector2;
                                getComponent: (index: number) => number;
                                clone: () => import('three').Vector2;
                                copy: (v: import('three').Vector2Like) => import('three').Vector2;
                                add: (v: import('three').Vector2Like) => import('three').Vector2;
                                addScalar: (s: number) => import('three').Vector2;
                                addVectors: (a: import('three').Vector2Like, b: import('three').Vector2Like) => import('three').Vector2;
                                addScaledVector: (v: import('three').Vector2Like, s: number) => import('three').Vector2;
                                sub: (v: import('three').Vector2Like) => import('three').Vector2;
                                subScalar: (s: number) => import('three').Vector2;
                                subVectors: (a: import('three').Vector2Like, b: import('three').Vector2Like) => import('three').Vector2;
                                multiply: (v: import('three').Vector2Like) => import('three').Vector2;
                                multiplyScalar: (scalar: number) => import('three').Vector2;
                                divide: (v: import('three').Vector2Like) => import('three').Vector2;
                                divideScalar: (s: number) => import('three').Vector2;
                                applyMatrix3: (m: import('three').Matrix3) => import('three').Vector2;
                                min: (v: import('three').Vector2Like) => import('three').Vector2;
                                max: (v: import('three').Vector2Like) => import('three').Vector2;
                                clamp: (min: import('three').Vector2Like, max: import('three').Vector2Like) => import('three').Vector2;
                                clampScalar: (min: number, max: number) => import('three').Vector2;
                                clampLength: (min: number, max: number) => import('three').Vector2;
                                floor: () => import('three').Vector2;
                                ceil: () => import('three').Vector2;
                                round: () => import('three').Vector2;
                                roundToZero: () => import('three').Vector2;
                                negate: () => import('three').Vector2;
                                dot: (v: import('three').Vector2Like) => number;
                                cross: (v: import('three').Vector2Like) => number;
                                lengthSq: () => number;
                                length: () => number;
                                manhattanLength: () => number;
                                normalize: () => import('three').Vector2;
                                angle: () => number;
                                angleTo: (v: import('three').Vector2) => number;
                                distanceTo: (v: import('three').Vector2Like) => number;
                                distanceToSquared: (v: import('three').Vector2Like) => number;
                                manhattanDistanceTo: (v: import('three').Vector2Like) => number;
                                setLength: (length: number) => import('three').Vector2;
                                lerp: (v: import('three').Vector2Like, alpha: number) => import('three').Vector2;
                                lerpVectors: (v1: import('three').Vector2Like, v2: import('three').Vector2Like, alpha: number) => import('three').Vector2;
                                equals: (v: import('three').Vector2Like) => boolean;
                                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector2;
                                toArray: {
                                    (array?: number[], offset?: number): number[];
                                    (array?: import('three').Vector2Tuple, offset?: 0): import('three').Vector2Tuple;
                                    (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                                };
                                fromBufferAttribute: (attribute: import('three').BufferAttribute, index: number) => import('three').Vector2;
                                rotateAround: (center: import('three').Vector2Like, angle: number) => import('three').Vector2;
                                random: () => import('three').Vector2;
                                [Symbol.iterator]: () => Iterator<number>;
                            };
                            center: {
                                x: number;
                                y: number;
                                width: number;
                                height: number;
                                readonly isVector2: true;
                                set: (x: number, y: number) => import('three').Vector2;
                                setScalar: (scalar: number) => import('three').Vector2;
                                setX: (x: number) => import('three').Vector2;
                                setY: (y: number) => import('three').Vector2;
                                setComponent: (index: number, value: number) => import('three').Vector2;
                                getComponent: (index: number) => number;
                                clone: () => import('three').Vector2;
                                copy: (v: import('three').Vector2Like) => import('three').Vector2;
                                add: (v: import('three').Vector2Like) => import('three').Vector2;
                                addScalar: (s: number) => import('three').Vector2;
                                addVectors: (a: import('three').Vector2Like, b: import('three').Vector2Like) => import('three').Vector2;
                                addScaledVector: (v: import('three').Vector2Like, s: number) => import('three').Vector2;
                                sub: (v: import('three').Vector2Like) => import('three').Vector2;
                                subScalar: (s: number) => import('three').Vector2;
                                subVectors: (a: import('three').Vector2Like, b: import('three').Vector2Like) => import('three').Vector2;
                                multiply: (v: import('three').Vector2Like) => import('three').Vector2;
                                multiplyScalar: (scalar: number) => import('three').Vector2;
                                divide: (v: import('three').Vector2Like) => import('three').Vector2;
                                divideScalar: (s: number) => import('three').Vector2;
                                applyMatrix3: (m: import('three').Matrix3) => import('three').Vector2;
                                min: (v: import('three').Vector2Like) => import('three').Vector2;
                                max: (v: import('three').Vector2Like) => import('three').Vector2;
                                clamp: (min: import('three').Vector2Like, max: import('three').Vector2Like) => import('three').Vector2;
                                clampScalar: (min: number, max: number) => import('three').Vector2;
                                clampLength: (min: number, max: number) => import('three').Vector2;
                                floor: () => import('three').Vector2;
                                ceil: () => import('three').Vector2;
                                round: () => import('three').Vector2;
                                roundToZero: () => import('three').Vector2;
                                negate: () => import('three').Vector2;
                                dot: (v: import('three').Vector2Like) => number;
                                cross: (v: import('three').Vector2Like) => number;
                                lengthSq: () => number;
                                length: () => number;
                                manhattanLength: () => number;
                                normalize: () => import('three').Vector2;
                                angle: () => number;
                                angleTo: (v: import('three').Vector2) => number;
                                distanceTo: (v: import('three').Vector2Like) => number;
                                distanceToSquared: (v: import('three').Vector2Like) => number;
                                manhattanDistanceTo: (v: import('three').Vector2Like) => number;
                                setLength: (length: number) => import('three').Vector2;
                                lerp: (v: import('three').Vector2Like, alpha: number) => import('three').Vector2;
                                lerpVectors: (v1: import('three').Vector2Like, v2: import('three').Vector2Like, alpha: number) => import('three').Vector2;
                                equals: (v: import('three').Vector2Like) => boolean;
                                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector2;
                                toArray: {
                                    (array?: number[], offset?: number): number[];
                                    (array?: import('three').Vector2Tuple, offset?: 0): import('three').Vector2Tuple;
                                    (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                                };
                                fromBufferAttribute: (attribute: import('three').BufferAttribute, index: number) => import('three').Vector2;
                                rotateAround: (center: import('three').Vector2Like, angle: number) => import('three').Vector2;
                                random: () => import('three').Vector2;
                                [Symbol.iterator]: () => Iterator<number>;
                            };
                            rotation: number;
                            premultiplyAlpha: boolean;
                            unpackAlignment: number;
                            colorSpace: string;
                            isRenderTargetTexture: boolean;
                            isArrayTexture: boolean;
                            userData: Record<string, any>;
                            updateRanges: {
                                start: number;
                                count: number;
                            }[];
                            version: number;
                            pmremVersion: number;
                            needsUpdate: boolean;
                            needsPMREMUpdate: boolean;
                            renderTarget: /*elided*/ any | null;
                            onUpdate: ((texture: Texture) => void) | null;
                            transformUv: (uv: import('three').Vector2) => import('three').Vector2;
                            updateMatrix: () => void;
                            addUpdateRange: (start: number, count: number) => void;
                            clearUpdateRanges: () => void;
                            clone: () => import('three').DepthTexture;
                            copy: (source: Texture) => import('three').DepthTexture;
                            setValues: (values: import('three').TextureParameters) => void;
                            toJSON: (meta?: string | {}) => import('three').TextureJSON;
                            dispose: () => void;
                            addEventListener: <T extends "dispose">(type: T, listener: import('three').EventListener<{
                                dispose: {};
                            }[T], T, import('three').DepthTexture>) => void;
                            hasEventListener: <T extends "dispose">(type: T, listener: import('three').EventListener<{
                                dispose: {};
                            }[T], T, import('three').DepthTexture>) => boolean;
                            removeEventListener: <T extends "dispose">(type: T, listener: import('three').EventListener<{
                                dispose: {};
                            }[T], T, import('three').DepthTexture>) => void;
                            dispatchEvent: <T extends "dispose">(event: import('three').BaseEvent<T> & {
                                dispose: {};
                            }[T]) => void;
                        } | null;
                        setSize: (width: number, height: number, depth?: number) => void;
                        clone: () => import('three').RenderTarget<Texture>;
                        copy: (source: import('three').RenderTarget) => import('three').RenderTarget<Texture>;
                        dispose: () => void;
                        addEventListener: <T extends "dispose">(type: T, listener: import('three').EventListener<{
                            dispose: {};
                        }[T], T, import('three').RenderTarget<Texture>>) => void;
                        hasEventListener: <T extends "dispose">(type: T, listener: import('three').EventListener<{
                            dispose: {};
                        }[T], T, import('three').RenderTarget<Texture>>) => boolean;
                        removeEventListener: <T extends "dispose">(type: T, listener: import('three').EventListener<{
                            dispose: {};
                        }[T], T, import('three').RenderTarget<Texture>>) => void;
                        dispatchEvent: <T extends "dispose">(event: import('three').BaseEvent<T> & {
                            dispose: {};
                        }[T]) => void;
                    } | null;
                    onUpdate: ((texture: Texture) => void) | null;
                    transformUv: (uv: import('three').Vector2) => import('three').Vector2;
                    updateMatrix: () => void;
                    addUpdateRange: (start: number, count: number) => void;
                    clearUpdateRanges: () => void;
                    clone: () => import('three').CubeTexture;
                    copy: (source: Texture) => import('three').CubeTexture;
                    setValues: (values: import('three').TextureParameters) => void;
                    toJSON: (meta?: string | {}) => import('three').TextureJSON;
                    dispose: () => void;
                    addEventListener: <T extends "dispose">(type: T, listener: import('three').EventListener<{
                        dispose: {};
                    }[T], T, import('three').CubeTexture>) => void;
                    hasEventListener: <T extends "dispose">(type: T, listener: import('three').EventListener<{
                        dispose: {};
                    }[T], T, import('three').CubeTexture>) => boolean;
                    removeEventListener: <T extends "dispose">(type: T, listener: import('three').EventListener<{
                        dispose: {};
                    }[T], T, import('three').CubeTexture>) => void;
                    dispatchEvent: <T extends "dispose">(event: import('three').BaseEvent<T> & {
                        dispose: {};
                    }[T]) => void;
                }[];
                mapping: import('three').AnyMapping;
                channel: number;
                wrapS: import('three').Wrapping;
                wrapT: import('three').Wrapping;
                magFilter: import('three').MagnificationTextureFilter;
                minFilter: import('three').MinificationTextureFilter;
                anisotropy: number;
                format: import('three').AnyPixelFormat;
                type: import('three').TextureDataType;
                internalFormat: import('three').PixelFormatGPU | null;
                matrix: {
                    readonly isMatrix3: true;
                    elements: [n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number];
                    set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import('three').Matrix3;
                    identity: () => import('three').Matrix3;
                    copy: (m: import('three').Matrix3) => import('three').Matrix3;
                    extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix3;
                    setFromMatrix4: (m: import('three').Matrix4) => import('three').Matrix3;
                    multiply: (m: import('three').Matrix3) => import('three').Matrix3;
                    premultiply: (m: import('three').Matrix3) => import('three').Matrix3;
                    multiplyMatrices: (a: import('three').Matrix3, b: import('three').Matrix3) => import('three').Matrix3;
                    multiplyScalar: (s: number) => import('three').Matrix3;
                    determinant: () => number;
                    invert: () => import('three').Matrix3;
                    transpose: () => import('three').Matrix3;
                    getNormalMatrix: (matrix4: import('three').Matrix4) => import('three').Matrix3;
                    transposeIntoArray: (r: number[]) => import('three').Matrix3;
                    setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import('three').Matrix3;
                    scale: (sx: number, sy: number) => import('three').Matrix3;
                    rotate: (theta: number) => import('three').Matrix3;
                    translate: (tx: number, ty: number) => import('three').Matrix3;
                    makeTranslation: {
                        (v: import('three').Vector2): import('three').Matrix3;
                        (x: number, y: number): import('three').Matrix3;
                    };
                    makeRotation: (theta: number) => import('three').Matrix3;
                    makeScale: (x: number, y: number) => import('three').Matrix3;
                    equals: (matrix: import('three').Matrix3) => boolean;
                    fromArray: (array: ArrayLike<number>, offset?: number) => import('three').Matrix3;
                    toArray: {
                        (): import('three').Matrix3Tuple;
                        <TArray extends ArrayLike<number>>(array: TArray, offset?: number): TArray;
                    };
                    clone: () => import('three').Matrix3;
                };
                matrixAutoUpdate: boolean;
                offset: {
                    x: number;
                    y: number;
                    width: number;
                    height: number;
                    readonly isVector2: true;
                    set: (x: number, y: number) => import('three').Vector2;
                    setScalar: (scalar: number) => import('three').Vector2;
                    setX: (x: number) => import('three').Vector2;
                    setY: (y: number) => import('three').Vector2;
                    setComponent: (index: number, value: number) => import('three').Vector2;
                    getComponent: (index: number) => number;
                    clone: () => import('three').Vector2;
                    copy: (v: import('three').Vector2Like) => import('three').Vector2;
                    add: (v: import('three').Vector2Like) => import('three').Vector2;
                    addScalar: (s: number) => import('three').Vector2;
                    addVectors: (a: import('three').Vector2Like, b: import('three').Vector2Like) => import('three').Vector2;
                    addScaledVector: (v: import('three').Vector2Like, s: number) => import('three').Vector2;
                    sub: (v: import('three').Vector2Like) => import('three').Vector2;
                    subScalar: (s: number) => import('three').Vector2;
                    subVectors: (a: import('three').Vector2Like, b: import('three').Vector2Like) => import('three').Vector2;
                    multiply: (v: import('three').Vector2Like) => import('three').Vector2;
                    multiplyScalar: (scalar: number) => import('three').Vector2;
                    divide: (v: import('three').Vector2Like) => import('three').Vector2;
                    divideScalar: (s: number) => import('three').Vector2;
                    applyMatrix3: (m: import('three').Matrix3) => import('three').Vector2;
                    min: (v: import('three').Vector2Like) => import('three').Vector2;
                    max: (v: import('three').Vector2Like) => import('three').Vector2;
                    clamp: (min: import('three').Vector2Like, max: import('three').Vector2Like) => import('three').Vector2;
                    clampScalar: (min: number, max: number) => import('three').Vector2;
                    clampLength: (min: number, max: number) => import('three').Vector2;
                    floor: () => import('three').Vector2;
                    ceil: () => import('three').Vector2;
                    round: () => import('three').Vector2;
                    roundToZero: () => import('three').Vector2;
                    negate: () => import('three').Vector2;
                    dot: (v: import('three').Vector2Like) => number;
                    cross: (v: import('three').Vector2Like) => number;
                    lengthSq: () => number;
                    length: () => number;
                    manhattanLength: () => number;
                    normalize: () => import('three').Vector2;
                    angle: () => number;
                    angleTo: (v: import('three').Vector2) => number;
                    distanceTo: (v: import('three').Vector2Like) => number;
                    distanceToSquared: (v: import('three').Vector2Like) => number;
                    manhattanDistanceTo: (v: import('three').Vector2Like) => number;
                    setLength: (length: number) => import('three').Vector2;
                    lerp: (v: import('three').Vector2Like, alpha: number) => import('three').Vector2;
                    lerpVectors: (v1: import('three').Vector2Like, v2: import('three').Vector2Like, alpha: number) => import('three').Vector2;
                    equals: (v: import('three').Vector2Like) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector2;
                    toArray: {
                        (array?: number[], offset?: number): number[];
                        (array?: import('three').Vector2Tuple, offset?: 0): import('three').Vector2Tuple;
                        (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import('three').BufferAttribute, index: number) => import('three').Vector2;
                    rotateAround: (center: import('three').Vector2Like, angle: number) => import('three').Vector2;
                    random: () => import('three').Vector2;
                    [Symbol.iterator]: () => Iterator<number>;
                };
                repeat: {
                    x: number;
                    y: number;
                    width: number;
                    height: number;
                    readonly isVector2: true;
                    set: (x: number, y: number) => import('three').Vector2;
                    setScalar: (scalar: number) => import('three').Vector2;
                    setX: (x: number) => import('three').Vector2;
                    setY: (y: number) => import('three').Vector2;
                    setComponent: (index: number, value: number) => import('three').Vector2;
                    getComponent: (index: number) => number;
                    clone: () => import('three').Vector2;
                    copy: (v: import('three').Vector2Like) => import('three').Vector2;
                    add: (v: import('three').Vector2Like) => import('three').Vector2;
                    addScalar: (s: number) => import('three').Vector2;
                    addVectors: (a: import('three').Vector2Like, b: import('three').Vector2Like) => import('three').Vector2;
                    addScaledVector: (v: import('three').Vector2Like, s: number) => import('three').Vector2;
                    sub: (v: import('three').Vector2Like) => import('three').Vector2;
                    subScalar: (s: number) => import('three').Vector2;
                    subVectors: (a: import('three').Vector2Like, b: import('three').Vector2Like) => import('three').Vector2;
                    multiply: (v: import('three').Vector2Like) => import('three').Vector2;
                    multiplyScalar: (scalar: number) => import('three').Vector2;
                    divide: (v: import('three').Vector2Like) => import('three').Vector2;
                    divideScalar: (s: number) => import('three').Vector2;
                    applyMatrix3: (m: import('three').Matrix3) => import('three').Vector2;
                    min: (v: import('three').Vector2Like) => import('three').Vector2;
                    max: (v: import('three').Vector2Like) => import('three').Vector2;
                    clamp: (min: import('three').Vector2Like, max: import('three').Vector2Like) => import('three').Vector2;
                    clampScalar: (min: number, max: number) => import('three').Vector2;
                    clampLength: (min: number, max: number) => import('three').Vector2;
                    floor: () => import('three').Vector2;
                    ceil: () => import('three').Vector2;
                    round: () => import('three').Vector2;
                    roundToZero: () => import('three').Vector2;
                    negate: () => import('three').Vector2;
                    dot: (v: import('three').Vector2Like) => number;
                    cross: (v: import('three').Vector2Like) => number;
                    lengthSq: () => number;
                    length: () => number;
                    manhattanLength: () => number;
                    normalize: () => import('three').Vector2;
                    angle: () => number;
                    angleTo: (v: import('three').Vector2) => number;
                    distanceTo: (v: import('three').Vector2Like) => number;
                    distanceToSquared: (v: import('three').Vector2Like) => number;
                    manhattanDistanceTo: (v: import('three').Vector2Like) => number;
                    setLength: (length: number) => import('three').Vector2;
                    lerp: (v: import('three').Vector2Like, alpha: number) => import('three').Vector2;
                    lerpVectors: (v1: import('three').Vector2Like, v2: import('three').Vector2Like, alpha: number) => import('three').Vector2;
                    equals: (v: import('three').Vector2Like) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector2;
                    toArray: {
                        (array?: number[], offset?: number): number[];
                        (array?: import('three').Vector2Tuple, offset?: 0): import('three').Vector2Tuple;
                        (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import('three').BufferAttribute, index: number) => import('three').Vector2;
                    rotateAround: (center: import('three').Vector2Like, angle: number) => import('three').Vector2;
                    random: () => import('three').Vector2;
                    [Symbol.iterator]: () => Iterator<number>;
                };
                center: {
                    x: number;
                    y: number;
                    width: number;
                    height: number;
                    readonly isVector2: true;
                    set: (x: number, y: number) => import('three').Vector2;
                    setScalar: (scalar: number) => import('three').Vector2;
                    setX: (x: number) => import('three').Vector2;
                    setY: (y: number) => import('three').Vector2;
                    setComponent: (index: number, value: number) => import('three').Vector2;
                    getComponent: (index: number) => number;
                    clone: () => import('three').Vector2;
                    copy: (v: import('three').Vector2Like) => import('three').Vector2;
                    add: (v: import('three').Vector2Like) => import('three').Vector2;
                    addScalar: (s: number) => import('three').Vector2;
                    addVectors: (a: import('three').Vector2Like, b: import('three').Vector2Like) => import('three').Vector2;
                    addScaledVector: (v: import('three').Vector2Like, s: number) => import('three').Vector2;
                    sub: (v: import('three').Vector2Like) => import('three').Vector2;
                    subScalar: (s: number) => import('three').Vector2;
                    subVectors: (a: import('three').Vector2Like, b: import('three').Vector2Like) => import('three').Vector2;
                    multiply: (v: import('three').Vector2Like) => import('three').Vector2;
                    multiplyScalar: (scalar: number) => import('three').Vector2;
                    divide: (v: import('three').Vector2Like) => import('three').Vector2;
                    divideScalar: (s: number) => import('three').Vector2;
                    applyMatrix3: (m: import('three').Matrix3) => import('three').Vector2;
                    min: (v: import('three').Vector2Like) => import('three').Vector2;
                    max: (v: import('three').Vector2Like) => import('three').Vector2;
                    clamp: (min: import('three').Vector2Like, max: import('three').Vector2Like) => import('three').Vector2;
                    clampScalar: (min: number, max: number) => import('three').Vector2;
                    clampLength: (min: number, max: number) => import('three').Vector2;
                    floor: () => import('three').Vector2;
                    ceil: () => import('three').Vector2;
                    round: () => import('three').Vector2;
                    roundToZero: () => import('three').Vector2;
                    negate: () => import('three').Vector2;
                    dot: (v: import('three').Vector2Like) => number;
                    cross: (v: import('three').Vector2Like) => number;
                    lengthSq: () => number;
                    length: () => number;
                    manhattanLength: () => number;
                    normalize: () => import('three').Vector2;
                    angle: () => number;
                    angleTo: (v: import('three').Vector2) => number;
                    distanceTo: (v: import('three').Vector2Like) => number;
                    distanceToSquared: (v: import('three').Vector2Like) => number;
                    manhattanDistanceTo: (v: import('three').Vector2Like) => number;
                    setLength: (length: number) => import('three').Vector2;
                    lerp: (v: import('three').Vector2Like, alpha: number) => import('three').Vector2;
                    lerpVectors: (v1: import('three').Vector2Like, v2: import('three').Vector2Like, alpha: number) => import('three').Vector2;
                    equals: (v: import('three').Vector2Like) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector2;
                    toArray: {
                        (array?: number[], offset?: number): number[];
                        (array?: import('three').Vector2Tuple, offset?: 0): import('three').Vector2Tuple;
                        (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import('three').BufferAttribute, index: number) => import('three').Vector2;
                    rotateAround: (center: import('three').Vector2Like, angle: number) => import('three').Vector2;
                    random: () => import('three').Vector2;
                    [Symbol.iterator]: () => Iterator<number>;
                };
                rotation: number;
                generateMipmaps: boolean;
                premultiplyAlpha: boolean;
                flipY: boolean;
                unpackAlignment: number;
                colorSpace: string;
                isRenderTargetTexture: boolean;
                isArrayTexture: boolean;
                userData: Record<string, any>;
                updateRanges: {
                    start: number;
                    count: number;
                }[];
                version: number;
                pmremVersion: number;
                needsUpdate: boolean;
                needsPMREMUpdate: boolean;
                renderTarget: {
                    readonly isRenderTarget: true;
                    width: number;
                    height: number;
                    depth: number;
                    scissor: {
                        x: number;
                        y: number;
                        z: number;
                        w: number;
                        width: number;
                        height: number;
                        readonly isVector4: true;
                        set: (x: number, y: number, z: number, w: number) => import('three').Vector4;
                        setScalar: (scalar: number) => import('three').Vector4;
                        setX: (x: number) => import('three').Vector4;
                        setY: (y: number) => import('three').Vector4;
                        setZ: (z: number) => import('three').Vector4;
                        setW: (w: number) => import('three').Vector4;
                        setComponent: (index: number, value: number) => import('three').Vector4;
                        getComponent: (index: number) => number;
                        clone: () => import('three').Vector4;
                        copy: (v: import('three').Vector4Like) => import('three').Vector4;
                        add: (v: import('three').Vector4Like) => import('three').Vector4;
                        addScalar: (scalar: number) => import('three').Vector4;
                        addVectors: (a: import('three').Vector4Like, b: import('three').Vector4Like) => import('three').Vector4;
                        addScaledVector: (v: import('three').Vector4Like, s: number) => import('three').Vector4;
                        sub: (v: import('three').Vector4Like) => import('three').Vector4;
                        subScalar: (s: number) => import('three').Vector4;
                        subVectors: (a: import('three').Vector4Like, b: import('three').Vector4Like) => import('three').Vector4;
                        multiply: (v: import('three').Vector4Like) => import('three').Vector4;
                        multiplyScalar: (s: number) => import('three').Vector4;
                        applyMatrix4: (m: import('three').Matrix4) => import('three').Vector4;
                        divide: (v: import('three').Vector4Like) => import('three').Vector4;
                        divideScalar: (s: number) => import('three').Vector4;
                        setAxisAngleFromQuaternion: (q: import('three').QuaternionLike) => import('three').Vector4;
                        setAxisAngleFromRotationMatrix: (m: import('three').Matrix4) => import('three').Vector4;
                        setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector4;
                        min: (v: import('three').Vector4Like) => import('three').Vector4;
                        max: (v: import('three').Vector4Like) => import('three').Vector4;
                        clamp: (min: import('three').Vector4Like, max: import('three').Vector4Like) => import('three').Vector4;
                        clampScalar: (min: number, max: number) => import('three').Vector4;
                        floor: () => import('three').Vector4;
                        ceil: () => import('three').Vector4;
                        round: () => import('three').Vector4;
                        roundToZero: () => import('three').Vector4;
                        negate: () => import('three').Vector4;
                        dot: (v: import('three').Vector4Like) => number;
                        lengthSq: () => number;
                        length: () => number;
                        manhattanLength: () => number;
                        normalize: () => import('three').Vector4;
                        setLength: (length: number) => import('three').Vector4;
                        lerp: (v: import('three').Vector4Like, alpha: number) => import('three').Vector4;
                        lerpVectors: (v1: import('three').Vector4Like, v2: import('three').Vector4Like, alpha: number) => import('three').Vector4;
                        equals: (v: import('three').Vector4Like) => boolean;
                        fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector4;
                        toArray: {
                            (array?: number[], offset?: number): number[];
                            (array?: import('three').Vector4Tuple, offset?: 0): import('three').Vector4Tuple;
                            (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                        };
                        fromBufferAttribute: (attribute: import('three').BufferAttribute, index: number) => import('three').Vector4;
                        random: () => import('three').Vector4;
                        [Symbol.iterator]: () => Iterator<number>;
                    };
                    scissorTest: boolean;
                    viewport: {
                        x: number;
                        y: number;
                        z: number;
                        w: number;
                        width: number;
                        height: number;
                        readonly isVector4: true;
                        set: (x: number, y: number, z: number, w: number) => import('three').Vector4;
                        setScalar: (scalar: number) => import('three').Vector4;
                        setX: (x: number) => import('three').Vector4;
                        setY: (y: number) => import('three').Vector4;
                        setZ: (z: number) => import('three').Vector4;
                        setW: (w: number) => import('three').Vector4;
                        setComponent: (index: number, value: number) => import('three').Vector4;
                        getComponent: (index: number) => number;
                        clone: () => import('three').Vector4;
                        copy: (v: import('three').Vector4Like) => import('three').Vector4;
                        add: (v: import('three').Vector4Like) => import('three').Vector4;
                        addScalar: (scalar: number) => import('three').Vector4;
                        addVectors: (a: import('three').Vector4Like, b: import('three').Vector4Like) => import('three').Vector4;
                        addScaledVector: (v: import('three').Vector4Like, s: number) => import('three').Vector4;
                        sub: (v: import('three').Vector4Like) => import('three').Vector4;
                        subScalar: (s: number) => import('three').Vector4;
                        subVectors: (a: import('three').Vector4Like, b: import('three').Vector4Like) => import('three').Vector4;
                        multiply: (v: import('three').Vector4Like) => import('three').Vector4;
                        multiplyScalar: (s: number) => import('three').Vector4;
                        applyMatrix4: (m: import('three').Matrix4) => import('three').Vector4;
                        divide: (v: import('three').Vector4Like) => import('three').Vector4;
                        divideScalar: (s: number) => import('three').Vector4;
                        setAxisAngleFromQuaternion: (q: import('three').QuaternionLike) => import('three').Vector4;
                        setAxisAngleFromRotationMatrix: (m: import('three').Matrix4) => import('three').Vector4;
                        setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector4;
                        min: (v: import('three').Vector4Like) => import('three').Vector4;
                        max: (v: import('three').Vector4Like) => import('three').Vector4;
                        clamp: (min: import('three').Vector4Like, max: import('three').Vector4Like) => import('three').Vector4;
                        clampScalar: (min: number, max: number) => import('three').Vector4;
                        floor: () => import('three').Vector4;
                        ceil: () => import('three').Vector4;
                        round: () => import('three').Vector4;
                        roundToZero: () => import('three').Vector4;
                        negate: () => import('three').Vector4;
                        dot: (v: import('three').Vector4Like) => number;
                        lengthSq: () => number;
                        length: () => number;
                        manhattanLength: () => number;
                        normalize: () => import('three').Vector4;
                        setLength: (length: number) => import('three').Vector4;
                        lerp: (v: import('three').Vector4Like, alpha: number) => import('three').Vector4;
                        lerpVectors: (v1: import('three').Vector4Like, v2: import('three').Vector4Like, alpha: number) => import('three').Vector4;
                        equals: (v: import('three').Vector4Like) => boolean;
                        fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector4;
                        toArray: {
                            (array?: number[], offset?: number): number[];
                            (array?: import('three').Vector4Tuple, offset?: 0): import('three').Vector4Tuple;
                            (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                        };
                        fromBufferAttribute: (attribute: import('three').BufferAttribute, index: number) => import('three').Vector4;
                        random: () => import('three').Vector4;
                        [Symbol.iterator]: () => Iterator<number>;
                    };
                    textures: /*elided*/ any[];
                    depthBuffer: boolean;
                    stencilBuffer: boolean;
                    resolveDepthBuffer: boolean;
                    resolveStencilBuffer: boolean;
                    samples: number;
                    multiview: boolean;
                    texture: /*elided*/ any;
                    depthTexture: {
                        readonly isDepthTexture: true;
                        image: {
                            width: number;
                            height: number;
                            depth: number;
                        };
                        flipY: boolean;
                        magFilter: import('three').MagnificationTextureFilter;
                        minFilter: import('three').MinificationTextureFilter;
                        generateMipmaps: boolean;
                        format: import('three').DepthTexturePixelFormat;
                        type: import('three').TextureDataType;
                        compareFunction: import('three').TextureComparisonFunction | null;
                        readonly isTexture: true;
                        readonly id: number;
                        uuid: string;
                        name: string;
                        source: {
                            readonly isSource: true;
                            readonly id: number;
                            uuid: string;
                            data: any;
                            dataReady: boolean;
                            version: number;
                            getSize: (target: import('three').Vector3) => import('three').Vector3;
                            needsUpdate: boolean;
                            toJSON: (meta?: string | {}) => import('three').SourceJSON;
                        };
                        readonly width: number;
                        readonly height: number;
                        readonly depth: number;
                        mipmaps: HTMLCanvasElement[] | {
                            data: {
                                [x: number]: number;
                                readonly BYTES_PER_ELEMENT: number;
                                readonly buffer: {
                                    readonly byteLength: number;
                                    slice: (begin?: number, end?: number) => ArrayBuffer;
                                    readonly maxByteLength: number;
                                    readonly resizable: boolean;
                                    resize: (newByteLength?: number) => void;
                                    readonly detached: boolean;
                                    transfer: (newByteLength?: number) => ArrayBuffer;
                                    transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                                    readonly [Symbol.toStringTag]: string;
                                } | {
                                    readonly byteLength: number;
                                    slice: (begin?: number, end?: number) => SharedArrayBuffer;
                                    readonly growable: boolean;
                                    readonly maxByteLength: number;
                                    grow: (newByteLength?: number) => void;
                                    readonly [Symbol.species]: SharedArrayBuffer;
                                    readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                                };
                                readonly byteLength: number;
                                readonly byteOffset: number;
                                copyWithin: (target: number, start: number, end?: number) => Int8Array<ArrayBufferLike>;
                                every: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                fill: (value: number, start?: number, end?: number) => Int8Array<ArrayBufferLike>;
                                filter: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => any, thisArg?: any) => Int8Array<ArrayBuffer>;
                                find: (predicate: (value: number, index: number, obj: Int8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                                findIndex: (predicate: (value: number, index: number, obj: Int8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                                forEach: (callbackfn: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                                indexOf: (searchElement: number, fromIndex?: number) => number;
                                join: (separator?: string) => string;
                                lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                                readonly length: number;
                                map: (callbackfn: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => number, thisArg?: any) => Int8Array<ArrayBuffer>;
                                reduce: {
                                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number): number;
                                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number, initialValue: number): number;
                                    <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => U, initialValue: U): U;
                                };
                                reduceRight: {
                                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number): number;
                                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number, initialValue: number): number;
                                    <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => U, initialValue: U): U;
                                };
                                reverse: () => Int8Array<ArrayBufferLike>;
                                set: (array: ArrayLike<number>, offset?: number) => void;
                                slice: (start?: number, end?: number) => Int8Array<ArrayBuffer>;
                                some: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Int8Array<ArrayBufferLike>;
                                subarray: (begin?: number, end?: number) => Int8Array<ArrayBufferLike>;
                                toLocaleString: {
                                    (): string;
                                    (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                                };
                                toString: () => string;
                                valueOf: () => Int8Array<ArrayBufferLike>;
                                entries: () => ArrayIterator<[number, number]>;
                                keys: () => ArrayIterator<number>;
                                values: () => ArrayIterator<number>;
                                includes: (searchElement: number, fromIndex?: number) => boolean;
                                at: (index: number) => number | undefined;
                                findLast: {
                                    <S extends number>(predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                                    (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                                };
                                findLastIndex: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                                toReversed: () => Int8Array<ArrayBuffer>;
                                toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Int8Array<ArrayBuffer>;
                                with: (index: number, value: number) => Int8Array<ArrayBuffer>;
                                [Symbol.iterator]: () => ArrayIterator<number>;
                                readonly [Symbol.toStringTag]: "Int8Array";
                            } | {
                                [x: number]: number;
                                readonly BYTES_PER_ELEMENT: number;
                                readonly buffer: {
                                    readonly byteLength: number;
                                    slice: (begin?: number, end?: number) => ArrayBuffer;
                                    readonly maxByteLength: number;
                                    readonly resizable: boolean;
                                    resize: (newByteLength?: number) => void;
                                    readonly detached: boolean;
                                    transfer: (newByteLength?: number) => ArrayBuffer;
                                    transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                                    readonly [Symbol.toStringTag]: string;
                                } | {
                                    readonly byteLength: number;
                                    slice: (begin?: number, end?: number) => SharedArrayBuffer;
                                    readonly growable: boolean;
                                    readonly maxByteLength: number;
                                    grow: (newByteLength?: number) => void;
                                    readonly [Symbol.species]: SharedArrayBuffer;
                                    readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                                };
                                readonly byteLength: number;
                                readonly byteOffset: number;
                                copyWithin: (target: number, start: number, end?: number) => Uint8Array<ArrayBufferLike>;
                                every: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                fill: (value: number, start?: number, end?: number) => Uint8Array<ArrayBufferLike>;
                                filter: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => any, thisArg?: any) => Uint8Array<ArrayBuffer>;
                                find: (predicate: (value: number, index: number, obj: Uint8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                                findIndex: (predicate: (value: number, index: number, obj: Uint8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                                forEach: (callbackfn: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                                indexOf: (searchElement: number, fromIndex?: number) => number;
                                join: (separator?: string) => string;
                                lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                                readonly length: number;
                                map: (callbackfn: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => number, thisArg?: any) => Uint8Array<ArrayBuffer>;
                                reduce: {
                                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number): number;
                                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number, initialValue: number): number;
                                    <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => U, initialValue: U): U;
                                };
                                reduceRight: {
                                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number): number;
                                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number, initialValue: number): number;
                                    <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => U, initialValue: U): U;
                                };
                                reverse: () => Uint8Array<ArrayBufferLike>;
                                set: (array: ArrayLike<number>, offset?: number) => void;
                                slice: (start?: number, end?: number) => Uint8Array<ArrayBuffer>;
                                some: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8Array<ArrayBufferLike>;
                                subarray: (begin?: number, end?: number) => Uint8Array<ArrayBufferLike>;
                                toLocaleString: {
                                    (): string;
                                    (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                                };
                                toString: () => string;
                                valueOf: () => Uint8Array<ArrayBufferLike>;
                                entries: () => ArrayIterator<[number, number]>;
                                keys: () => ArrayIterator<number>;
                                values: () => ArrayIterator<number>;
                                includes: (searchElement: number, fromIndex?: number) => boolean;
                                at: (index: number) => number | undefined;
                                findLast: {
                                    <S extends number>(predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                                    (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                                };
                                findLastIndex: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                                toReversed: () => Uint8Array<ArrayBuffer>;
                                toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8Array<ArrayBuffer>;
                                with: (index: number, value: number) => Uint8Array<ArrayBuffer>;
                                [Symbol.iterator]: () => ArrayIterator<number>;
                                readonly [Symbol.toStringTag]: "Uint8Array";
                            } | {
                                [x: number]: number;
                                readonly BYTES_PER_ELEMENT: number;
                                readonly buffer: {
                                    readonly byteLength: number;
                                    slice: (begin?: number, end?: number) => ArrayBuffer;
                                    readonly maxByteLength: number;
                                    readonly resizable: boolean;
                                    resize: (newByteLength?: number) => void;
                                    readonly detached: boolean;
                                    transfer: (newByteLength?: number) => ArrayBuffer;
                                    transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                                    readonly [Symbol.toStringTag]: string;
                                } | {
                                    readonly byteLength: number;
                                    slice: (begin?: number, end?: number) => SharedArrayBuffer;
                                    readonly growable: boolean;
                                    readonly maxByteLength: number;
                                    grow: (newByteLength?: number) => void;
                                    readonly [Symbol.species]: SharedArrayBuffer;
                                    readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                                };
                                readonly byteLength: number;
                                readonly byteOffset: number;
                                copyWithin: (target: number, start: number, end?: number) => Uint8ClampedArray<ArrayBufferLike>;
                                every: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                fill: (value: number, start?: number, end?: number) => Uint8ClampedArray<ArrayBufferLike>;
                                filter: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => any, thisArg?: any) => Uint8ClampedArray<ArrayBuffer>;
                                find: (predicate: (value: number, index: number, obj: Uint8ClampedArray<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                                findIndex: (predicate: (value: number, index: number, obj: Uint8ClampedArray<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                                forEach: (callbackfn: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => void, thisArg?: any) => void;
                                indexOf: (searchElement: number, fromIndex?: number) => number;
                                join: (separator?: string) => string;
                                lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                                readonly length: number;
                                map: (callbackfn: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => number, thisArg?: any) => Uint8ClampedArray<ArrayBuffer>;
                                reduce: {
                                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number): number;
                                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number, initialValue: number): number;
                                    <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => U, initialValue: U): U;
                                };
                                reduceRight: {
                                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number): number;
                                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number, initialValue: number): number;
                                    <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => U, initialValue: U): U;
                                };
                                reverse: () => Uint8ClampedArray<ArrayBufferLike>;
                                set: (array: ArrayLike<number>, offset?: number) => void;
                                slice: (start?: number, end?: number) => Uint8ClampedArray<ArrayBuffer>;
                                some: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8ClampedArray<ArrayBufferLike>;
                                subarray: (begin?: number, end?: number) => Uint8ClampedArray<ArrayBufferLike>;
                                toLocaleString: {
                                    (): string;
                                    (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                                };
                                toString: () => string;
                                valueOf: () => Uint8ClampedArray<ArrayBufferLike>;
                                entries: () => ArrayIterator<[number, number]>;
                                keys: () => ArrayIterator<number>;
                                values: () => ArrayIterator<number>;
                                includes: (searchElement: number, fromIndex?: number) => boolean;
                                at: (index: number) => number | undefined;
                                findLast: {
                                    <S extends number>(predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                                    (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                                };
                                findLastIndex: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                                toReversed: () => Uint8ClampedArray<ArrayBuffer>;
                                toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8ClampedArray<ArrayBuffer>;
                                with: (index: number, value: number) => Uint8ClampedArray<ArrayBuffer>;
                                [Symbol.iterator]: () => ArrayIterator<number>;
                                readonly [Symbol.toStringTag]: "Uint8ClampedArray";
                            } | {
                                [x: number]: number;
                                readonly BYTES_PER_ELEMENT: number;
                                readonly buffer: {
                                    readonly byteLength: number;
                                    slice: (begin?: number, end?: number) => ArrayBuffer;
                                    readonly maxByteLength: number;
                                    readonly resizable: boolean;
                                    resize: (newByteLength?: number) => void;
                                    readonly detached: boolean;
                                    transfer: (newByteLength?: number) => ArrayBuffer;
                                    transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                                    readonly [Symbol.toStringTag]: string;
                                } | {
                                    readonly byteLength: number;
                                    slice: (begin?: number, end?: number) => SharedArrayBuffer;
                                    readonly growable: boolean;
                                    readonly maxByteLength: number;
                                    grow: (newByteLength?: number) => void;
                                    readonly [Symbol.species]: SharedArrayBuffer;
                                    readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                                };
                                readonly byteLength: number;
                                readonly byteOffset: number;
                                copyWithin: (target: number, start: number, end?: number) => Int16Array<ArrayBufferLike>;
                                every: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                fill: (value: number, start?: number, end?: number) => Int16Array<ArrayBufferLike>;
                                filter: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => any, thisArg?: any) => Int16Array<ArrayBuffer>;
                                find: (predicate: (value: number, index: number, obj: Int16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                                findIndex: (predicate: (value: number, index: number, obj: Int16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                                forEach: (callbackfn: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                                indexOf: (searchElement: number, fromIndex?: number) => number;
                                join: (separator?: string) => string;
                                lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                                readonly length: number;
                                map: (callbackfn: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => number, thisArg?: any) => Int16Array<ArrayBuffer>;
                                reduce: {
                                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number): number;
                                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number, initialValue: number): number;
                                    <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => U, initialValue: U): U;
                                };
                                reduceRight: {
                                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number): number;
                                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number, initialValue: number): number;
                                    <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => U, initialValue: U): U;
                                };
                                reverse: () => Int16Array<ArrayBufferLike>;
                                set: (array: ArrayLike<number>, offset?: number) => void;
                                slice: (start?: number, end?: number) => Int16Array<ArrayBuffer>;
                                some: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Int16Array<ArrayBufferLike>;
                                subarray: (begin?: number, end?: number) => Int16Array<ArrayBufferLike>;
                                toLocaleString: {
                                    (): string;
                                    (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                                };
                                toString: () => string;
                                valueOf: () => Int16Array<ArrayBufferLike>;
                                entries: () => ArrayIterator<[number, number]>;
                                keys: () => ArrayIterator<number>;
                                values: () => ArrayIterator<number>;
                                includes: (searchElement: number, fromIndex?: number) => boolean;
                                at: (index: number) => number | undefined;
                                findLast: {
                                    <S extends number>(predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                                    (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                                };
                                findLastIndex: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                                toReversed: () => Int16Array<ArrayBuffer>;
                                toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Int16Array<ArrayBuffer>;
                                with: (index: number, value: number) => Int16Array<ArrayBuffer>;
                                [Symbol.iterator]: () => ArrayIterator<number>;
                                readonly [Symbol.toStringTag]: "Int16Array";
                            } | {
                                [x: number]: number;
                                readonly BYTES_PER_ELEMENT: number;
                                readonly buffer: {
                                    readonly byteLength: number;
                                    slice: (begin?: number, end?: number) => ArrayBuffer;
                                    readonly maxByteLength: number;
                                    readonly resizable: boolean;
                                    resize: (newByteLength?: number) => void;
                                    readonly detached: boolean;
                                    transfer: (newByteLength?: number) => ArrayBuffer;
                                    transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                                    readonly [Symbol.toStringTag]: string;
                                } | {
                                    readonly byteLength: number;
                                    slice: (begin?: number, end?: number) => SharedArrayBuffer;
                                    readonly growable: boolean;
                                    readonly maxByteLength: number;
                                    grow: (newByteLength?: number) => void;
                                    readonly [Symbol.species]: SharedArrayBuffer;
                                    readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                                };
                                readonly byteLength: number;
                                readonly byteOffset: number;
                                copyWithin: (target: number, start: number, end?: number) => Uint16Array<ArrayBufferLike>;
                                every: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                fill: (value: number, start?: number, end?: number) => Uint16Array<ArrayBufferLike>;
                                filter: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => any, thisArg?: any) => Uint16Array<ArrayBuffer>;
                                find: (predicate: (value: number, index: number, obj: Uint16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                                findIndex: (predicate: (value: number, index: number, obj: Uint16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                                forEach: (callbackfn: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                                indexOf: (searchElement: number, fromIndex?: number) => number;
                                join: (separator?: string) => string;
                                lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                                readonly length: number;
                                map: (callbackfn: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => number, thisArg?: any) => Uint16Array<ArrayBuffer>;
                                reduce: {
                                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number): number;
                                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number, initialValue: number): number;
                                    <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => U, initialValue: U): U;
                                };
                                reduceRight: {
                                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number): number;
                                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number, initialValue: number): number;
                                    <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => U, initialValue: U): U;
                                };
                                reverse: () => Uint16Array<ArrayBufferLike>;
                                set: (array: ArrayLike<number>, offset?: number) => void;
                                slice: (start?: number, end?: number) => Uint16Array<ArrayBuffer>;
                                some: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint16Array<ArrayBufferLike>;
                                subarray: (begin?: number, end?: number) => Uint16Array<ArrayBufferLike>;
                                toLocaleString: {
                                    (): string;
                                    (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                                };
                                toString: () => string;
                                valueOf: () => Uint16Array<ArrayBufferLike>;
                                entries: () => ArrayIterator<[number, number]>;
                                keys: () => ArrayIterator<number>;
                                values: () => ArrayIterator<number>;
                                includes: (searchElement: number, fromIndex?: number) => boolean;
                                at: (index: number) => number | undefined;
                                findLast: {
                                    <S extends number>(predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                                    (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                                };
                                findLastIndex: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                                toReversed: () => Uint16Array<ArrayBuffer>;
                                toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint16Array<ArrayBuffer>;
                                with: (index: number, value: number) => Uint16Array<ArrayBuffer>;
                                [Symbol.iterator]: () => ArrayIterator<number>;
                                readonly [Symbol.toStringTag]: "Uint16Array";
                            } | {
                                [x: number]: number;
                                readonly BYTES_PER_ELEMENT: number;
                                readonly buffer: {
                                    readonly byteLength: number;
                                    slice: (begin?: number, end?: number) => ArrayBuffer;
                                    readonly maxByteLength: number;
                                    readonly resizable: boolean;
                                    resize: (newByteLength?: number) => void;
                                    readonly detached: boolean;
                                    transfer: (newByteLength?: number) => ArrayBuffer;
                                    transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                                    readonly [Symbol.toStringTag]: string;
                                } | {
                                    readonly byteLength: number;
                                    slice: (begin?: number, end?: number) => SharedArrayBuffer;
                                    readonly growable: boolean;
                                    readonly maxByteLength: number;
                                    grow: (newByteLength?: number) => void;
                                    readonly [Symbol.species]: SharedArrayBuffer;
                                    readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                                };
                                readonly byteLength: number;
                                readonly byteOffset: number;
                                copyWithin: (target: number, start: number, end?: number) => Int32Array<ArrayBufferLike>;
                                every: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                fill: (value: number, start?: number, end?: number) => Int32Array<ArrayBufferLike>;
                                filter: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => any, thisArg?: any) => Int32Array<ArrayBuffer>;
                                find: (predicate: (value: number, index: number, obj: Int32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                                findIndex: (predicate: (value: number, index: number, obj: Int32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                                forEach: (callbackfn: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                                indexOf: (searchElement: number, fromIndex?: number) => number;
                                join: (separator?: string) => string;
                                lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                                readonly length: number;
                                map: (callbackfn: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => number, thisArg?: any) => Int32Array<ArrayBuffer>;
                                reduce: {
                                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number): number;
                                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number, initialValue: number): number;
                                    <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => U, initialValue: U): U;
                                };
                                reduceRight: {
                                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number): number;
                                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number, initialValue: number): number;
                                    <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => U, initialValue: U): U;
                                };
                                reverse: () => Int32Array<ArrayBufferLike>;
                                set: (array: ArrayLike<number>, offset?: number) => void;
                                slice: (start?: number, end?: number) => Int32Array<ArrayBuffer>;
                                some: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Int32Array<ArrayBufferLike>;
                                subarray: (begin?: number, end?: number) => Int32Array<ArrayBufferLike>;
                                toLocaleString: {
                                    (): string;
                                    (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                                };
                                toString: () => string;
                                valueOf: () => Int32Array<ArrayBufferLike>;
                                entries: () => ArrayIterator<[number, number]>;
                                keys: () => ArrayIterator<number>;
                                values: () => ArrayIterator<number>;
                                includes: (searchElement: number, fromIndex?: number) => boolean;
                                at: (index: number) => number | undefined;
                                findLast: {
                                    <S extends number>(predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                                    (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                                };
                                findLastIndex: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                                toReversed: () => Int32Array<ArrayBuffer>;
                                toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Int32Array<ArrayBuffer>;
                                with: (index: number, value: number) => Int32Array<ArrayBuffer>;
                                [Symbol.iterator]: () => ArrayIterator<number>;
                                readonly [Symbol.toStringTag]: "Int32Array";
                            } | {
                                [x: number]: number;
                                readonly BYTES_PER_ELEMENT: number;
                                readonly buffer: {
                                    readonly byteLength: number;
                                    slice: (begin?: number, end?: number) => ArrayBuffer;
                                    readonly maxByteLength: number;
                                    readonly resizable: boolean;
                                    resize: (newByteLength?: number) => void;
                                    readonly detached: boolean;
                                    transfer: (newByteLength?: number) => ArrayBuffer;
                                    transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                                    readonly [Symbol.toStringTag]: string;
                                } | {
                                    readonly byteLength: number;
                                    slice: (begin?: number, end?: number) => SharedArrayBuffer;
                                    readonly growable: boolean;
                                    readonly maxByteLength: number;
                                    grow: (newByteLength?: number) => void;
                                    readonly [Symbol.species]: SharedArrayBuffer;
                                    readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                                };
                                readonly byteLength: number;
                                readonly byteOffset: number;
                                copyWithin: (target: number, start: number, end?: number) => Uint32Array<ArrayBufferLike>;
                                every: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                fill: (value: number, start?: number, end?: number) => Uint32Array<ArrayBufferLike>;
                                filter: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => any, thisArg?: any) => Uint32Array<ArrayBuffer>;
                                find: (predicate: (value: number, index: number, obj: Uint32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                                findIndex: (predicate: (value: number, index: number, obj: Uint32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                                forEach: (callbackfn: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                                indexOf: (searchElement: number, fromIndex?: number) => number;
                                join: (separator?: string) => string;
                                lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                                readonly length: number;
                                map: (callbackfn: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => number, thisArg?: any) => Uint32Array<ArrayBuffer>;
                                reduce: {
                                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number): number;
                                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number, initialValue: number): number;
                                    <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => U, initialValue: U): U;
                                };
                                reduceRight: {
                                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number): number;
                                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number, initialValue: number): number;
                                    <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => U, initialValue: U): U;
                                };
                                reverse: () => Uint32Array<ArrayBufferLike>;
                                set: (array: ArrayLike<number>, offset?: number) => void;
                                slice: (start?: number, end?: number) => Uint32Array<ArrayBuffer>;
                                some: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint32Array<ArrayBufferLike>;
                                subarray: (begin?: number, end?: number) => Uint32Array<ArrayBufferLike>;
                                toLocaleString: {
                                    (): string;
                                    (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                                };
                                toString: () => string;
                                valueOf: () => Uint32Array<ArrayBufferLike>;
                                entries: () => ArrayIterator<[number, number]>;
                                keys: () => ArrayIterator<number>;
                                values: () => ArrayIterator<number>;
                                includes: (searchElement: number, fromIndex?: number) => boolean;
                                at: (index: number) => number | undefined;
                                findLast: {
                                    <S extends number>(predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                                    (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                                };
                                findLastIndex: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                                toReversed: () => Uint32Array<ArrayBuffer>;
                                toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint32Array<ArrayBuffer>;
                                with: (index: number, value: number) => Uint32Array<ArrayBuffer>;
                                [Symbol.iterator]: () => ArrayIterator<number>;
                                readonly [Symbol.toStringTag]: "Uint32Array";
                            } | {
                                [x: number]: number;
                                readonly BYTES_PER_ELEMENT: number;
                                readonly buffer: {
                                    readonly byteLength: number;
                                    slice: (begin?: number, end?: number) => ArrayBuffer;
                                    readonly maxByteLength: number;
                                    readonly resizable: boolean;
                                    resize: (newByteLength?: number) => void;
                                    readonly detached: boolean;
                                    transfer: (newByteLength?: number) => ArrayBuffer;
                                    transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                                    readonly [Symbol.toStringTag]: string;
                                } | {
                                    readonly byteLength: number;
                                    slice: (begin?: number, end?: number) => SharedArrayBuffer;
                                    readonly growable: boolean;
                                    readonly maxByteLength: number;
                                    grow: (newByteLength?: number) => void;
                                    readonly [Symbol.species]: SharedArrayBuffer;
                                    readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                                };
                                readonly byteLength: number;
                                readonly byteOffset: number;
                                copyWithin: (target: number, start: number, end?: number) => Float32Array<ArrayBufferLike>;
                                every: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                fill: (value: number, start?: number, end?: number) => Float32Array<ArrayBufferLike>;
                                filter: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => any, thisArg?: any) => Float32Array<ArrayBuffer>;
                                find: (predicate: (value: number, index: number, obj: Float32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                                findIndex: (predicate: (value: number, index: number, obj: Float32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                                forEach: (callbackfn: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                                indexOf: (searchElement: number, fromIndex?: number) => number;
                                join: (separator?: string) => string;
                                lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                                readonly length: number;
                                map: (callbackfn: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => number, thisArg?: any) => Float32Array<ArrayBuffer>;
                                reduce: {
                                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number): number;
                                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number, initialValue: number): number;
                                    <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => U, initialValue: U): U;
                                };
                                reduceRight: {
                                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number): number;
                                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number, initialValue: number): number;
                                    <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => U, initialValue: U): U;
                                };
                                reverse: () => Float32Array<ArrayBufferLike>;
                                set: (array: ArrayLike<number>, offset?: number) => void;
                                slice: (start?: number, end?: number) => Float32Array<ArrayBuffer>;
                                some: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array<ArrayBufferLike>;
                                subarray: (begin?: number, end?: number) => Float32Array<ArrayBufferLike>;
                                toLocaleString: {
                                    (): string;
                                    (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                                };
                                toString: () => string;
                                valueOf: () => Float32Array<ArrayBufferLike>;
                                entries: () => ArrayIterator<[number, number]>;
                                keys: () => ArrayIterator<number>;
                                values: () => ArrayIterator<number>;
                                includes: (searchElement: number, fromIndex?: number) => boolean;
                                at: (index: number) => number | undefined;
                                findLast: {
                                    <S extends number>(predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                                    (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                                };
                                findLastIndex: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                                toReversed: () => Float32Array<ArrayBuffer>;
                                toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array<ArrayBuffer>;
                                with: (index: number, value: number) => Float32Array<ArrayBuffer>;
                                [Symbol.iterator]: () => ArrayIterator<number>;
                                readonly [Symbol.toStringTag]: "Float32Array";
                            } | {
                                [x: number]: number;
                                readonly BYTES_PER_ELEMENT: number;
                                readonly buffer: {
                                    readonly byteLength: number;
                                    slice: (begin?: number, end?: number) => ArrayBuffer;
                                    readonly maxByteLength: number;
                                    readonly resizable: boolean;
                                    resize: (newByteLength?: number) => void;
                                    readonly detached: boolean;
                                    transfer: (newByteLength?: number) => ArrayBuffer;
                                    transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                                    readonly [Symbol.toStringTag]: string;
                                } | {
                                    readonly byteLength: number;
                                    slice: (begin?: number, end?: number) => SharedArrayBuffer;
                                    readonly growable: boolean;
                                    readonly maxByteLength: number;
                                    grow: (newByteLength?: number) => void;
                                    readonly [Symbol.species]: SharedArrayBuffer;
                                    readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                                };
                                readonly byteLength: number;
                                readonly byteOffset: number;
                                copyWithin: (target: number, start: number, end?: number) => Float64Array<ArrayBufferLike>;
                                every: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                fill: (value: number, start?: number, end?: number) => Float64Array<ArrayBufferLike>;
                                filter: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => any, thisArg?: any) => Float64Array<ArrayBuffer>;
                                find: (predicate: (value: number, index: number, obj: Float64Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                                findIndex: (predicate: (value: number, index: number, obj: Float64Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                                forEach: (callbackfn: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                                indexOf: (searchElement: number, fromIndex?: number) => number;
                                join: (separator?: string) => string;
                                lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                                readonly length: number;
                                map: (callbackfn: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => number, thisArg?: any) => Float64Array<ArrayBuffer>;
                                reduce: {
                                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number): number;
                                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number, initialValue: number): number;
                                    <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => U, initialValue: U): U;
                                };
                                reduceRight: {
                                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number): number;
                                    (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number, initialValue: number): number;
                                    <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => U, initialValue: U): U;
                                };
                                reverse: () => Float64Array<ArrayBufferLike>;
                                set: (array: ArrayLike<number>, offset?: number) => void;
                                slice: (start?: number, end?: number) => Float64Array<ArrayBuffer>;
                                some: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float64Array<ArrayBufferLike>;
                                subarray: (begin?: number, end?: number) => Float64Array<ArrayBufferLike>;
                                toLocaleString: {
                                    (): string;
                                    (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                                };
                                toString: () => string;
                                valueOf: () => Float64Array<ArrayBufferLike>;
                                entries: () => ArrayIterator<[number, number]>;
                                keys: () => ArrayIterator<number>;
                                values: () => ArrayIterator<number>;
                                includes: (searchElement: number, fromIndex?: number) => boolean;
                                at: (index: number) => number | undefined;
                                findLast: {
                                    <S extends number>(predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                                    (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                                };
                                findLastIndex: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                                toReversed: () => Float64Array<ArrayBuffer>;
                                toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float64Array<ArrayBuffer>;
                                with: (index: number, value: number) => Float64Array<ArrayBuffer>;
                                [Symbol.iterator]: () => ArrayIterator<number>;
                                readonly [Symbol.toStringTag]: "Float64Array";
                            };
                            width: number;
                            height: number;
                        }[] | {
                            readonly isCubeTexture: true;
                            image: any;
                            images: any;
                            mapping: import('three').CubeTextureMapping;
                            flipY: boolean;
                            readonly isTexture: true;
                            readonly id: number;
                            uuid: string;
                            name: string;
                            source: {
                                readonly isSource: true;
                                readonly id: number;
                                uuid: string;
                                data: any;
                                dataReady: boolean;
                                version: number;
                                getSize: (target: import('three').Vector3) => import('three').Vector3;
                                needsUpdate: boolean;
                                toJSON: (meta?: string | {}) => import('three').SourceJSON;
                            };
                            readonly width: number;
                            readonly height: number;
                            readonly depth: number;
                            mipmaps: HTMLCanvasElement[] | {
                                data: {
                                    [x: number]: number;
                                    readonly BYTES_PER_ELEMENT: number;
                                    readonly buffer: {
                                        readonly byteLength: number;
                                        slice: (begin?: number, end?: number) => ArrayBuffer;
                                        readonly maxByteLength: number;
                                        readonly resizable: boolean;
                                        resize: (newByteLength?: number) => void;
                                        readonly detached: boolean;
                                        transfer: (newByteLength?: number) => ArrayBuffer;
                                        transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                                        readonly [Symbol.toStringTag]: string;
                                    } | {
                                        readonly byteLength: number;
                                        slice: (begin?: number, end?: number) => SharedArrayBuffer;
                                        readonly growable: boolean;
                                        readonly maxByteLength: number;
                                        grow: (newByteLength?: number) => void;
                                        readonly [Symbol.species]: SharedArrayBuffer;
                                        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                                    };
                                    readonly byteLength: number;
                                    readonly byteOffset: number;
                                    copyWithin: (target: number, start: number, end?: number) => Int8Array<ArrayBufferLike>;
                                    every: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                    fill: (value: number, start?: number, end?: number) => Int8Array<ArrayBufferLike>;
                                    filter: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => any, thisArg?: any) => Int8Array<ArrayBuffer>;
                                    find: (predicate: (value: number, index: number, obj: Int8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                                    findIndex: (predicate: (value: number, index: number, obj: Int8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                                    forEach: (callbackfn: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                                    indexOf: (searchElement: number, fromIndex?: number) => number;
                                    join: (separator?: string) => string;
                                    lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                                    readonly length: number;
                                    map: (callbackfn: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => number, thisArg?: any) => Int8Array<ArrayBuffer>;
                                    reduce: {
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number): number;
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number, initialValue: number): number;
                                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => U, initialValue: U): U;
                                    };
                                    reduceRight: {
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number): number;
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number, initialValue: number): number;
                                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => U, initialValue: U): U;
                                    };
                                    reverse: () => Int8Array<ArrayBufferLike>;
                                    set: (array: ArrayLike<number>, offset?: number) => void;
                                    slice: (start?: number, end?: number) => Int8Array<ArrayBuffer>;
                                    some: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                    sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Int8Array<ArrayBufferLike>;
                                    subarray: (begin?: number, end?: number) => Int8Array<ArrayBufferLike>;
                                    toLocaleString: {
                                        (): string;
                                        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                                    };
                                    toString: () => string;
                                    valueOf: () => Int8Array<ArrayBufferLike>;
                                    entries: () => ArrayIterator<[number, number]>;
                                    keys: () => ArrayIterator<number>;
                                    values: () => ArrayIterator<number>;
                                    includes: (searchElement: number, fromIndex?: number) => boolean;
                                    at: (index: number) => number | undefined;
                                    findLast: {
                                        <S extends number>(predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                                        (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                                    };
                                    findLastIndex: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                                    toReversed: () => Int8Array<ArrayBuffer>;
                                    toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Int8Array<ArrayBuffer>;
                                    with: (index: number, value: number) => Int8Array<ArrayBuffer>;
                                    [Symbol.iterator]: () => ArrayIterator<number>;
                                    readonly [Symbol.toStringTag]: "Int8Array";
                                } | {
                                    [x: number]: number;
                                    readonly BYTES_PER_ELEMENT: number;
                                    readonly buffer: {
                                        readonly byteLength: number;
                                        slice: (begin?: number, end?: number) => ArrayBuffer;
                                        readonly maxByteLength: number;
                                        readonly resizable: boolean;
                                        resize: (newByteLength?: number) => void;
                                        readonly detached: boolean;
                                        transfer: (newByteLength?: number) => ArrayBuffer;
                                        transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                                        readonly [Symbol.toStringTag]: string;
                                    } | {
                                        readonly byteLength: number;
                                        slice: (begin?: number, end?: number) => SharedArrayBuffer;
                                        readonly growable: boolean;
                                        readonly maxByteLength: number;
                                        grow: (newByteLength?: number) => void;
                                        readonly [Symbol.species]: SharedArrayBuffer;
                                        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                                    };
                                    readonly byteLength: number;
                                    readonly byteOffset: number;
                                    copyWithin: (target: number, start: number, end?: number) => Uint8Array<ArrayBufferLike>;
                                    every: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                    fill: (value: number, start?: number, end?: number) => Uint8Array<ArrayBufferLike>;
                                    filter: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => any, thisArg?: any) => Uint8Array<ArrayBuffer>;
                                    find: (predicate: (value: number, index: number, obj: Uint8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                                    findIndex: (predicate: (value: number, index: number, obj: Uint8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                                    forEach: (callbackfn: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                                    indexOf: (searchElement: number, fromIndex?: number) => number;
                                    join: (separator?: string) => string;
                                    lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                                    readonly length: number;
                                    map: (callbackfn: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => number, thisArg?: any) => Uint8Array<ArrayBuffer>;
                                    reduce: {
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number): number;
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number, initialValue: number): number;
                                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => U, initialValue: U): U;
                                    };
                                    reduceRight: {
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number): number;
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number, initialValue: number): number;
                                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => U, initialValue: U): U;
                                    };
                                    reverse: () => Uint8Array<ArrayBufferLike>;
                                    set: (array: ArrayLike<number>, offset?: number) => void;
                                    slice: (start?: number, end?: number) => Uint8Array<ArrayBuffer>;
                                    some: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                    sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8Array<ArrayBufferLike>;
                                    subarray: (begin?: number, end?: number) => Uint8Array<ArrayBufferLike>;
                                    toLocaleString: {
                                        (): string;
                                        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                                    };
                                    toString: () => string;
                                    valueOf: () => Uint8Array<ArrayBufferLike>;
                                    entries: () => ArrayIterator<[number, number]>;
                                    keys: () => ArrayIterator<number>;
                                    values: () => ArrayIterator<number>;
                                    includes: (searchElement: number, fromIndex?: number) => boolean;
                                    at: (index: number) => number | undefined;
                                    findLast: {
                                        <S extends number>(predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                                        (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                                    };
                                    findLastIndex: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                                    toReversed: () => Uint8Array<ArrayBuffer>;
                                    toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8Array<ArrayBuffer>;
                                    with: (index: number, value: number) => Uint8Array<ArrayBuffer>;
                                    [Symbol.iterator]: () => ArrayIterator<number>;
                                    readonly [Symbol.toStringTag]: "Uint8Array";
                                } | {
                                    [x: number]: number;
                                    readonly BYTES_PER_ELEMENT: number;
                                    readonly buffer: {
                                        readonly byteLength: number;
                                        slice: (begin?: number, end?: number) => ArrayBuffer;
                                        readonly maxByteLength: number;
                                        readonly resizable: boolean;
                                        resize: (newByteLength?: number) => void;
                                        readonly detached: boolean;
                                        transfer: (newByteLength?: number) => ArrayBuffer;
                                        transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                                        readonly [Symbol.toStringTag]: string;
                                    } | {
                                        readonly byteLength: number;
                                        slice: (begin?: number, end?: number) => SharedArrayBuffer;
                                        readonly growable: boolean;
                                        readonly maxByteLength: number;
                                        grow: (newByteLength?: number) => void;
                                        readonly [Symbol.species]: SharedArrayBuffer;
                                        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                                    };
                                    readonly byteLength: number;
                                    readonly byteOffset: number;
                                    copyWithin: (target: number, start: number, end?: number) => Uint8ClampedArray<ArrayBufferLike>;
                                    every: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                    fill: (value: number, start?: number, end?: number) => Uint8ClampedArray<ArrayBufferLike>;
                                    filter: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => any, thisArg?: any) => Uint8ClampedArray<ArrayBuffer>;
                                    find: (predicate: (value: number, index: number, obj: Uint8ClampedArray<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                                    findIndex: (predicate: (value: number, index: number, obj: Uint8ClampedArray<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                                    forEach: (callbackfn: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => void, thisArg?: any) => void;
                                    indexOf: (searchElement: number, fromIndex?: number) => number;
                                    join: (separator?: string) => string;
                                    lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                                    readonly length: number;
                                    map: (callbackfn: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => number, thisArg?: any) => Uint8ClampedArray<ArrayBuffer>;
                                    reduce: {
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number): number;
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number, initialValue: number): number;
                                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => U, initialValue: U): U;
                                    };
                                    reduceRight: {
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number): number;
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number, initialValue: number): number;
                                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => U, initialValue: U): U;
                                    };
                                    reverse: () => Uint8ClampedArray<ArrayBufferLike>;
                                    set: (array: ArrayLike<number>, offset?: number) => void;
                                    slice: (start?: number, end?: number) => Uint8ClampedArray<ArrayBuffer>;
                                    some: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                    sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8ClampedArray<ArrayBufferLike>;
                                    subarray: (begin?: number, end?: number) => Uint8ClampedArray<ArrayBufferLike>;
                                    toLocaleString: {
                                        (): string;
                                        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                                    };
                                    toString: () => string;
                                    valueOf: () => Uint8ClampedArray<ArrayBufferLike>;
                                    entries: () => ArrayIterator<[number, number]>;
                                    keys: () => ArrayIterator<number>;
                                    values: () => ArrayIterator<number>;
                                    includes: (searchElement: number, fromIndex?: number) => boolean;
                                    at: (index: number) => number | undefined;
                                    findLast: {
                                        <S extends number>(predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                                        (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                                    };
                                    findLastIndex: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                                    toReversed: () => Uint8ClampedArray<ArrayBuffer>;
                                    toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8ClampedArray<ArrayBuffer>;
                                    with: (index: number, value: number) => Uint8ClampedArray<ArrayBuffer>;
                                    [Symbol.iterator]: () => ArrayIterator<number>;
                                    readonly [Symbol.toStringTag]: "Uint8ClampedArray";
                                } | {
                                    [x: number]: number;
                                    readonly BYTES_PER_ELEMENT: number;
                                    readonly buffer: {
                                        readonly byteLength: number;
                                        slice: (begin?: number, end?: number) => ArrayBuffer;
                                        readonly maxByteLength: number;
                                        readonly resizable: boolean;
                                        resize: (newByteLength?: number) => void;
                                        readonly detached: boolean;
                                        transfer: (newByteLength?: number) => ArrayBuffer;
                                        transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                                        readonly [Symbol.toStringTag]: string;
                                    } | {
                                        readonly byteLength: number;
                                        slice: (begin?: number, end?: number) => SharedArrayBuffer;
                                        readonly growable: boolean;
                                        readonly maxByteLength: number;
                                        grow: (newByteLength?: number) => void;
                                        readonly [Symbol.species]: SharedArrayBuffer;
                                        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                                    };
                                    readonly byteLength: number;
                                    readonly byteOffset: number;
                                    copyWithin: (target: number, start: number, end?: number) => Int16Array<ArrayBufferLike>;
                                    every: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                    fill: (value: number, start?: number, end?: number) => Int16Array<ArrayBufferLike>;
                                    filter: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => any, thisArg?: any) => Int16Array<ArrayBuffer>;
                                    find: (predicate: (value: number, index: number, obj: Int16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                                    findIndex: (predicate: (value: number, index: number, obj: Int16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                                    forEach: (callbackfn: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                                    indexOf: (searchElement: number, fromIndex?: number) => number;
                                    join: (separator?: string) => string;
                                    lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                                    readonly length: number;
                                    map: (callbackfn: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => number, thisArg?: any) => Int16Array<ArrayBuffer>;
                                    reduce: {
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number): number;
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number, initialValue: number): number;
                                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => U, initialValue: U): U;
                                    };
                                    reduceRight: {
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number): number;
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number, initialValue: number): number;
                                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => U, initialValue: U): U;
                                    };
                                    reverse: () => Int16Array<ArrayBufferLike>;
                                    set: (array: ArrayLike<number>, offset?: number) => void;
                                    slice: (start?: number, end?: number) => Int16Array<ArrayBuffer>;
                                    some: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                    sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Int16Array<ArrayBufferLike>;
                                    subarray: (begin?: number, end?: number) => Int16Array<ArrayBufferLike>;
                                    toLocaleString: {
                                        (): string;
                                        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                                    };
                                    toString: () => string;
                                    valueOf: () => Int16Array<ArrayBufferLike>;
                                    entries: () => ArrayIterator<[number, number]>;
                                    keys: () => ArrayIterator<number>;
                                    values: () => ArrayIterator<number>;
                                    includes: (searchElement: number, fromIndex?: number) => boolean;
                                    at: (index: number) => number | undefined;
                                    findLast: {
                                        <S extends number>(predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                                        (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                                    };
                                    findLastIndex: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                                    toReversed: () => Int16Array<ArrayBuffer>;
                                    toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Int16Array<ArrayBuffer>;
                                    with: (index: number, value: number) => Int16Array<ArrayBuffer>;
                                    [Symbol.iterator]: () => ArrayIterator<number>;
                                    readonly [Symbol.toStringTag]: "Int16Array";
                                } | {
                                    [x: number]: number;
                                    readonly BYTES_PER_ELEMENT: number;
                                    readonly buffer: {
                                        readonly byteLength: number;
                                        slice: (begin?: number, end?: number) => ArrayBuffer;
                                        readonly maxByteLength: number;
                                        readonly resizable: boolean;
                                        resize: (newByteLength?: number) => void;
                                        readonly detached: boolean;
                                        transfer: (newByteLength?: number) => ArrayBuffer;
                                        transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                                        readonly [Symbol.toStringTag]: string;
                                    } | {
                                        readonly byteLength: number;
                                        slice: (begin?: number, end?: number) => SharedArrayBuffer;
                                        readonly growable: boolean;
                                        readonly maxByteLength: number;
                                        grow: (newByteLength?: number) => void;
                                        readonly [Symbol.species]: SharedArrayBuffer;
                                        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                                    };
                                    readonly byteLength: number;
                                    readonly byteOffset: number;
                                    copyWithin: (target: number, start: number, end?: number) => Uint16Array<ArrayBufferLike>;
                                    every: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                    fill: (value: number, start?: number, end?: number) => Uint16Array<ArrayBufferLike>;
                                    filter: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => any, thisArg?: any) => Uint16Array<ArrayBuffer>;
                                    find: (predicate: (value: number, index: number, obj: Uint16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                                    findIndex: (predicate: (value: number, index: number, obj: Uint16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                                    forEach: (callbackfn: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                                    indexOf: (searchElement: number, fromIndex?: number) => number;
                                    join: (separator?: string) => string;
                                    lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                                    readonly length: number;
                                    map: (callbackfn: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => number, thisArg?: any) => Uint16Array<ArrayBuffer>;
                                    reduce: {
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number): number;
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number, initialValue: number): number;
                                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => U, initialValue: U): U;
                                    };
                                    reduceRight: {
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number): number;
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number, initialValue: number): number;
                                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => U, initialValue: U): U;
                                    };
                                    reverse: () => Uint16Array<ArrayBufferLike>;
                                    set: (array: ArrayLike<number>, offset?: number) => void;
                                    slice: (start?: number, end?: number) => Uint16Array<ArrayBuffer>;
                                    some: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                    sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint16Array<ArrayBufferLike>;
                                    subarray: (begin?: number, end?: number) => Uint16Array<ArrayBufferLike>;
                                    toLocaleString: {
                                        (): string;
                                        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                                    };
                                    toString: () => string;
                                    valueOf: () => Uint16Array<ArrayBufferLike>;
                                    entries: () => ArrayIterator<[number, number]>;
                                    keys: () => ArrayIterator<number>;
                                    values: () => ArrayIterator<number>;
                                    includes: (searchElement: number, fromIndex?: number) => boolean;
                                    at: (index: number) => number | undefined;
                                    findLast: {
                                        <S extends number>(predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                                        (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                                    };
                                    findLastIndex: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                                    toReversed: () => Uint16Array<ArrayBuffer>;
                                    toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint16Array<ArrayBuffer>;
                                    with: (index: number, value: number) => Uint16Array<ArrayBuffer>;
                                    [Symbol.iterator]: () => ArrayIterator<number>;
                                    readonly [Symbol.toStringTag]: "Uint16Array";
                                } | {
                                    [x: number]: number;
                                    readonly BYTES_PER_ELEMENT: number;
                                    readonly buffer: {
                                        readonly byteLength: number;
                                        slice: (begin?: number, end?: number) => ArrayBuffer;
                                        readonly maxByteLength: number;
                                        readonly resizable: boolean;
                                        resize: (newByteLength?: number) => void;
                                        readonly detached: boolean;
                                        transfer: (newByteLength?: number) => ArrayBuffer;
                                        transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                                        readonly [Symbol.toStringTag]: string;
                                    } | {
                                        readonly byteLength: number;
                                        slice: (begin?: number, end?: number) => SharedArrayBuffer;
                                        readonly growable: boolean;
                                        readonly maxByteLength: number;
                                        grow: (newByteLength?: number) => void;
                                        readonly [Symbol.species]: SharedArrayBuffer;
                                        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                                    };
                                    readonly byteLength: number;
                                    readonly byteOffset: number;
                                    copyWithin: (target: number, start: number, end?: number) => Int32Array<ArrayBufferLike>;
                                    every: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                    fill: (value: number, start?: number, end?: number) => Int32Array<ArrayBufferLike>;
                                    filter: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => any, thisArg?: any) => Int32Array<ArrayBuffer>;
                                    find: (predicate: (value: number, index: number, obj: Int32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                                    findIndex: (predicate: (value: number, index: number, obj: Int32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                                    forEach: (callbackfn: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                                    indexOf: (searchElement: number, fromIndex?: number) => number;
                                    join: (separator?: string) => string;
                                    lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                                    readonly length: number;
                                    map: (callbackfn: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => number, thisArg?: any) => Int32Array<ArrayBuffer>;
                                    reduce: {
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number): number;
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number, initialValue: number): number;
                                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => U, initialValue: U): U;
                                    };
                                    reduceRight: {
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number): number;
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number, initialValue: number): number;
                                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => U, initialValue: U): U;
                                    };
                                    reverse: () => Int32Array<ArrayBufferLike>;
                                    set: (array: ArrayLike<number>, offset?: number) => void;
                                    slice: (start?: number, end?: number) => Int32Array<ArrayBuffer>;
                                    some: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                    sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Int32Array<ArrayBufferLike>;
                                    subarray: (begin?: number, end?: number) => Int32Array<ArrayBufferLike>;
                                    toLocaleString: {
                                        (): string;
                                        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                                    };
                                    toString: () => string;
                                    valueOf: () => Int32Array<ArrayBufferLike>;
                                    entries: () => ArrayIterator<[number, number]>;
                                    keys: () => ArrayIterator<number>;
                                    values: () => ArrayIterator<number>;
                                    includes: (searchElement: number, fromIndex?: number) => boolean;
                                    at: (index: number) => number | undefined;
                                    findLast: {
                                        <S extends number>(predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                                        (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                                    };
                                    findLastIndex: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                                    toReversed: () => Int32Array<ArrayBuffer>;
                                    toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Int32Array<ArrayBuffer>;
                                    with: (index: number, value: number) => Int32Array<ArrayBuffer>;
                                    [Symbol.iterator]: () => ArrayIterator<number>;
                                    readonly [Symbol.toStringTag]: "Int32Array";
                                } | {
                                    [x: number]: number;
                                    readonly BYTES_PER_ELEMENT: number;
                                    readonly buffer: {
                                        readonly byteLength: number;
                                        slice: (begin?: number, end?: number) => ArrayBuffer;
                                        readonly maxByteLength: number;
                                        readonly resizable: boolean;
                                        resize: (newByteLength?: number) => void;
                                        readonly detached: boolean;
                                        transfer: (newByteLength?: number) => ArrayBuffer;
                                        transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                                        readonly [Symbol.toStringTag]: string;
                                    } | {
                                        readonly byteLength: number;
                                        slice: (begin?: number, end?: number) => SharedArrayBuffer;
                                        readonly growable: boolean;
                                        readonly maxByteLength: number;
                                        grow: (newByteLength?: number) => void;
                                        readonly [Symbol.species]: SharedArrayBuffer;
                                        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                                    };
                                    readonly byteLength: number;
                                    readonly byteOffset: number;
                                    copyWithin: (target: number, start: number, end?: number) => Uint32Array<ArrayBufferLike>;
                                    every: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                    fill: (value: number, start?: number, end?: number) => Uint32Array<ArrayBufferLike>;
                                    filter: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => any, thisArg?: any) => Uint32Array<ArrayBuffer>;
                                    find: (predicate: (value: number, index: number, obj: Uint32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                                    findIndex: (predicate: (value: number, index: number, obj: Uint32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                                    forEach: (callbackfn: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                                    indexOf: (searchElement: number, fromIndex?: number) => number;
                                    join: (separator?: string) => string;
                                    lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                                    readonly length: number;
                                    map: (callbackfn: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => number, thisArg?: any) => Uint32Array<ArrayBuffer>;
                                    reduce: {
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number): number;
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number, initialValue: number): number;
                                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => U, initialValue: U): U;
                                    };
                                    reduceRight: {
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number): number;
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number, initialValue: number): number;
                                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => U, initialValue: U): U;
                                    };
                                    reverse: () => Uint32Array<ArrayBufferLike>;
                                    set: (array: ArrayLike<number>, offset?: number) => void;
                                    slice: (start?: number, end?: number) => Uint32Array<ArrayBuffer>;
                                    some: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                    sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint32Array<ArrayBufferLike>;
                                    subarray: (begin?: number, end?: number) => Uint32Array<ArrayBufferLike>;
                                    toLocaleString: {
                                        (): string;
                                        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                                    };
                                    toString: () => string;
                                    valueOf: () => Uint32Array<ArrayBufferLike>;
                                    entries: () => ArrayIterator<[number, number]>;
                                    keys: () => ArrayIterator<number>;
                                    values: () => ArrayIterator<number>;
                                    includes: (searchElement: number, fromIndex?: number) => boolean;
                                    at: (index: number) => number | undefined;
                                    findLast: {
                                        <S extends number>(predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                                        (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                                    };
                                    findLastIndex: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                                    toReversed: () => Uint32Array<ArrayBuffer>;
                                    toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint32Array<ArrayBuffer>;
                                    with: (index: number, value: number) => Uint32Array<ArrayBuffer>;
                                    [Symbol.iterator]: () => ArrayIterator<number>;
                                    readonly [Symbol.toStringTag]: "Uint32Array";
                                } | {
                                    [x: number]: number;
                                    readonly BYTES_PER_ELEMENT: number;
                                    readonly buffer: {
                                        readonly byteLength: number;
                                        slice: (begin?: number, end?: number) => ArrayBuffer;
                                        readonly maxByteLength: number;
                                        readonly resizable: boolean;
                                        resize: (newByteLength?: number) => void;
                                        readonly detached: boolean;
                                        transfer: (newByteLength?: number) => ArrayBuffer;
                                        transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                                        readonly [Symbol.toStringTag]: string;
                                    } | {
                                        readonly byteLength: number;
                                        slice: (begin?: number, end?: number) => SharedArrayBuffer;
                                        readonly growable: boolean;
                                        readonly maxByteLength: number;
                                        grow: (newByteLength?: number) => void;
                                        readonly [Symbol.species]: SharedArrayBuffer;
                                        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                                    };
                                    readonly byteLength: number;
                                    readonly byteOffset: number;
                                    copyWithin: (target: number, start: number, end?: number) => Float32Array<ArrayBufferLike>;
                                    every: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                    fill: (value: number, start?: number, end?: number) => Float32Array<ArrayBufferLike>;
                                    filter: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => any, thisArg?: any) => Float32Array<ArrayBuffer>;
                                    find: (predicate: (value: number, index: number, obj: Float32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                                    findIndex: (predicate: (value: number, index: number, obj: Float32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                                    forEach: (callbackfn: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                                    indexOf: (searchElement: number, fromIndex?: number) => number;
                                    join: (separator?: string) => string;
                                    lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                                    readonly length: number;
                                    map: (callbackfn: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => number, thisArg?: any) => Float32Array<ArrayBuffer>;
                                    reduce: {
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number): number;
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number, initialValue: number): number;
                                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => U, initialValue: U): U;
                                    };
                                    reduceRight: {
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number): number;
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number, initialValue: number): number;
                                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => U, initialValue: U): U;
                                    };
                                    reverse: () => Float32Array<ArrayBufferLike>;
                                    set: (array: ArrayLike<number>, offset?: number) => void;
                                    slice: (start?: number, end?: number) => Float32Array<ArrayBuffer>;
                                    some: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                    sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array<ArrayBufferLike>;
                                    subarray: (begin?: number, end?: number) => Float32Array<ArrayBufferLike>;
                                    toLocaleString: {
                                        (): string;
                                        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                                    };
                                    toString: () => string;
                                    valueOf: () => Float32Array<ArrayBufferLike>;
                                    entries: () => ArrayIterator<[number, number]>;
                                    keys: () => ArrayIterator<number>;
                                    values: () => ArrayIterator<number>;
                                    includes: (searchElement: number, fromIndex?: number) => boolean;
                                    at: (index: number) => number | undefined;
                                    findLast: {
                                        <S extends number>(predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                                        (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                                    };
                                    findLastIndex: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                                    toReversed: () => Float32Array<ArrayBuffer>;
                                    toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array<ArrayBuffer>;
                                    with: (index: number, value: number) => Float32Array<ArrayBuffer>;
                                    [Symbol.iterator]: () => ArrayIterator<number>;
                                    readonly [Symbol.toStringTag]: "Float32Array";
                                } | {
                                    [x: number]: number;
                                    readonly BYTES_PER_ELEMENT: number;
                                    readonly buffer: {
                                        readonly byteLength: number;
                                        slice: (begin?: number, end?: number) => ArrayBuffer;
                                        readonly maxByteLength: number;
                                        readonly resizable: boolean;
                                        resize: (newByteLength?: number) => void;
                                        readonly detached: boolean;
                                        transfer: (newByteLength?: number) => ArrayBuffer;
                                        transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                                        readonly [Symbol.toStringTag]: string;
                                    } | {
                                        readonly byteLength: number;
                                        slice: (begin?: number, end?: number) => SharedArrayBuffer;
                                        readonly growable: boolean;
                                        readonly maxByteLength: number;
                                        grow: (newByteLength?: number) => void;
                                        readonly [Symbol.species]: SharedArrayBuffer;
                                        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                                    };
                                    readonly byteLength: number;
                                    readonly byteOffset: number;
                                    copyWithin: (target: number, start: number, end?: number) => Float64Array<ArrayBufferLike>;
                                    every: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                    fill: (value: number, start?: number, end?: number) => Float64Array<ArrayBufferLike>;
                                    filter: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => any, thisArg?: any) => Float64Array<ArrayBuffer>;
                                    find: (predicate: (value: number, index: number, obj: Float64Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
                                    findIndex: (predicate: (value: number, index: number, obj: Float64Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
                                    forEach: (callbackfn: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => void, thisArg?: any) => void;
                                    indexOf: (searchElement: number, fromIndex?: number) => number;
                                    join: (separator?: string) => string;
                                    lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                                    readonly length: number;
                                    map: (callbackfn: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => number, thisArg?: any) => Float64Array<ArrayBuffer>;
                                    reduce: {
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number): number;
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number, initialValue: number): number;
                                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => U, initialValue: U): U;
                                    };
                                    reduceRight: {
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number): number;
                                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number, initialValue: number): number;
                                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => U, initialValue: U): U;
                                    };
                                    reverse: () => Float64Array<ArrayBufferLike>;
                                    set: (array: ArrayLike<number>, offset?: number) => void;
                                    slice: (start?: number, end?: number) => Float64Array<ArrayBuffer>;
                                    some: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
                                    sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float64Array<ArrayBufferLike>;
                                    subarray: (begin?: number, end?: number) => Float64Array<ArrayBufferLike>;
                                    toLocaleString: {
                                        (): string;
                                        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                                    };
                                    toString: () => string;
                                    valueOf: () => Float64Array<ArrayBufferLike>;
                                    entries: () => ArrayIterator<[number, number]>;
                                    keys: () => ArrayIterator<number>;
                                    values: () => ArrayIterator<number>;
                                    includes: (searchElement: number, fromIndex?: number) => boolean;
                                    at: (index: number) => number | undefined;
                                    findLast: {
                                        <S extends number>(predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                                        (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
                                    };
                                    findLastIndex: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
                                    toReversed: () => Float64Array<ArrayBuffer>;
                                    toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float64Array<ArrayBuffer>;
                                    with: (index: number, value: number) => Float64Array<ArrayBuffer>;
                                    [Symbol.iterator]: () => ArrayIterator<number>;
                                    readonly [Symbol.toStringTag]: "Float64Array";
                                };
                                width: number;
                                height: number;
                            }[] | /*elided*/ any[];
                            channel: number;
                            wrapS: import('three').Wrapping;
                            wrapT: import('three').Wrapping;
                            magFilter: import('three').MagnificationTextureFilter;
                            minFilter: import('three').MinificationTextureFilter;
                            anisotropy: number;
                            format: import('three').AnyPixelFormat;
                            type: import('three').TextureDataType;
                            internalFormat: import('three').PixelFormatGPU | null;
                            matrix: {
                                readonly isMatrix3: true;
                                elements: [n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number];
                                set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import('three').Matrix3;
                                identity: () => import('three').Matrix3;
                                copy: (m: import('three').Matrix3) => import('three').Matrix3;
                                extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix3;
                                setFromMatrix4: (m: import('three').Matrix4) => import('three').Matrix3;
                                multiply: (m: import('three').Matrix3) => import('three').Matrix3;
                                premultiply: (m: import('three').Matrix3) => import('three').Matrix3;
                                multiplyMatrices: (a: import('three').Matrix3, b: import('three').Matrix3) => import('three').Matrix3;
                                multiplyScalar: (s: number) => import('three').Matrix3;
                                determinant: () => number;
                                invert: () => import('three').Matrix3;
                                transpose: () => import('three').Matrix3;
                                getNormalMatrix: (matrix4: import('three').Matrix4) => import('three').Matrix3;
                                transposeIntoArray: (r: number[]) => import('three').Matrix3;
                                setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import('three').Matrix3;
                                scale: (sx: number, sy: number) => import('three').Matrix3;
                                rotate: (theta: number) => import('three').Matrix3;
                                translate: (tx: number, ty: number) => import('three').Matrix3;
                                makeTranslation: {
                                    (v: import('three').Vector2): import('three').Matrix3;
                                    (x: number, y: number): import('three').Matrix3;
                                };
                                makeRotation: (theta: number) => import('three').Matrix3;
                                makeScale: (x: number, y: number) => import('three').Matrix3;
                                equals: (matrix: import('three').Matrix3) => boolean;
                                fromArray: (array: ArrayLike<number>, offset?: number) => import('three').Matrix3;
                                toArray: {
                                    (): import('three').Matrix3Tuple;
                                    <TArray extends ArrayLike<number>>(array: TArray, offset?: number): TArray;
                                };
                                clone: () => import('three').Matrix3;
                            };
                            matrixAutoUpdate: boolean;
                            offset: {
                                x: number;
                                y: number;
                                width: number;
                                height: number;
                                readonly isVector2: true;
                                set: (x: number, y: number) => import('three').Vector2;
                                setScalar: (scalar: number) => import('three').Vector2;
                                setX: (x: number) => import('three').Vector2;
                                setY: (y: number) => import('three').Vector2;
                                setComponent: (index: number, value: number) => import('three').Vector2;
                                getComponent: (index: number) => number;
                                clone: () => import('three').Vector2;
                                copy: (v: import('three').Vector2Like) => import('three').Vector2;
                                add: (v: import('three').Vector2Like) => import('three').Vector2;
                                addScalar: (s: number) => import('three').Vector2;
                                addVectors: (a: import('three').Vector2Like, b: import('three').Vector2Like) => import('three').Vector2;
                                addScaledVector: (v: import('three').Vector2Like, s: number) => import('three').Vector2;
                                sub: (v: import('three').Vector2Like) => import('three').Vector2;
                                subScalar: (s: number) => import('three').Vector2;
                                subVectors: (a: import('three').Vector2Like, b: import('three').Vector2Like) => import('three').Vector2;
                                multiply: (v: import('three').Vector2Like) => import('three').Vector2;
                                multiplyScalar: (scalar: number) => import('three').Vector2;
                                divide: (v: import('three').Vector2Like) => import('three').Vector2;
                                divideScalar: (s: number) => import('three').Vector2;
                                applyMatrix3: (m: import('three').Matrix3) => import('three').Vector2;
                                min: (v: import('three').Vector2Like) => import('three').Vector2;
                                max: (v: import('three').Vector2Like) => import('three').Vector2;
                                clamp: (min: import('three').Vector2Like, max: import('three').Vector2Like) => import('three').Vector2;
                                clampScalar: (min: number, max: number) => import('three').Vector2;
                                clampLength: (min: number, max: number) => import('three').Vector2;
                                floor: () => import('three').Vector2;
                                ceil: () => import('three').Vector2;
                                round: () => import('three').Vector2;
                                roundToZero: () => import('three').Vector2;
                                negate: () => import('three').Vector2;
                                dot: (v: import('three').Vector2Like) => number;
                                cross: (v: import('three').Vector2Like) => number;
                                lengthSq: () => number;
                                length: () => number;
                                manhattanLength: () => number;
                                normalize: () => import('three').Vector2;
                                angle: () => number;
                                angleTo: (v: import('three').Vector2) => number;
                                distanceTo: (v: import('three').Vector2Like) => number;
                                distanceToSquared: (v: import('three').Vector2Like) => number;
                                manhattanDistanceTo: (v: import('three').Vector2Like) => number;
                                setLength: (length: number) => import('three').Vector2;
                                lerp: (v: import('three').Vector2Like, alpha: number) => import('three').Vector2;
                                lerpVectors: (v1: import('three').Vector2Like, v2: import('three').Vector2Like, alpha: number) => import('three').Vector2;
                                equals: (v: import('three').Vector2Like) => boolean;
                                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector2;
                                toArray: {
                                    (array?: number[], offset?: number): number[];
                                    (array?: import('three').Vector2Tuple, offset?: 0): import('three').Vector2Tuple;
                                    (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                                };
                                fromBufferAttribute: (attribute: import('three').BufferAttribute, index: number) => import('three').Vector2;
                                rotateAround: (center: import('three').Vector2Like, angle: number) => import('three').Vector2;
                                random: () => import('three').Vector2;
                                [Symbol.iterator]: () => Iterator<number>;
                            };
                            repeat: {
                                x: number;
                                y: number;
                                width: number;
                                height: number;
                                readonly isVector2: true;
                                set: (x: number, y: number) => import('three').Vector2;
                                setScalar: (scalar: number) => import('three').Vector2;
                                setX: (x: number) => import('three').Vector2;
                                setY: (y: number) => import('three').Vector2;
                                setComponent: (index: number, value: number) => import('three').Vector2;
                                getComponent: (index: number) => number;
                                clone: () => import('three').Vector2;
                                copy: (v: import('three').Vector2Like) => import('three').Vector2;
                                add: (v: import('three').Vector2Like) => import('three').Vector2;
                                addScalar: (s: number) => import('three').Vector2;
                                addVectors: (a: import('three').Vector2Like, b: import('three').Vector2Like) => import('three').Vector2;
                                addScaledVector: (v: import('three').Vector2Like, s: number) => import('three').Vector2;
                                sub: (v: import('three').Vector2Like) => import('three').Vector2;
                                subScalar: (s: number) => import('three').Vector2;
                                subVectors: (a: import('three').Vector2Like, b: import('three').Vector2Like) => import('three').Vector2;
                                multiply: (v: import('three').Vector2Like) => import('three').Vector2;
                                multiplyScalar: (scalar: number) => import('three').Vector2;
                                divide: (v: import('three').Vector2Like) => import('three').Vector2;
                                divideScalar: (s: number) => import('three').Vector2;
                                applyMatrix3: (m: import('three').Matrix3) => import('three').Vector2;
                                min: (v: import('three').Vector2Like) => import('three').Vector2;
                                max: (v: import('three').Vector2Like) => import('three').Vector2;
                                clamp: (min: import('three').Vector2Like, max: import('three').Vector2Like) => import('three').Vector2;
                                clampScalar: (min: number, max: number) => import('three').Vector2;
                                clampLength: (min: number, max: number) => import('three').Vector2;
                                floor: () => import('three').Vector2;
                                ceil: () => import('three').Vector2;
                                round: () => import('three').Vector2;
                                roundToZero: () => import('three').Vector2;
                                negate: () => import('three').Vector2;
                                dot: (v: import('three').Vector2Like) => number;
                                cross: (v: import('three').Vector2Like) => number;
                                lengthSq: () => number;
                                length: () => number;
                                manhattanLength: () => number;
                                normalize: () => import('three').Vector2;
                                angle: () => number;
                                angleTo: (v: import('three').Vector2) => number;
                                distanceTo: (v: import('three').Vector2Like) => number;
                                distanceToSquared: (v: import('three').Vector2Like) => number;
                                manhattanDistanceTo: (v: import('three').Vector2Like) => number;
                                setLength: (length: number) => import('three').Vector2;
                                lerp: (v: import('three').Vector2Like, alpha: number) => import('three').Vector2;
                                lerpVectors: (v1: import('three').Vector2Like, v2: import('three').Vector2Like, alpha: number) => import('three').Vector2;
                                equals: (v: import('three').Vector2Like) => boolean;
                                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector2;
                                toArray: {
                                    (array?: number[], offset?: number): number[];
                                    (array?: import('three').Vector2Tuple, offset?: 0): import('three').Vector2Tuple;
                                    (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                                };
                                fromBufferAttribute: (attribute: import('three').BufferAttribute, index: number) => import('three').Vector2;
                                rotateAround: (center: import('three').Vector2Like, angle: number) => import('three').Vector2;
                                random: () => import('three').Vector2;
                                [Symbol.iterator]: () => Iterator<number>;
                            };
                            center: {
                                x: number;
                                y: number;
                                width: number;
                                height: number;
                                readonly isVector2: true;
                                set: (x: number, y: number) => import('three').Vector2;
                                setScalar: (scalar: number) => import('three').Vector2;
                                setX: (x: number) => import('three').Vector2;
                                setY: (y: number) => import('three').Vector2;
                                setComponent: (index: number, value: number) => import('three').Vector2;
                                getComponent: (index: number) => number;
                                clone: () => import('three').Vector2;
                                copy: (v: import('three').Vector2Like) => import('three').Vector2;
                                add: (v: import('three').Vector2Like) => import('three').Vector2;
                                addScalar: (s: number) => import('three').Vector2;
                                addVectors: (a: import('three').Vector2Like, b: import('three').Vector2Like) => import('three').Vector2;
                                addScaledVector: (v: import('three').Vector2Like, s: number) => import('three').Vector2;
                                sub: (v: import('three').Vector2Like) => import('three').Vector2;
                                subScalar: (s: number) => import('three').Vector2;
                                subVectors: (a: import('three').Vector2Like, b: import('three').Vector2Like) => import('three').Vector2;
                                multiply: (v: import('three').Vector2Like) => import('three').Vector2;
                                multiplyScalar: (scalar: number) => import('three').Vector2;
                                divide: (v: import('three').Vector2Like) => import('three').Vector2;
                                divideScalar: (s: number) => import('three').Vector2;
                                applyMatrix3: (m: import('three').Matrix3) => import('three').Vector2;
                                min: (v: import('three').Vector2Like) => import('three').Vector2;
                                max: (v: import('three').Vector2Like) => import('three').Vector2;
                                clamp: (min: import('three').Vector2Like, max: import('three').Vector2Like) => import('three').Vector2;
                                clampScalar: (min: number, max: number) => import('three').Vector2;
                                clampLength: (min: number, max: number) => import('three').Vector2;
                                floor: () => import('three').Vector2;
                                ceil: () => import('three').Vector2;
                                round: () => import('three').Vector2;
                                roundToZero: () => import('three').Vector2;
                                negate: () => import('three').Vector2;
                                dot: (v: import('three').Vector2Like) => number;
                                cross: (v: import('three').Vector2Like) => number;
                                lengthSq: () => number;
                                length: () => number;
                                manhattanLength: () => number;
                                normalize: () => import('three').Vector2;
                                angle: () => number;
                                angleTo: (v: import('three').Vector2) => number;
                                distanceTo: (v: import('three').Vector2Like) => number;
                                distanceToSquared: (v: import('three').Vector2Like) => number;
                                manhattanDistanceTo: (v: import('three').Vector2Like) => number;
                                setLength: (length: number) => import('three').Vector2;
                                lerp: (v: import('three').Vector2Like, alpha: number) => import('three').Vector2;
                                lerpVectors: (v1: import('three').Vector2Like, v2: import('three').Vector2Like, alpha: number) => import('three').Vector2;
                                equals: (v: import('three').Vector2Like) => boolean;
                                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector2;
                                toArray: {
                                    (array?: number[], offset?: number): number[];
                                    (array?: import('three').Vector2Tuple, offset?: 0): import('three').Vector2Tuple;
                                    (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                                };
                                fromBufferAttribute: (attribute: import('three').BufferAttribute, index: number) => import('three').Vector2;
                                rotateAround: (center: import('three').Vector2Like, angle: number) => import('three').Vector2;
                                random: () => import('three').Vector2;
                                [Symbol.iterator]: () => Iterator<number>;
                            };
                            rotation: number;
                            generateMipmaps: boolean;
                            premultiplyAlpha: boolean;
                            unpackAlignment: number;
                            colorSpace: string;
                            isRenderTargetTexture: boolean;
                            isArrayTexture: boolean;
                            userData: Record<string, any>;
                            updateRanges: {
                                start: number;
                                count: number;
                            }[];
                            version: number;
                            pmremVersion: number;
                            needsUpdate: boolean;
                            needsPMREMUpdate: boolean;
                            renderTarget: /*elided*/ any | null;
                            onUpdate: ((texture: Texture) => void) | null;
                            transformUv: (uv: import('three').Vector2) => import('three').Vector2;
                            updateMatrix: () => void;
                            addUpdateRange: (start: number, count: number) => void;
                            clearUpdateRanges: () => void;
                            clone: () => import('three').CubeTexture;
                            copy: (source: Texture) => import('three').CubeTexture;
                            setValues: (values: import('three').TextureParameters) => void;
                            toJSON: (meta?: string | {}) => import('three').TextureJSON;
                            dispose: () => void;
                            addEventListener: <T extends "dispose">(type: T, listener: import('three').EventListener<{
                                dispose: {};
                            }[T], T, import('three').CubeTexture>) => void;
                            hasEventListener: <T extends "dispose">(type: T, listener: import('three').EventListener<{
                                dispose: {};
                            }[T], T, import('three').CubeTexture>) => boolean;
                            removeEventListener: <T extends "dispose">(type: T, listener: import('three').EventListener<{
                                dispose: {};
                            }[T], T, import('three').CubeTexture>) => void;
                            dispatchEvent: <T extends "dispose">(event: import('three').BaseEvent<T> & {
                                dispose: {};
                            }[T]) => void;
                        }[];
                        mapping: import('three').AnyMapping;
                        channel: number;
                        wrapS: import('three').Wrapping;
                        wrapT: import('three').Wrapping;
                        anisotropy: number;
                        internalFormat: import('three').PixelFormatGPU | null;
                        matrix: {
                            readonly isMatrix3: true;
                            elements: [n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number];
                            set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import('three').Matrix3;
                            identity: () => import('three').Matrix3;
                            copy: (m: import('three').Matrix3) => import('three').Matrix3;
                            extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix3;
                            setFromMatrix4: (m: import('three').Matrix4) => import('three').Matrix3;
                            multiply: (m: import('three').Matrix3) => import('three').Matrix3;
                            premultiply: (m: import('three').Matrix3) => import('three').Matrix3;
                            multiplyMatrices: (a: import('three').Matrix3, b: import('three').Matrix3) => import('three').Matrix3;
                            multiplyScalar: (s: number) => import('three').Matrix3;
                            determinant: () => number;
                            invert: () => import('three').Matrix3;
                            transpose: () => import('three').Matrix3;
                            getNormalMatrix: (matrix4: import('three').Matrix4) => import('three').Matrix3;
                            transposeIntoArray: (r: number[]) => import('three').Matrix3;
                            setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import('three').Matrix3;
                            scale: (sx: number, sy: number) => import('three').Matrix3;
                            rotate: (theta: number) => import('three').Matrix3;
                            translate: (tx: number, ty: number) => import('three').Matrix3;
                            makeTranslation: {
                                (v: import('three').Vector2): import('three').Matrix3;
                                (x: number, y: number): import('three').Matrix3;
                            };
                            makeRotation: (theta: number) => import('three').Matrix3;
                            makeScale: (x: number, y: number) => import('three').Matrix3;
                            equals: (matrix: import('three').Matrix3) => boolean;
                            fromArray: (array: ArrayLike<number>, offset?: number) => import('three').Matrix3;
                            toArray: {
                                (): import('three').Matrix3Tuple;
                                <TArray extends ArrayLike<number>>(array: TArray, offset?: number): TArray;
                            };
                            clone: () => import('three').Matrix3;
                        };
                        matrixAutoUpdate: boolean;
                        offset: {
                            x: number;
                            y: number;
                            width: number;
                            height: number;
                            readonly isVector2: true;
                            set: (x: number, y: number) => import('three').Vector2;
                            setScalar: (scalar: number) => import('three').Vector2;
                            setX: (x: number) => import('three').Vector2;
                            setY: (y: number) => import('three').Vector2;
                            setComponent: (index: number, value: number) => import('three').Vector2;
                            getComponent: (index: number) => number;
                            clone: () => import('three').Vector2;
                            copy: (v: import('three').Vector2Like) => import('three').Vector2;
                            add: (v: import('three').Vector2Like) => import('three').Vector2;
                            addScalar: (s: number) => import('three').Vector2;
                            addVectors: (a: import('three').Vector2Like, b: import('three').Vector2Like) => import('three').Vector2;
                            addScaledVector: (v: import('three').Vector2Like, s: number) => import('three').Vector2;
                            sub: (v: import('three').Vector2Like) => import('three').Vector2;
                            subScalar: (s: number) => import('three').Vector2;
                            subVectors: (a: import('three').Vector2Like, b: import('three').Vector2Like) => import('three').Vector2;
                            multiply: (v: import('three').Vector2Like) => import('three').Vector2;
                            multiplyScalar: (scalar: number) => import('three').Vector2;
                            divide: (v: import('three').Vector2Like) => import('three').Vector2;
                            divideScalar: (s: number) => import('three').Vector2;
                            applyMatrix3: (m: import('three').Matrix3) => import('three').Vector2;
                            min: (v: import('three').Vector2Like) => import('three').Vector2;
                            max: (v: import('three').Vector2Like) => import('three').Vector2;
                            clamp: (min: import('three').Vector2Like, max: import('three').Vector2Like) => import('three').Vector2;
                            clampScalar: (min: number, max: number) => import('three').Vector2;
                            clampLength: (min: number, max: number) => import('three').Vector2;
                            floor: () => import('three').Vector2;
                            ceil: () => import('three').Vector2;
                            round: () => import('three').Vector2;
                            roundToZero: () => import('three').Vector2;
                            negate: () => import('three').Vector2;
                            dot: (v: import('three').Vector2Like) => number;
                            cross: (v: import('three').Vector2Like) => number;
                            lengthSq: () => number;
                            length: () => number;
                            manhattanLength: () => number;
                            normalize: () => import('three').Vector2;
                            angle: () => number;
                            angleTo: (v: import('three').Vector2) => number;
                            distanceTo: (v: import('three').Vector2Like) => number;
                            distanceToSquared: (v: import('three').Vector2Like) => number;
                            manhattanDistanceTo: (v: import('three').Vector2Like) => number;
                            setLength: (length: number) => import('three').Vector2;
                            lerp: (v: import('three').Vector2Like, alpha: number) => import('three').Vector2;
                            lerpVectors: (v1: import('three').Vector2Like, v2: import('three').Vector2Like, alpha: number) => import('three').Vector2;
                            equals: (v: import('three').Vector2Like) => boolean;
                            fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector2;
                            toArray: {
                                (array?: number[], offset?: number): number[];
                                (array?: import('three').Vector2Tuple, offset?: 0): import('three').Vector2Tuple;
                                (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                            };
                            fromBufferAttribute: (attribute: import('three').BufferAttribute, index: number) => import('three').Vector2;
                            rotateAround: (center: import('three').Vector2Like, angle: number) => import('three').Vector2;
                            random: () => import('three').Vector2;
                            [Symbol.iterator]: () => Iterator<number>;
                        };
                        repeat: {
                            x: number;
                            y: number;
                            width: number;
                            height: number;
                            readonly isVector2: true;
                            set: (x: number, y: number) => import('three').Vector2;
                            setScalar: (scalar: number) => import('three').Vector2;
                            setX: (x: number) => import('three').Vector2;
                            setY: (y: number) => import('three').Vector2;
                            setComponent: (index: number, value: number) => import('three').Vector2;
                            getComponent: (index: number) => number;
                            clone: () => import('three').Vector2;
                            copy: (v: import('three').Vector2Like) => import('three').Vector2;
                            add: (v: import('three').Vector2Like) => import('three').Vector2;
                            addScalar: (s: number) => import('three').Vector2;
                            addVectors: (a: import('three').Vector2Like, b: import('three').Vector2Like) => import('three').Vector2;
                            addScaledVector: (v: import('three').Vector2Like, s: number) => import('three').Vector2;
                            sub: (v: import('three').Vector2Like) => import('three').Vector2;
                            subScalar: (s: number) => import('three').Vector2;
                            subVectors: (a: import('three').Vector2Like, b: import('three').Vector2Like) => import('three').Vector2;
                            multiply: (v: import('three').Vector2Like) => import('three').Vector2;
                            multiplyScalar: (scalar: number) => import('three').Vector2;
                            divide: (v: import('three').Vector2Like) => import('three').Vector2;
                            divideScalar: (s: number) => import('three').Vector2;
                            applyMatrix3: (m: import('three').Matrix3) => import('three').Vector2;
                            min: (v: import('three').Vector2Like) => import('three').Vector2;
                            max: (v: import('three').Vector2Like) => import('three').Vector2;
                            clamp: (min: import('three').Vector2Like, max: import('three').Vector2Like) => import('three').Vector2;
                            clampScalar: (min: number, max: number) => import('three').Vector2;
                            clampLength: (min: number, max: number) => import('three').Vector2;
                            floor: () => import('three').Vector2;
                            ceil: () => import('three').Vector2;
                            round: () => import('three').Vector2;
                            roundToZero: () => import('three').Vector2;
                            negate: () => import('three').Vector2;
                            dot: (v: import('three').Vector2Like) => number;
                            cross: (v: import('three').Vector2Like) => number;
                            lengthSq: () => number;
                            length: () => number;
                            manhattanLength: () => number;
                            normalize: () => import('three').Vector2;
                            angle: () => number;
                            angleTo: (v: import('three').Vector2) => number;
                            distanceTo: (v: import('three').Vector2Like) => number;
                            distanceToSquared: (v: import('three').Vector2Like) => number;
                            manhattanDistanceTo: (v: import('three').Vector2Like) => number;
                            setLength: (length: number) => import('three').Vector2;
                            lerp: (v: import('three').Vector2Like, alpha: number) => import('three').Vector2;
                            lerpVectors: (v1: import('three').Vector2Like, v2: import('three').Vector2Like, alpha: number) => import('three').Vector2;
                            equals: (v: import('three').Vector2Like) => boolean;
                            fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector2;
                            toArray: {
                                (array?: number[], offset?: number): number[];
                                (array?: import('three').Vector2Tuple, offset?: 0): import('three').Vector2Tuple;
                                (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                            };
                            fromBufferAttribute: (attribute: import('three').BufferAttribute, index: number) => import('three').Vector2;
                            rotateAround: (center: import('three').Vector2Like, angle: number) => import('three').Vector2;
                            random: () => import('three').Vector2;
                            [Symbol.iterator]: () => Iterator<number>;
                        };
                        center: {
                            x: number;
                            y: number;
                            width: number;
                            height: number;
                            readonly isVector2: true;
                            set: (x: number, y: number) => import('three').Vector2;
                            setScalar: (scalar: number) => import('three').Vector2;
                            setX: (x: number) => import('three').Vector2;
                            setY: (y: number) => import('three').Vector2;
                            setComponent: (index: number, value: number) => import('three').Vector2;
                            getComponent: (index: number) => number;
                            clone: () => import('three').Vector2;
                            copy: (v: import('three').Vector2Like) => import('three').Vector2;
                            add: (v: import('three').Vector2Like) => import('three').Vector2;
                            addScalar: (s: number) => import('three').Vector2;
                            addVectors: (a: import('three').Vector2Like, b: import('three').Vector2Like) => import('three').Vector2;
                            addScaledVector: (v: import('three').Vector2Like, s: number) => import('three').Vector2;
                            sub: (v: import('three').Vector2Like) => import('three').Vector2;
                            subScalar: (s: number) => import('three').Vector2;
                            subVectors: (a: import('three').Vector2Like, b: import('three').Vector2Like) => import('three').Vector2;
                            multiply: (v: import('three').Vector2Like) => import('three').Vector2;
                            multiplyScalar: (scalar: number) => import('three').Vector2;
                            divide: (v: import('three').Vector2Like) => import('three').Vector2;
                            divideScalar: (s: number) => import('three').Vector2;
                            applyMatrix3: (m: import('three').Matrix3) => import('three').Vector2;
                            min: (v: import('three').Vector2Like) => import('three').Vector2;
                            max: (v: import('three').Vector2Like) => import('three').Vector2;
                            clamp: (min: import('three').Vector2Like, max: import('three').Vector2Like) => import('three').Vector2;
                            clampScalar: (min: number, max: number) => import('three').Vector2;
                            clampLength: (min: number, max: number) => import('three').Vector2;
                            floor: () => import('three').Vector2;
                            ceil: () => import('three').Vector2;
                            round: () => import('three').Vector2;
                            roundToZero: () => import('three').Vector2;
                            negate: () => import('three').Vector2;
                            dot: (v: import('three').Vector2Like) => number;
                            cross: (v: import('three').Vector2Like) => number;
                            lengthSq: () => number;
                            length: () => number;
                            manhattanLength: () => number;
                            normalize: () => import('three').Vector2;
                            angle: () => number;
                            angleTo: (v: import('three').Vector2) => number;
                            distanceTo: (v: import('three').Vector2Like) => number;
                            distanceToSquared: (v: import('three').Vector2Like) => number;
                            manhattanDistanceTo: (v: import('three').Vector2Like) => number;
                            setLength: (length: number) => import('three').Vector2;
                            lerp: (v: import('three').Vector2Like, alpha: number) => import('three').Vector2;
                            lerpVectors: (v1: import('three').Vector2Like, v2: import('three').Vector2Like, alpha: number) => import('three').Vector2;
                            equals: (v: import('three').Vector2Like) => boolean;
                            fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector2;
                            toArray: {
                                (array?: number[], offset?: number): number[];
                                (array?: import('three').Vector2Tuple, offset?: 0): import('three').Vector2Tuple;
                                (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                            };
                            fromBufferAttribute: (attribute: import('three').BufferAttribute, index: number) => import('three').Vector2;
                            rotateAround: (center: import('three').Vector2Like, angle: number) => import('three').Vector2;
                            random: () => import('three').Vector2;
                            [Symbol.iterator]: () => Iterator<number>;
                        };
                        rotation: number;
                        premultiplyAlpha: boolean;
                        unpackAlignment: number;
                        colorSpace: string;
                        isRenderTargetTexture: boolean;
                        isArrayTexture: boolean;
                        userData: Record<string, any>;
                        updateRanges: {
                            start: number;
                            count: number;
                        }[];
                        version: number;
                        pmremVersion: number;
                        needsUpdate: boolean;
                        needsPMREMUpdate: boolean;
                        renderTarget: /*elided*/ any | null;
                        onUpdate: ((texture: Texture) => void) | null;
                        transformUv: (uv: import('three').Vector2) => import('three').Vector2;
                        updateMatrix: () => void;
                        addUpdateRange: (start: number, count: number) => void;
                        clearUpdateRanges: () => void;
                        clone: () => import('three').DepthTexture;
                        copy: (source: Texture) => import('three').DepthTexture;
                        setValues: (values: import('three').TextureParameters) => void;
                        toJSON: (meta?: string | {}) => import('three').TextureJSON;
                        dispose: () => void;
                        addEventListener: <T extends "dispose">(type: T, listener: import('three').EventListener<{
                            dispose: {};
                        }[T], T, import('three').DepthTexture>) => void;
                        hasEventListener: <T extends "dispose">(type: T, listener: import('three').EventListener<{
                            dispose: {};
                        }[T], T, import('three').DepthTexture>) => boolean;
                        removeEventListener: <T extends "dispose">(type: T, listener: import('three').EventListener<{
                            dispose: {};
                        }[T], T, import('three').DepthTexture>) => void;
                        dispatchEvent: <T extends "dispose">(event: import('three').BaseEvent<T> & {
                            dispose: {};
                        }[T]) => void;
                    } | null;
                    setSize: (width: number, height: number, depth?: number) => void;
                    clone: () => import('three').RenderTarget<Texture>;
                    copy: (source: import('three').RenderTarget) => import('three').RenderTarget<Texture>;
                    dispose: () => void;
                    addEventListener: <T extends "dispose">(type: T, listener: import('three').EventListener<{
                        dispose: {};
                    }[T], T, import('three').RenderTarget<Texture>>) => void;
                    hasEventListener: <T extends "dispose">(type: T, listener: import('three').EventListener<{
                        dispose: {};
                    }[T], T, import('three').RenderTarget<Texture>>) => boolean;
                    removeEventListener: <T extends "dispose">(type: T, listener: import('three').EventListener<{
                        dispose: {};
                    }[T], T, import('three').RenderTarget<Texture>>) => void;
                    dispatchEvent: <T extends "dispose">(event: import('three').BaseEvent<T> & {
                        dispose: {};
                    }[T]) => void;
                } | null;
                onUpdate: ((texture: Texture) => void) | null;
                transformUv: (uv: import('three').Vector2) => import('three').Vector2;
                updateMatrix: () => void;
                addUpdateRange: (start: number, count: number) => void;
                clearUpdateRanges: () => void;
                clone: () => Texture;
                copy: (source: Texture) => Texture;
                setValues: (values: import('three').TextureParameters) => void;
                toJSON: (meta?: string | {}) => import('three').TextureJSON;
                dispose: () => void;
                addEventListener: <T extends "dispose">(type: T, listener: import('three').EventListener<{
                    dispose: {};
                }[T], T, Texture>) => void;
                hasEventListener: <T extends "dispose">(type: T, listener: import('three').EventListener<{
                    dispose: {};
                }[T], T, Texture>) => boolean;
                removeEventListener: <T extends "dispose">(type: T, listener: import('three').EventListener<{
                    dispose: {};
                }[T], T, Texture>) => void;
                dispatchEvent: <T extends "dispose">(event: import('three').BaseEvent<T> & {
                    dispose: {};
                }[T]) => void;
            };
            isLoading: boolean;
            error: unknown;
        }): any;
    };
    refs: {};
    rootEl: any;
};
type __VLS_TemplateResult = ReturnType<typeof __VLS_template>;
declare const __VLS_component: import('vue').DefineComponent<__VLS_Props, {}, {}, {}, {}, import('vue').ComponentOptionsMixin, import('vue').ComponentOptionsMixin, {
    error: (error: unknown) => any;
    loaded: (result: Texture) => any;
}, string, import('vue').PublicProps, Readonly<__VLS_Props> & Readonly<{
    onError?: ((error: unknown) => any) | undefined;
    onLoaded?: ((result: Texture) => any) | undefined;
}>, {}, {}, {}, {}, string, import('vue').ComponentProvideOptions, false, {}, any>;
declare const _default: __VLS_WithTemplateSlots<typeof __VLS_component, __VLS_TemplateResult["slots"]>;
export default _default;
type __VLS_WithTemplateSlots<T, S> = T & {
    new (): {
        $slots: S;
    };
};
