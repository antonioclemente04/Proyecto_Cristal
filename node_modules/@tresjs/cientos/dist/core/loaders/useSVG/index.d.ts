import { ComputedRef, MaybeRef, Ref } from 'vue';
import { BufferGeometry, MeshBasicMaterialParameters } from 'three';
import { SVGResult } from 'three-stdlib';
export interface UseSVGOptions {
    /**
     * Whether to skip rendering strokes
     * @type {boolean}
     * @default false
     */
    skipStrokes?: boolean;
    /**
     * Whether to skip rendering fills
     * @type {boolean}
     * @default false
     */
    skipFills?: boolean;
    /**
     * Fill material properties
     * @type {MeshBasicMaterialParameters}
     */
    fillMaterial?: MeshBasicMaterialParameters;
    /**
     * Stroke material properties
     * @type {MeshBasicMaterialParameters}
     */
    strokeMaterial?: MeshBasicMaterialParameters;
    /**
     * Depth type - how should the resulting meshes be rendered?
     * 'renderOrder' disables depthWrite and sets renderOrder of each layer
     * 'flat' disables depthWrite on materials
     * 'offsetZ' enables depthWrite and inserts small distance between layers
     * number is treated same as 'offsetZ' using the number as distance
     * @type {'renderOrder' | 'flat' | 'offsetZ' | number}
     * @default 'renderOrder'
     */
    depth?: 'renderOrder' | 'flat' | 'offsetZ' | number;
}
export interface SVGLayer {
    geometry: BufferGeometry;
    material: MeshBasicMaterialParameters;
    isStroke: boolean;
}
/**
 * Vue composable for loading SVG files in TresJS
 *
 * @remarks
 * This composable uses Three.js SVGLoader under the hood to load and process SVG files
 * into geometries and materials that can be rendered in a 3D scene.
 *
 * @example
 * ```ts
 * const { state: svg, layers } = useSVG('/path/to/file.svg', { skipStrokes: false })
 * ```
 *
 * @param {MaybeRef<string>} path - Path to the SVG file or SVG data string
 * @param {UseSVGOptions} options - Options for processing the SVG
 * @returns Object containing the SVG state, loading state, processed layers and disposal function
 */
export declare function useSVG(path: MaybeRef<string>, options?: UseSVGOptions): {
    state: Ref<SVGResult | null>;
    isLoading: Ref<boolean>;
    execute: (delay?: number, ...args: any[]) => Promise<SVGResult>;
    layers: ComputedRef<SVGLayer[]>;
    dispose: () => void;
};
