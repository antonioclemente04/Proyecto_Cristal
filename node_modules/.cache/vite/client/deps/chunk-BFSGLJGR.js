import {
  ACESFilmicToneMapping,
  ArrowHelper,
  BackSide,
  BufferAttribute,
  BufferGeometry,
  Clock,
  Color,
  DirectionalLightHelper,
  DoubleSide,
  Float32BufferAttribute,
  HemisphereLightHelper,
  Layers,
  Line,
  Line3,
  LineBasicMaterial,
  Material,
  MathUtils,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  Object3D,
  PCFSoftShadowMap,
  PerspectiveCamera,
  Plane,
  PointLightHelper,
  Quaternion,
  Ray,
  Raycaster,
  Scene,
  Sphere,
  SphereGeometry,
  SpotLightHelper,
  Triangle,
  Vector2,
  Vector3,
  WebGLRenderer,
  three_module_exports
} from "./chunk-CAVBG7WH.js";

// node_modules/@tresjs/core/dist/tres.js
import { reactive as Io, toValue as I, watch as At, onUnmounted as ie, defineComponent as ot, renderSlot as Do, unref as ke, ref as Ae, computed as J, watchEffect as $, readonly as zt, shallowRef as it, isRef as me, useSlots as ko, getCurrentInstance as $t, onMounted as Kt, createElementBlock as xo, openBlock as Ro, normalizeStyle as Lo, normalizeClass as Fo, createRenderer as Mo, h as Wt, provide as qe, Fragment as No } from "vue";

// node_modules/@vueuse/shared/index.mjs
import { shallowRef, watchEffect, readonly, watch, customRef, getCurrentScope, onScopeDispose, effectScope, getCurrentInstance, hasInjectionContext, inject, provide, ref, isRef, unref, toValue as toValue$1, computed, reactive, toRefs as toRefs$1, toRef as toRef$1, shallowReadonly, onBeforeMount, nextTick, onBeforeUnmount, onMounted, onUnmounted, isReactive } from "vue";
function tryOnScopeDispose(fn2) {
  if (getCurrentScope()) {
    onScopeDispose(fn2);
    return true;
  }
  return false;
}
function createEventHook() {
  const fns = /* @__PURE__ */ new Set();
  const off = (fn2) => {
    fns.delete(fn2);
  };
  const clear = () => {
    fns.clear();
  };
  const on2 = (fn2) => {
    fns.add(fn2);
    const offFn = () => off(fn2);
    tryOnScopeDispose(offFn);
    return {
      off: offFn
    };
  };
  const trigger = (...args) => {
    return Promise.all(Array.from(fns).map((fn2) => fn2(...args)));
  };
  return {
    on: on2,
    off,
    trigger,
    clear
  };
}
var localProvidedStateMap = /* @__PURE__ */ new WeakMap();
var injectLocal = (...args) => {
  var _a2;
  const key = args[0];
  const instance = (_a2 = getCurrentInstance()) == null ? void 0 : _a2.proxy;
  if (instance == null && !hasInjectionContext())
    throw new Error("injectLocal must be called in setup");
  if (instance && localProvidedStateMap.has(instance) && key in localProvidedStateMap.get(instance))
    return localProvidedStateMap.get(instance)[key];
  return inject(...args);
};
function provideLocal(key, value) {
  var _a2;
  const instance = (_a2 = getCurrentInstance()) == null ? void 0 : _a2.proxy;
  if (instance == null)
    throw new Error("provideLocal must be called in setup");
  if (!localProvidedStateMap.has(instance))
    localProvidedStateMap.set(instance, /* @__PURE__ */ Object.create(null));
  const localProvidedState = localProvidedStateMap.get(instance);
  localProvidedState[key] = value;
  return provide(key, value);
}
function createInjectionState(composable, options) {
  const key = (options == null ? void 0 : options.injectionKey) || Symbol(composable.name || "InjectionState");
  const defaultValue = options == null ? void 0 : options.defaultValue;
  const useProvidingState = (...args) => {
    const state = composable(...args);
    provideLocal(key, state);
    return state;
  };
  const useInjectedState = () => injectLocal(key, defaultValue);
  return [useProvidingState, useInjectedState];
}
var isClient = typeof window !== "undefined" && typeof document !== "undefined";
var isWorker = typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
var toString = Object.prototype.toString;
var isObject = (val) => toString.call(val) === "[object Object]";
var noop = () => {
};
var isIOS = getIsIOS();
function getIsIOS() {
  var _a2, _b;
  return isClient && ((_a2 = window == null ? void 0 : window.navigator) == null ? void 0 : _a2.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function createFilterWrapper(filter, fn2) {
  function wrapper(...args) {
    return new Promise((resolve, reject) => {
      Promise.resolve(filter(() => fn2.apply(this, args), { fn: fn2, thisArg: this, args })).then(resolve).catch(reject);
    });
  }
  return wrapper;
}
function debounceFilter(ms2, options = {}) {
  let timer;
  let maxTimer;
  let lastRejector = noop;
  const _clearTimeout = (timer2) => {
    clearTimeout(timer2);
    lastRejector();
    lastRejector = noop;
  };
  let lastInvoker;
  const filter = (invoke) => {
    const duration = toValue$1(ms2);
    const maxDuration = toValue$1(options.maxWait);
    if (timer)
      _clearTimeout(timer);
    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
      if (maxTimer) {
        _clearTimeout(maxTimer);
        maxTimer = void 0;
      }
      return Promise.resolve(invoke());
    }
    return new Promise((resolve, reject) => {
      lastRejector = options.rejectOnCancel ? reject : resolve;
      lastInvoker = invoke;
      if (maxDuration && !maxTimer) {
        maxTimer = setTimeout(() => {
          if (timer)
            _clearTimeout(timer);
          maxTimer = void 0;
          resolve(lastInvoker());
        }, maxDuration);
      }
      timer = setTimeout(() => {
        if (maxTimer)
          _clearTimeout(maxTimer);
        maxTimer = void 0;
        resolve(invoke());
      }, duration);
    });
  };
  return filter;
}
function promiseTimeout(ms2, throwOnTimeout = false, reason = "Timeout") {
  return new Promise((resolve, reject) => {
    if (throwOnTimeout)
      setTimeout(() => reject(reason), ms2);
    else
      setTimeout(resolve, ms2);
  });
}
function identity(arg) {
  return arg;
}
function pxValue(px) {
  return px.endsWith("rem") ? Number.parseFloat(px) * 16 : Number.parseFloat(px);
}
function toArray(value) {
  return Array.isArray(value) ? value : [value];
}
function cacheStringFunction(fn2) {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn2(str));
  };
}
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
var camelizeRE = /-(\w)/g;
var camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
});
function getLifeCycleTarget(target) {
  return target || getCurrentInstance();
}
function useDebounceFn(fn2, ms2 = 200, options = {}) {
  return createFilterWrapper(
    debounceFilter(ms2, options),
    fn2
  );
}
function refDebounced(value, ms2 = 200, options = {}) {
  const debounced = ref(toValue$1(value));
  const updater = useDebounceFn(() => {
    debounced.value = value.value;
  }, ms2, options);
  watch(value, () => updater());
  return shallowReadonly(debounced);
}
function tryOnMounted(fn2, sync = true, target) {
  const instance = getLifeCycleTarget(target);
  if (instance)
    onMounted(fn2, target);
  else if (sync)
    fn2();
  else
    nextTick(fn2);
}
function createUntil(r, isNot = false) {
  function toMatch(condition, { flush = "sync", deep = false, timeout, throwOnTimeout } = {}) {
    let stop = null;
    const watcher = new Promise((resolve) => {
      stop = watch(
        r,
        (v) => {
          if (condition(v) !== isNot) {
            if (stop)
              stop();
            else
              nextTick(() => stop == null ? void 0 : stop());
            resolve(v);
          }
        },
        {
          flush,
          deep,
          immediate: true
        }
      );
    });
    const promises = [watcher];
    if (timeout != null) {
      promises.push(
        promiseTimeout(timeout, throwOnTimeout).then(() => toValue$1(r)).finally(() => stop == null ? void 0 : stop())
      );
    }
    return Promise.race(promises);
  }
  function toBe(value, options) {
    if (!isRef(value))
      return toMatch((v) => v === value, options);
    const { flush = "sync", deep = false, timeout, throwOnTimeout } = options != null ? options : {};
    let stop = null;
    const watcher = new Promise((resolve) => {
      stop = watch(
        [r, value],
        ([v1, v2]) => {
          if (isNot !== (v1 === v2)) {
            if (stop)
              stop();
            else
              nextTick(() => stop == null ? void 0 : stop());
            resolve(v1);
          }
        },
        {
          flush,
          deep,
          immediate: true
        }
      );
    });
    const promises = [watcher];
    if (timeout != null) {
      promises.push(
        promiseTimeout(timeout, throwOnTimeout).then(() => toValue$1(r)).finally(() => {
          stop == null ? void 0 : stop();
          return toValue$1(r);
        })
      );
    }
    return Promise.race(promises);
  }
  function toBeTruthy(options) {
    return toMatch((v) => Boolean(v), options);
  }
  function toBeNull(options) {
    return toBe(null, options);
  }
  function toBeUndefined(options) {
    return toBe(void 0, options);
  }
  function toBeNaN(options) {
    return toMatch(Number.isNaN, options);
  }
  function toContains(value, options) {
    return toMatch((v) => {
      const array = Array.from(v);
      return array.includes(value) || array.includes(toValue$1(value));
    }, options);
  }
  function changed(options) {
    return changedTimes(1, options);
  }
  function changedTimes(n = 1, options) {
    let count = -1;
    return toMatch(() => {
      count += 1;
      return count >= n;
    }, options);
  }
  if (Array.isArray(toValue$1(r))) {
    const instance = {
      toMatch,
      toContains,
      changed,
      changedTimes,
      get not() {
        return createUntil(r, !isNot);
      }
    };
    return instance;
  } else {
    const instance = {
      toMatch,
      toBe,
      toBeTruthy,
      toBeNull,
      toBeNaN,
      toBeUndefined,
      changed,
      changedTimes,
      get not() {
        return createUntil(r, !isNot);
      }
    };
    return instance;
  }
}
function until(r) {
  return createUntil(r);
}
function useIntervalFn(cb, interval = 1e3, options = {}) {
  const {
    immediate = true,
    immediateCallback = false
  } = options;
  let timer = null;
  const isActive = shallowRef(false);
  function clean() {
    if (timer) {
      clearInterval(timer);
      timer = null;
    }
  }
  function pause() {
    isActive.value = false;
    clean();
  }
  function resume() {
    const intervalValue = toValue$1(interval);
    if (intervalValue <= 0)
      return;
    isActive.value = true;
    if (immediateCallback)
      cb();
    clean();
    if (isActive.value)
      timer = setInterval(cb, intervalValue);
  }
  if (immediate && isClient)
    resume();
  if (isRef(interval) || typeof interval === "function") {
    const stopWatch = watch(interval, () => {
      if (isActive.value && isClient)
        resume();
    });
    tryOnScopeDispose(stopWatch);
  }
  tryOnScopeDispose(pause);
  return {
    isActive: shallowReadonly(isActive),
    pause,
    resume
  };
}
function useTimeoutFn(cb, interval, options = {}) {
  const {
    immediate = true,
    immediateCallback = false
  } = options;
  const isPending = shallowRef(false);
  let timer;
  function clear() {
    if (timer) {
      clearTimeout(timer);
      timer = void 0;
    }
  }
  function stop() {
    isPending.value = false;
    clear();
  }
  function start(...args) {
    if (immediateCallback)
      cb();
    clear();
    isPending.value = true;
    timer = setTimeout(() => {
      isPending.value = false;
      timer = void 0;
      cb(...args);
    }, toValue$1(interval));
  }
  if (immediate) {
    isPending.value = true;
    if (isClient)
      start();
  }
  tryOnScopeDispose(stop);
  return {
    isPending: shallowReadonly(isPending),
    start,
    stop
  };
}
function useTimeout(interval = 1e3, options = {}) {
  const {
    controls: exposeControls = false,
    callback
  } = options;
  const controls = useTimeoutFn(
    callback != null ? callback : noop,
    interval,
    options
  );
  const ready = computed(() => !controls.isPending.value);
  if (exposeControls) {
    return {
      ready,
      ...controls
    };
  } else {
    return ready;
  }
}
function watchImmediate(source, cb, options) {
  return watch(
    source,
    cb,
    {
      ...options,
      immediate: true
    }
  );
}
function whenever(source, cb, options) {
  const stop = watch(
    source,
    (v, ov, onInvalidate) => {
      if (v) {
        if (options == null ? void 0 : options.once)
          nextTick(() => stop());
        cb(v, ov, onInvalidate);
      }
    },
    {
      ...options,
      once: false
    }
  );
  return stop;
}

// node_modules/@vueuse/core/index.mjs
import { isRef as isRef2, shallowRef as shallowRef2, ref as ref2, watchEffect as watchEffect2, computed as computed2, inject as inject2, defineComponent, h, TransitionGroup, Fragment, shallowReactive, toValue, unref as unref2, getCurrentInstance as getCurrentInstance2, onMounted as onMounted2, watch as watch2, customRef as customRef2, onUpdated, readonly as readonly2, reactive as reactive2, hasInjectionContext as hasInjectionContext2, toRaw, shallowReadonly as shallowReadonly2, nextTick as nextTick2, markRaw, getCurrentScope as getCurrentScope2, isReadonly, onBeforeUpdate } from "vue";
var defaultWindow = isClient ? window : void 0;
var defaultDocument = isClient ? window.document : void 0;
var defaultNavigator = isClient ? window.navigator : void 0;
var defaultLocation = isClient ? window.location : void 0;
function unrefElement(elRef) {
  var _a2;
  const plain = toValue(elRef);
  return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
}
function useEventListener(...args) {
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn2) => fn2());
    cleanups.length = 0;
  };
  const register = (el2, event, listener, options) => {
    el2.addEventListener(event, listener, options);
    return () => el2.removeEventListener(event, listener, options);
  };
  const firstParamTargets = computed2(() => {
    const test = toArray(toValue(args[0])).filter((e) => e != null);
    return test.every((e) => typeof e !== "string") ? test : void 0;
  });
  const stopWatch = watchImmediate(
    () => {
      var _a2, _b;
      return [
        (_b = (_a2 = firstParamTargets.value) == null ? void 0 : _a2.map((e) => unrefElement(e))) != null ? _b : [defaultWindow].filter((e) => e != null),
        toArray(toValue(firstParamTargets.value ? args[1] : args[0])),
        toArray(unref2(firstParamTargets.value ? args[2] : args[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        toValue(firstParamTargets.value ? args[3] : args[2])
      ];
    },
    ([raw_targets, raw_events, raw_listeners, raw_options]) => {
      cleanup();
      if (!(raw_targets == null ? void 0 : raw_targets.length) || !(raw_events == null ? void 0 : raw_events.length) || !(raw_listeners == null ? void 0 : raw_listeners.length))
        return;
      const optionsClone = isObject(raw_options) ? { ...raw_options } : raw_options;
      cleanups.push(
        ...raw_targets.flatMap(
          (el2) => raw_events.flatMap(
            (event) => raw_listeners.map((listener) => register(el2, event, listener, optionsClone))
          )
        )
      );
    },
    { flush: "post" }
  );
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(cleanup);
  return stop;
}
function useMounted() {
  const isMounted = shallowRef2(false);
  const instance = getCurrentInstance2();
  if (instance) {
    onMounted2(() => {
      isMounted.value = true;
    }, instance);
  }
  return isMounted;
}
function useSupported(callback) {
  const isMounted = useMounted();
  return computed2(() => {
    isMounted.value;
    return Boolean(callback());
  });
}
function useRafFn(fn2, options = {}) {
  const {
    immediate = true,
    fpsLimit = void 0,
    window: window2 = defaultWindow,
    once = false
  } = options;
  const isActive = shallowRef2(false);
  const intervalLimit = computed2(() => {
    return fpsLimit ? 1e3 / toValue(fpsLimit) : null;
  });
  let previousFrameTimestamp = 0;
  let rafId = null;
  function loop(timestamp2) {
    if (!isActive.value || !window2)
      return;
    if (!previousFrameTimestamp)
      previousFrameTimestamp = timestamp2;
    const delta = timestamp2 - previousFrameTimestamp;
    if (intervalLimit.value && delta < intervalLimit.value) {
      rafId = window2.requestAnimationFrame(loop);
      return;
    }
    previousFrameTimestamp = timestamp2;
    fn2({ delta, timestamp: timestamp2 });
    if (once) {
      isActive.value = false;
      rafId = null;
      return;
    }
    rafId = window2.requestAnimationFrame(loop);
  }
  function resume() {
    if (!isActive.value && window2) {
      isActive.value = true;
      previousFrameTimestamp = 0;
      rafId = window2.requestAnimationFrame(loop);
    }
  }
  function pause() {
    isActive.value = false;
    if (rafId != null && window2) {
      window2.cancelAnimationFrame(rafId);
      rafId = null;
    }
  }
  if (immediate)
    resume();
  tryOnScopeDispose(pause);
  return {
    isActive: readonly2(isActive),
    pause,
    resume
  };
}
function useAsyncState(promise, initialState, options) {
  var _a2;
  const {
    immediate = true,
    delay = 0,
    onError = (_a2 = globalThis.reportError) != null ? _a2 : noop,
    onSuccess = noop,
    resetOnExecute = true,
    shallow = true,
    throwError
  } = options != null ? options : {};
  const state = shallow ? shallowRef2(initialState) : ref2(initialState);
  const isReady = shallowRef2(false);
  const isLoading = shallowRef2(false);
  const error = shallowRef2(void 0);
  async function execute(delay2 = 0, ...args) {
    if (resetOnExecute)
      state.value = toValue(initialState);
    error.value = void 0;
    isReady.value = false;
    isLoading.value = true;
    if (delay2 > 0)
      await promiseTimeout(delay2);
    const _promise = typeof promise === "function" ? promise(...args) : promise;
    try {
      const data = await _promise;
      state.value = data;
      isReady.value = true;
      onSuccess(data);
    } catch (e) {
      error.value = e;
      onError(e);
      if (throwError)
        throw e;
    } finally {
      isLoading.value = false;
    }
    return state.value;
  }
  if (immediate) {
    execute(delay);
  }
  const shell = {
    state,
    isReady,
    isLoading,
    error,
    execute,
    executeImmediate: (...args) => execute(0, ...args)
  };
  function waitUntilIsLoaded() {
    return new Promise((resolve, reject) => {
      until(isLoading).toBe(false).then(() => resolve(shell)).catch(reject);
    });
  }
  return {
    ...shell,
    then(onFulfilled, onRejected) {
      return waitUntilIsLoaded().then(onFulfilled, onRejected);
    }
  };
}
var ssrWidthSymbol = Symbol("vueuse-ssr-width");
function useSSRWidth() {
  const ssrWidth = hasInjectionContext2() ? injectLocal(ssrWidthSymbol, null) : null;
  return typeof ssrWidth === "number" ? ssrWidth : void 0;
}
function useMediaQuery(query, options = {}) {
  const { window: window2 = defaultWindow, ssrWidth = useSSRWidth() } = options;
  const isSupported = useSupported(() => window2 && "matchMedia" in window2 && typeof window2.matchMedia === "function");
  const ssrSupport = shallowRef2(typeof ssrWidth === "number");
  const mediaQuery = shallowRef2();
  const matches = shallowRef2(false);
  const handler = (event) => {
    matches.value = event.matches;
  };
  watchEffect2(() => {
    if (ssrSupport.value) {
      ssrSupport.value = !isSupported.value;
      const queryStrings = toValue(query).split(",");
      matches.value = queryStrings.some((queryString) => {
        const not = queryString.includes("not all");
        const minWidth = queryString.match(/\(\s*min-width:\s*(-?\d+(?:\.\d*)?[a-z]+\s*)\)/);
        const maxWidth = queryString.match(/\(\s*max-width:\s*(-?\d+(?:\.\d*)?[a-z]+\s*)\)/);
        let res = Boolean(minWidth || maxWidth);
        if (minWidth && res) {
          res = ssrWidth >= pxValue(minWidth[1]);
        }
        if (maxWidth && res) {
          res = ssrWidth <= pxValue(maxWidth[1]);
        }
        return not ? !res : res;
      });
      return;
    }
    if (!isSupported.value)
      return;
    mediaQuery.value = window2.matchMedia(toValue(query));
    matches.value = mediaQuery.value.matches;
  });
  useEventListener(mediaQuery, "change", handler, { passive: true });
  return computed2(() => matches.value);
}
var _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var globalKey = "__vueuse_ssr_handlers__";
var handlers = getHandlers();
function getHandlers() {
  if (!(globalKey in _global))
    _global[globalKey] = _global[globalKey] || {};
  return _global[globalKey];
}
function useDevicePixelRatio(options = {}) {
  const {
    window: window2 = defaultWindow
  } = options;
  const pixelRatio = shallowRef2(1);
  const query = useMediaQuery(() => `(resolution: ${pixelRatio.value}dppx)`, options);
  let stop = noop;
  if (window2) {
    stop = watchImmediate(query, () => pixelRatio.value = window2.devicePixelRatio);
  }
  return {
    pixelRatio: readonly2(pixelRatio),
    stop
  };
}
function useResizeObserver(target, callback, options = {}) {
  const { window: window2 = defaultWindow, ...observerOptions } = options;
  let observer;
  const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const targets = computed2(() => {
    const _targets = toValue(target);
    return Array.isArray(_targets) ? _targets.map((el2) => unrefElement(el2)) : [unrefElement(_targets)];
  });
  const stopWatch = watch2(
    targets,
    (els) => {
      cleanup();
      if (isSupported.value && window2) {
        observer = new ResizeObserver(callback);
        for (const _el of els) {
          if (_el)
            observer.observe(_el, observerOptions);
        }
      }
    },
    { immediate: true, flush: "post" }
  );
  const stop = () => {
    cleanup();
    stopWatch();
  };
  tryOnScopeDispose(stop);
  return {
    isSupported,
    stop
  };
}
function useElementSize(target, initialSize = { width: 0, height: 0 }, options = {}) {
  const { window: window2 = defaultWindow, box = "content-box" } = options;
  const isSVG = computed2(() => {
    var _a2, _b;
    return (_b = (_a2 = unrefElement(target)) == null ? void 0 : _a2.namespaceURI) == null ? void 0 : _b.includes("svg");
  });
  const width = shallowRef2(initialSize.width);
  const height = shallowRef2(initialSize.height);
  const { stop: stop1 } = useResizeObserver(
    target,
    ([entry]) => {
      const boxSize = box === "border-box" ? entry.borderBoxSize : box === "content-box" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;
      if (window2 && isSVG.value) {
        const $elem = unrefElement(target);
        if ($elem) {
          const rect = $elem.getBoundingClientRect();
          width.value = rect.width;
          height.value = rect.height;
        }
      } else {
        if (boxSize) {
          const formatBoxSize = toArray(boxSize);
          width.value = formatBoxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);
          height.value = formatBoxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);
        } else {
          width.value = entry.contentRect.width;
          height.value = entry.contentRect.height;
        }
      }
    },
    options
  );
  tryOnMounted(() => {
    const ele = unrefElement(target);
    if (ele) {
      width.value = "offsetWidth" in ele ? ele.offsetWidth : initialSize.width;
      height.value = "offsetHeight" in ele ? ele.offsetHeight : initialSize.height;
    }
  });
  const stop2 = watch2(
    () => unrefElement(target),
    (ele) => {
      width.value = ele ? initialSize.width : 0;
      height.value = ele ? initialSize.height : 0;
    }
  );
  function stop() {
    stop1();
    stop2();
  }
  return {
    width,
    height,
    stop
  };
}
function useFps(options) {
  var _a2;
  const fps = shallowRef2(0);
  if (typeof performance === "undefined")
    return fps;
  const every = (_a2 = options == null ? void 0 : options.every) != null ? _a2 : 10;
  let last = performance.now();
  let ticks = 0;
  useRafFn(() => {
    ticks += 1;
    if (ticks >= every) {
      const now = performance.now();
      const diff = now - last;
      fps.value = Math.round(1e3 / (diff / ticks));
      last = now;
      ticks = 0;
    }
  });
  return fps;
}
function useMemory(options = {}) {
  const memory = ref2();
  const isSupported = useSupported(() => typeof performance !== "undefined" && "memory" in performance);
  if (isSupported.value) {
    const { interval = 1e3 } = options;
    useIntervalFn(() => {
      memory.value = performance.memory;
    }, interval, { immediate: options.immediate, immediateCallback: options.immediateCallback });
  }
  return { isSupported, memory };
}
var defaultState = {
  x: 0,
  y: 0,
  pointerId: 0,
  pressure: 0,
  tiltX: 0,
  tiltY: 0,
  width: 0,
  height: 0,
  twist: 0,
  pointerType: null
};
var keys = Object.keys(defaultState);
var DEFAULT_UNITS = [
  { max: 6e4, value: 1e3, name: "second" },
  { max: 276e4, value: 6e4, name: "minute" },
  { max: 72e6, value: 36e5, name: "hour" },
  { max: 5184e5, value: 864e5, name: "day" },
  { max: 24192e5, value: 6048e5, name: "week" },
  { max: 28512e6, value: 2592e6, name: "month" },
  { max: Number.POSITIVE_INFINITY, value: 31536e6, name: "year" }
];
var _TransitionPresets = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
var TransitionPresets = Object.assign({}, { linear: identity }, _TransitionPresets);
function useWindowSize(options = {}) {
  const {
    window: window2 = defaultWindow,
    initialWidth = Number.POSITIVE_INFINITY,
    initialHeight = Number.POSITIVE_INFINITY,
    listenOrientation = true,
    includeScrollbar = true,
    type = "inner"
  } = options;
  const width = shallowRef2(initialWidth);
  const height = shallowRef2(initialHeight);
  const update = () => {
    if (window2) {
      if (type === "outer") {
        width.value = window2.outerWidth;
        height.value = window2.outerHeight;
      } else if (type === "visual" && window2.visualViewport) {
        const { width: visualViewportWidth, height: visualViewportHeight, scale } = window2.visualViewport;
        width.value = Math.round(visualViewportWidth * scale);
        height.value = Math.round(visualViewportHeight * scale);
      } else if (includeScrollbar) {
        width.value = window2.innerWidth;
        height.value = window2.innerHeight;
      } else {
        width.value = window2.document.documentElement.clientWidth;
        height.value = window2.document.documentElement.clientHeight;
      }
    }
  };
  update();
  tryOnMounted(update);
  const listenerOptions = { passive: true };
  useEventListener("resize", update, listenerOptions);
  if (window2 && type === "visual" && window2.visualViewport) {
    useEventListener(window2.visualViewport, "resize", update, listenerOptions);
  }
  if (listenOrientation) {
    const matches = useMediaQuery("(orientation: portrait)");
    watch2(matches, () => update());
  }
  return { width, height };
}

// node_modules/@tresjs/core/dist/tres.js
var _i = "@tresjs/core";
var mi = "module";
var gi = "5.1.0";
var Ei = "pnpm@10.17.0";
var vi = "Declarative ThreeJS using Vue Components";
var yi = "Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)";
var Ci = "MIT";
var bi = { type: "git", url: "git+https://github.com/Tresjs/tres.git", directory: "packages/core" };
var wi = ["vue", "3d", "threejs", "three", "threejs-vue"];
var Ai = false;
var Ti = { ".": { types: "./dist/index.d.ts", import: "./dist/tres.js", default: "./dist/tres.js" }, "./components": { types: "./dist/src/components/index.d.ts" }, "./composables": { types: "./dist/src/composables/index.d.ts" }, "./types": { types: "./dist/src/types/index.d.ts" }, "./utils": { types: "./dist/src/utils/index.d.ts" }, "./*": "./*" };
var Oi = "./dist/tres.js";
var Si = "./dist/index.d.ts";
var Pi = ["*.d.ts", "dist"];
var Ii = { access: "public" };
var Di = { build: "vite build", test: "vitest", "test:ci": "vitest run", "test:ui": "vitest --ui --coverage.enabled=true", coverage: "vitest run --coverage", lint: "eslint .", "lint:fix": "eslint . --fix", typecheck: "vue-tsc --noEmit" };
var ki = { three: ">=0.133", vue: ">=3.4" };
var xi = { "@pmndrs/pointer-events": "^6.6.17", "@vue/devtools-api": "^7.7.2", "@vueuse/core": "catalog:", radashi: "^12.6.2" };
var Ri = { "@tresjs/eslint-config": "workspace:*", "@types/three": "catalog:", "@typescript-eslint/eslint-plugin": "catalog:", "@typescript-eslint/parser": "catalog:", "@vitejs/plugin-vue": "catalog:", "@vitest/coverage-v8": "3.2.4", "@vitest/ui": "catalog:", "@vue/test-utils": "catalog:", eslint: "catalog:", "eslint-plugin-vue": "catalog:", jsdom: "catalog:", kolorist: "catalog:", pathe: "catalog:", "rollup-plugin-analyzer": "catalog:", "rollup-plugin-copy": "^3.5.0", "rollup-plugin-visualizer": "catalog:", three: "catalog:", vite: "catalog:", "vite-plugin-banner": "catalog:", "vite-plugin-dts": "catalog:", "vite-plugin-inspect": "^11.3.3", vitest: "catalog:", vue: "catalog:", "vue-demi": "^0.14.10", "vue-tsc": "catalog:" };
var Li = { implicitDependencies: ["!@tresjs/core-*"] };
var Fi = {
  name: _i,
  type: mi,
  version: gi,
  packageManager: Ei,
  description: vi,
  author: yi,
  license: Ci,
  repository: bi,
  keywords: wi,
  sideEffects: Ai,
  exports: Ti,
  module: Oi,
  types: Si,
  files: Pi,
  publishConfig: Ii,
  scripts: Di,
  peerDependencies: ki,
  dependencies: xi,
  devDependencies: Ri,
  nx: Li
};
function Mi(e) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const n of e.split(","))
    t[n] = 1;
  return (n) => n in t;
}
var Ni = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
var Vi = Mi(Ni);
function Qt(e) {
  var t;
  const n = ((t = e?.replace(/([A-Z])+/g, Bi)) == null ? void 0 : t.split(/(?=[A-Z])|[\.\-\s_]/).map((r) => r.toLowerCase())) ?? [];
  return n.length === 0 ? "" : n.length === 1 ? n[0] : n.reduce((r, o) => `${r}${o.charAt(0).toUpperCase()}${o.slice(1)}`);
}
function Bi(e) {
  if (!e || e.length === 0)
    return "";
  const t = e.toLowerCase();
  return t.substring(0, 1).toUpperCase() + t.substring(1, t.length);
}
function Or(e, t) {
  if (Object.is(e, t))
    return true;
  if (e instanceof Date && t instanceof Date)
    return e.getTime() === t.getTime();
  if (e instanceof RegExp && t instanceof RegExp)
    return e.toString() === t.toString();
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return false;
  const n = Reflect.ownKeys(e), r = Reflect.ownKeys(t);
  if (n.length !== r.length)
    return false;
  for (let o = 0; o < n.length; o++)
    if (!Reflect.has(t, n[o]) || !Or(e[n[o]], t[n[o]]))
      return false;
  return true;
}
function Q(e) {
  return typeof e == "function";
}
function Sr(e) {
  return typeof e == "number" && !Number.isNaN(e);
}
function Tt(e) {
  return Ui(e, "[object Object]");
}
function Ot(e) {
  return typeof e == "string";
}
function Ui(e, t) {
  return Object.prototype.toString.call(e) === t;
}
function ut(e) {
  return typeof e > "u";
}
var B = (e) => (t) => Tt(t) && e in t && !!t[e];
var lt = B("isObject3D");
var $e = B("isMesh");
var Pr = B("isCamera");
var Hi = B("isOrthographicCamera");
var Ir = B("isPerspectiveCamera");
var Dr = B("isColor");
var ji = (e) => Ot(e) || Sr(e) || Dr(e);
var Zt = (e) => e instanceof Layers;
var kr = B("isBufferGeometry");
var xr = B("isMaterial");
var Rr = B("isLight");
var Lr = B("isFog");
var Fr = B("isScene");
var cl = B("isGroup");
var ct = (e) => e !== null && typeof e == "object" && "set" in e && typeof e.set == "function";
var zi = (e) => ct(e) && "copy" in e && typeof e.copy == "function";
var $i = (e) => !!e?.constructor;
var re = (e) => Pr(e) || Hi(e) || Ir(e);
var Ki = (e) => (
  // NOTE: TresObject is currently defined as
  // TresObject3D | THREE.BufferGeometry | THREE.Material | THREE.Fog
  lt(e) || kr(e) || xr(e) || Lr(e)
);
var Wi = B("isPrimitive");
var Gi = (e) => Ki(e) && "__tres" in e;
var Yi = (e, t) => {
  let n = 0;
  for (let r = 0; r < e.length; r++)
    t(e[r], r) && (e[n] = e[r], n++);
  return e.length = n, e;
};
var fl = true;
var Fe = "[TresJS ▲ ■ ●] ";
function Jt(...e) {
  typeof e[0] == "string" ? e[0] = Fe + e[0] : e.unshift(Fe), console.error(...e);
}
function Me(...e) {
  typeof e[0] == "string" ? e[0] = Fe + e[0] : e.unshift(Fe), console.warn(...e);
}
function dl(e, t) {
}
function en(e) {
  ((n) => "map" in n && !!n.map)(e) && e.map.dispose(), e.dispose();
}
function Ne(e) {
  if (e.parent && e.removeFromParent?.(), delete e.__tres, [...e.children].forEach((n) => Ne(n)), !(e instanceof Scene)) {
    const n = e;
    e && e.dispose?.(), n.geometry && n.geometry.dispose(), Array.isArray(n.material) ? n.material.forEach((r) => en(r)) : n.material && en(n.material);
  }
}
function Ve(e, t) {
  let n = e;
  if (t.includes("-")) {
    const r = t.split("-");
    let o = r.shift();
    for (; n && r.length; )
      o in n ? (n = n[o], o = r.shift()) : o = tn(o, r.shift());
    return { target: n, key: tn(o, ...r) };
  } else
    return { target: n, key: t };
}
function tn(...e) {
  return e.map((t, n) => n === 0 ? t : t.charAt(0).toUpperCase() + t.slice(1)).join("");
}
function qi(e, t, n) {
  const r = /-\d+$/;
  if (Ot(n)) {
    if (r.test(n)) {
      const s = n.replace(r, ""), { target: a, key: u } = Ve(e, s);
      if (!Array.isArray(a[u])) {
        const l = a[u], c = [];
        c.__tresDetach = () => {
          c.every((f) => ut(f)) && (a[u] = l);
        }, a[u] = c;
      }
    }
    const { target: o, key: i } = Ve(e, n);
    t.__tres.previousAttach = o[i], o[i] = se(t);
  } else
    t.__tres.previousAttach = n(e, t);
}
function Xi(e, t, n) {
  if (Ot(n)) {
    const { target: r, key: o } = Ve(e, n), i = t.__tres.previousAttach;
    i === void 0 ? delete r[o] : r[o] = i, "__tresDetach" in r && r.__tresDetach();
  } else
    t.__tres?.previousAttach?.(e, t);
  delete t.__tres?.previousAttach;
}
function X(e, t, n) {
  const r = e;
  return r.__tres = {
    type: "unknown",
    root: n,
    memoizedProps: {},
    objects: [],
    parent: null,
    previousAttach: null,
    ...t
  }, r.__tres.attach || (xr(r) ? r.__tres.attach = "material" : kr(r) ? r.__tres.attach = "geometry" : Lr(r) && (r.__tres.attach = "fog")), r;
}
function ft(e) {
  const t = e?.__tres?.root;
  t?.renderer && t.renderer.canBeInvalidated.value && t.renderer.invalidate();
}
function Qi(e, t, n, r, o) {
  const i = [...t.__tres.objects], s = se(t);
  if (e = se(e), s === e)
    return true;
  const a = X(e, t.__tres ?? {}, o), u = t.parent ?? t.__tres.parent ?? null, l = { ...t.__tres.memoizedProps };
  delete l.object;
  for (const c of i)
    Mr(c, o), Nr(c, o);
  s.__tres.objects = [], r.remove(t);
  for (const [c, f] of Object.entries(l))
    r.patchProp(a, c, a[c], f);
  n(e), r.insert(t, u);
  for (const c of i)
    r.insert(c, t);
  return true;
}
function se(e) {
  if (Wi(e)) {
    const t = e;
    return t.object.__tres = t.__tres, t.object;
  } else
    return e;
}
function Mr(e, t) {
  const n = e.__tres?.parent || t.scene.value;
  e.__tres && (e.__tres.parent = null), n && n.__tres && "objects" in n.__tres && Yi(n.__tres.objects, (r) => r !== e), e.__tres?.attach ? Xi(n, e, e.__tres.attach) : (e.parent?.remove?.(se(e)), e.parent = null);
}
function Nr(e, t) {
  e.traverse?.((n) => {
    re(n) && t.camera.deregisterCamera(n);
  }), re(e) && t.camera.deregisterCamera(e), ft(e);
}
function Zi(e, t, n) {
  const r = new e(n?.manager), o = Io({
    loaded: 0,
    total: 0,
    percentage: 0
  });
  n?.extensions && n.extensions(r);
  const i = I(t), s = useAsyncState(
    (u) => new Promise((l, c) => {
      const f = u || i || "";
      r.load(f, (h2) => {
        l(h2);
      }, (h2) => {
        o.loaded = h2.loaded, o.total = h2.total, o.percentage = o.loaded / o.total * 100;
      }, (h2) => {
        c(h2);
      });
    }),
    n?.initialValue ?? null,
    {
      ...n?.asyncOptions,
      immediate: n?.asyncOptions?.immediate ?? true
    }
  ), a = At(() => I(t), (u) => {
    if (u) {
      const l = s.state.value;
      l && typeof l == "object" && "scene" in l && l.scene && Ne(l.scene), s.execute(0, u);
    }
  });
  return ie(() => {
    a();
    const u = s.state.value;
    u && typeof u == "object" && "scene" in u && u.scene && Ne(u.scene);
  }), {
    ...s,
    load: (u) => {
      s.execute(0, u);
    },
    progress: o
  };
}
var pl = ot({
  __name: "component",
  props: {
    loader: {},
    path: {},
    manager: {}
  },
  emits: ["loaded", "error"],
  setup(e, { emit: t }) {
    const n = e, r = t, { state: o, isLoading: i, error: s } = Zi(n.loader, n.path, { manager: n.manager });
    return whenever(s, (a) => {
      a && r("error", a);
    }), whenever(o, (a) => {
      a && r("loaded", a);
    }), (a, u) => Do(a.$slots, "default", {
      state: ke(o),
      isLoading: ke(i),
      error: ke(s)
    });
  }
});
var Ji = ({ sizes: e }) => {
  const t = Ae([]), n = J(() => t.value[0]), r = (s) => {
    const a = Pr(s) ? s : t.value.find((l) => l.uuid === s);
    if (!a)
      return;
    const u = t.value.filter(({ uuid: l }) => l !== a.uuid);
    t.value = [a, ...u];
  }, o = (s, a = false) => {
    t.value.some(({ uuid: u }) => u === s.uuid) || (t.value.push(s), a && r(s.uuid));
  }, i = (s) => {
    t.value = t.value.filter(({ uuid: a }) => a !== s.uuid);
  };
  return $(() => {
    e.aspectRatio.value && t.value.forEach((s) => {
      Ir(s) && (s.aspect = e.aspectRatio.value, s.updateProjectionMatrix());
    });
  }), {
    activeCamera: n,
    cameras: t,
    registerCamera: o,
    deregisterCamera: i,
    setActiveCamera: r
  };
};
function es(e) {
  const t = { nodes: {}, materials: {}, meshes: {} };
  return e && e.traverse((n) => {
    n.name && (t.nodes[n.name] = n), $e(n) && (t.meshes[n.name] || (t.meshes[n.name] = n), (Array.isArray(n.material) ? n.material : [n.material]).forEach((r) => {
      r.name && !t.materials[r.name] && (t.materials[r.name] = r);
    }));
  }), t;
}
var hl = (e) => J(() => {
  const t = I(e);
  if (t)
    return es(t);
});
function nn() {
  const e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Set();
  let n = 0, r = false;
  const o = () => {
    const l = Array.from(e.entries()).sort((c, f) => {
      const h2 = c[1].priority - f[1].priority;
      return h2 === 0 ? c[1].addI - f[1].addI : h2;
    });
    t.clear(), l.forEach((c) => t.add(c[0]));
  }, i = (l) => {
    e.delete(l), t.delete(l);
  };
  return { on: (l, c = 0) => {
    e.set(l, { priority: c, addI: n++ });
    const f = () => i(l);
    return tryOnScopeDispose(f), r = true, {
      off: f
    };
  }, off: i, trigger: (...l) => (r && (o(), r = false), Promise.all(
    Array.from(t).map((c) => c(...l))
  )), dispose: () => {
    e.clear(), t.clear();
  }, get count() {
    return e.size;
  } };
}
var dt = Ae({});
var pt = (e) => Object.assign(dt.value, e);
var ts = (e, t, n) => {
  if (!Q(e.setPixelRatio))
    return;
  let r = 0;
  if (n && Array.isArray(n) && n.length >= 2) {
    const [o, i] = n;
    r = MathUtils.clamp(t, o, i);
  } else Sr(n) ? r = n : r = t;
  r !== e.getPixelRatio?.() && e.setPixelRatio(r);
};
var ns = (e) => {
  const t = new Clock(), n = {
    before: createEventHook(),
    after: createEventHook()
  }, { pause: r, resume: o, isActive: i } = useRafFn(() => {
    const u = () => ({
      delta: t.getDelta(),
      elapsed: t.elapsedTime
    });
    n.before.trigger(u()), e(), n.after.trigger(u());
  }, {
    immediate: false
  });
  return {
    start: () => {
      t.start(), o();
    },
    stop: () => {
      t.stop(), r();
    },
    isActive: i,
    onBeforeLoop: n.before.on,
    onLoop: n.after.on
  };
};
function rs({
  scene: e,
  canvas: t,
  options: n,
  contextParts: { sizes: r, camera: o }
}) {
  const s = Q(n.renderer) ? n.renderer({
    sizes: r,
    scene: e,
    camera: o,
    canvas: t
  }) : new WebGLRenderer({
    ...n,
    canvas: unrefElement(t)
  }), a = Ae(I(n.renderMode) === "manual" ? 0 : 1), u = 60, l = J(() => I(n.renderMode) === "on-demand" && a.value === 0), c = () => e.value.traverse((E) => {
    E instanceof Mesh && E.material instanceof Material && (E.material.needsUpdate = true);
  }), f = (E = 1) => {
    l.value && (a.value = Math.min(u, a.value + E));
  }, h2 = () => {
    if (I(n.renderMode) !== "manual")
      throw new Error("advance can only be called in manual render mode.");
    a.value = 1;
  }, d = () => {
    I(n.renderMode) === "on-demand" && f();
  }, _ = J(() => I(n.renderMode) === "always"), v = (E) => Tt(E) && "isRenderer" in E && !!E.isRenderer, p = createEventHook();
  let g = false;
  v(s) && (s.init(), p.trigger(s));
  const C = createEventHook(), b = () => {
    a.value = _.value ? 1 : Math.max(0, a.value - 1), C.trigger(s);
  };
  let P = (E) => {
    o.activeCamera.value && (s.render(e.value, o.activeCamera.value), E());
  };
  const M = (E) => {
    P = E;
  }, A = ns(() => {
    a.value && P(b);
  });
  p.on(A.start), At([r.width, r.height], () => {
    s.setSize(r.width.value, r.height.value), !g && s.domElement.width && s.domElement.height && (p.trigger(s), g = true), d();
  }, {
    immediate: true
  });
  const { pixelRatio: O } = useDevicePixelRatio();
  $(() => {
    ts(s, O.value, I(n.dpr));
  }), I(n.renderMode) === "on-demand" && f(), I(n.renderMode) === "manual" && useTimeout(100, {
    callback: h2
  });
  const T = J(() => {
    const E = I(n.clearColor), x = I(n.clearAlpha), R = typeof E == "string" && E.length === 9 && E.startsWith("#");
    return R && x !== void 0 && Me(`clearColor with alpha (e.g. ${E}) and clearAlpha cannot both be set, using clearColor as source of truth`), R ? {
      alpha: Number.parseInt(E.slice(7, 9), 16) / 255,
      color: E.slice(0, 7)
    } : {
      alpha: x,
      color: E
    };
  });
  return $(() => {
    const E = T.value;
    E.color === void 0 || E.alpha === void 0 || s.setClearColor(E.color, E.alpha);
  }), $(() => {
    const E = n.toneMapping;
    E && (s.toneMapping = E);
  }), $(() => {
    const E = n.toneMappingExposure;
    E && (s.toneMappingExposure = E);
  }), $(() => {
    const E = n.outputColorSpace;
    E && (s.outputColorSpace = E);
  }), $(() => {
    const E = n.shadows;
    E !== void 0 && (s.shadowMap.enabled = E, c());
  }), $(() => {
    const E = n.shadowMapType;
    E !== void 0 && (s.shadowMap.type = E, c());
  }), ie(() => {
    s.dispose(), "forceContextLoss" in s && s.forceContextLoss();
  }), {
    loop: A,
    instance: s,
    advance: h2,
    onReady: p.on,
    onRender: C.on,
    invalidate: f,
    canBeInvalidated: l,
    mode: I(n.renderMode),
    replaceRenderFunction: M
  };
}
function os(e, t, n = 10) {
  const r = I(e) ? useWindowSize() : useElementSize(J(() => I(t).parentElement)), o = zt(refDebounced(r.width, n)), i = zt(refDebounced(r.height, n)), s = J(() => o.value / i.value);
  return {
    height: i,
    width: o,
    aspectRatio: s
  };
}
var is = class {
  nativeEvent;
  NONE = 0;
  CAPTURING_PHASE = 1;
  AT_TARGET = 2;
  BUBBLING_PHASE = 3;
  relatedTarget = null;
  get altKey() {
    return this.getFromNative("altKey", false);
  }
  get button() {
    return this.getFromNative("button", 0);
  }
  get buttons() {
    return this.getFromNative("buttons", 0);
  }
  get clientX() {
    return this.getFromNative("clientX", 0);
  }
  get clientY() {
    return this.getFromNative("clientY", 0);
  }
  get ctrlKey() {
    return this.getFromNative("ctrlKey", false);
  }
  get layerX() {
    return this.getFromNative("layerX", 0);
  }
  get layerY() {
    return this.getFromNative("layerY", 0);
  }
  get metaKey() {
    return this.getFromNative("metaKey", false);
  }
  get movementX() {
    return this.getFromNative("movementX", 0);
  }
  get movementY() {
    return this.getFromNative("movementY", 0);
  }
  get offsetX() {
    return this.getFromNative("offsetX", 0);
  }
  get offsetY() {
    return this.getFromNative("offsetY", 0);
  }
  get pageX() {
    return this.getFromNative("pageX", 0);
  }
  get pageY() {
    return this.getFromNative("pageY", 0);
  }
  get screenX() {
    return this.getFromNative("screenX", 0);
  }
  get screenY() {
    return this.getFromNative("screenY", 0);
  }
  get shiftKey() {
    return this.getFromNative("shiftKey", false);
  }
  get x() {
    return this.getFromNative("x", 0);
  }
  get y() {
    return this.getFromNative("y", 0);
  }
  get detail() {
    return this.getFromNative("detail", 0);
  }
  get view() {
    return this.getFromNative("view", null);
  }
  get which() {
    return this.getFromNative("which", 0);
  }
  get cancelBubble() {
    return this.getFromNative("cancelBubble", false);
  }
  get composed() {
    return this.getFromNative("composed", false);
  }
  get eventPhase() {
    return this.getFromNative("eventPhase", 0);
  }
  get isTrusted() {
    return this.getFromNative("isTrusted", false);
  }
  get returnValue() {
    return this.getFromNative("returnValue", false);
  }
  get timeStamp() {
    return this.getFromNative("timeStamp", 0);
  }
  get cancelable() {
    return this.getFromNative("cancelable", false);
  }
  get defaultPrevented() {
    return this.getFromNative("defaultPrevented", false);
  }
  constructor(t) {
    this.nativeEvent = t;
  }
  getFromNative(t, n) {
    return t in this.nativeEvent ? this.nativeEvent[t] : n;
  }
};
var Xe = new Vector3();
var L = class _L extends is {
  type;
  bubbles;
  internalPointer;
  intersection;
  camera;
  currentObject;
  object;
  propagationState;
  //--- pointer events data
  get pointerId() {
    return this.internalPointer.id;
  }
  get pointerType() {
    return this.internalPointer.type;
  }
  get pointerState() {
    return this.internalPointer.state;
  }
  //--- intersection data
  get distance() {
    return this.intersection.distance;
  }
  get distanceToRay() {
    return this.intersection.distanceToRay;
  }
  get point() {
    return this.intersection.point;
  }
  get index() {
    return this.intersection.index;
  }
  get face() {
    return this.intersection.face;
  }
  get faceIndex() {
    return this.intersection.faceIndex;
  }
  get uv() {
    return this.intersection.uv;
  }
  get uv1() {
    return this.intersection.uv1;
  }
  get normal() {
    return this.intersection.normal;
  }
  get instanceId() {
    return this.intersection.instanceId;
  }
  get pointOnLine() {
    return this.intersection.pointOnLine;
  }
  get batchId() {
    return this.intersection.batchId;
  }
  get pointerPosition() {
    return this.intersection.pointerPosition;
  }
  get pointerQuaternion() {
    return this.intersection.pointerQuaternion;
  }
  get pointOnFace() {
    return this.intersection.pointOnFace;
  }
  get localPoint() {
    return this.intersection.localPoint;
  }
  get details() {
    return this.intersection.details;
  }
  /** same as object */
  get target() {
    return this.object;
  }
  /** same as currentObject */
  get currentTarget() {
    return this.currentObject;
  }
  /** same as currentObject */
  get eventObject() {
    return this.currentObject;
  }
  /** same as object */
  get srcElement() {
    return this.currentObject;
  }
  _pointer;
  get pointer() {
    return this._pointer == null && (Xe.copy(this.intersection.point).project(this.camera), this._pointer = new Vector2(Xe.x, Xe.y)), this._pointer;
  }
  _ray;
  get ray() {
    if (this._ray != null)
      return this._ray;
    switch (this.intersection.details.type) {
      case "screen-ray":
      case "ray":
      case "sphere":
        return this._ray = new Ray(this.intersection.pointerPosition, new Vector3(0, 0, -1).applyQuaternion(this.intersection.pointerQuaternion));
      case "lines":
        return this._ray = new Ray(this.intersection.details.line.start, this.intersection.details.line.end.clone().sub(this.intersection.details.line.start).normalize());
    }
  }
  _intersections = [];
  get intersections() {
    return this._intersections == null && (this._intersections = [{ ...this.intersection, eventObject: this.currentObject }]), this._intersections;
  }
  _unprojectedPoint;
  get unprojectedPoint() {
    if (this._unprojectedPoint == null) {
      const t = this.pointer;
      this._unprojectedPoint = new Vector3(t.x, t.y, 0).unproject(this.camera);
    }
    return this._unprojectedPoint;
  }
  get stopped() {
    return this.propagationState.stoppedImmediate || this.propagationState.stopped;
  }
  get stoppedImmediate() {
    return this.propagationState.stoppedImmediate;
  }
  get delta() {
    throw new Error("not supported");
  }
  constructor(t, n, r, o, i, s, a = i.object, u = a, l = {
    stopped: !n,
    stoppedImmediate: false
  }) {
    super(r), this.type = t, this.bubbles = n, this.internalPointer = o, this.intersection = i, this.camera = s, this.currentObject = a, this.object = u, this.propagationState = l;
  }
  stopPropagation() {
    this.propagationState.stopped = true;
  }
  stopImmediatePropagation() {
    this.propagationState.stoppedImmediate = true;
  }
  /**
   * for internal use
   */
  retarget(t) {
    return new _L(this.type, this.bubbles, this.nativeEvent, this.internalPointer, this.intersection, this.camera, t, this.target, this.propagationState);
  }
};
var Be = class _Be extends L {
  get deltaX() {
    return this.nativeEvent.deltaX;
  }
  get deltaY() {
    return this.nativeEvent.deltaY;
  }
  get deltaZ() {
    return this.nativeEvent.deltaZ;
  }
  constructor(t, n, r, o, i, s) {
    super("wheel", true, t, n, r, o, i, s);
  }
  /**
   * for internal use
   */
  retarget(t) {
    return new _Be(this.nativeEvent, this.internalPointer, this.intersection, this.camera, t, this.target);
  }
};
function N(e) {
  Vr(e, e.currentObject);
}
function Vr(e, t) {
  if (t == null)
    return;
  const n = as(t, e.type);
  if (n != null && n.length > 0) {
    const r = e.retarget(t), o = n.length;
    for (let i = 0; i < o && !r.stoppedImmediate; i++)
      n[i](r);
  }
  e.stopped || Vr(e, t.parent);
}
var Br = {
  click: "onClick",
  contextmenu: "onContextMenu",
  dblclick: "onDoubleClick",
  pointercancel: "onPointerCancel",
  pointerdown: "onPointerDown",
  pointerenter: "onPointerEnter",
  pointerleave: "onPointerLeave",
  pointermove: "onPointerMove",
  pointerout: "onPointerOut",
  pointerover: "onPointerOver",
  pointerup: "onPointerUp",
  wheel: "onWheel"
};
var ss = Object.keys(Br);
function as(e, t) {
  if (e._listeners != null && t in e._listeners)
    return e._listeners[t];
  let n;
  if (e.isVoidObject && t === "click" && e.parent?.__r3f != null && (n = e.parent.__r3f.root.getState().onPointerMissed), e.__r3f != null && (n = e.__r3f.handlers[Br[t]]), n != null)
    return [n];
}
var us = 1e10;
var ls = new SphereGeometry(us);
var rn = /* @__PURE__ */ new Map();
function Ur(e) {
  let t = rn.get(e);
  return t == null && (t = new Mesh(ls), t.isVoidObject = true, t.parent = e, t.pointerEventsOrder = -1 / 0, rn.set(e, t)), t;
}
function cs(e, t, n) {
  const r = t.normal ?? t.face?.normal;
  return r == null ? false : (e.setFromNormalAndCoplanarPoint(r, t.localPoint), e.applyMatrix4(n), true);
}
function fs(e, t, n) {
  if (t === "none" || t === "listener" && !e)
    return false;
  if (n === "all")
    return true;
  if (typeof n == "function")
    return ({ id: i, type: s, state: a }) => n(i, s, a);
  let r, o;
  return "deny" in n ? (o = true, r = n.deny) : (o = false, r = n.allow), Array.isArray(r) ? (i) => on(r.includes(i.type), o) : (i) => on(r === i.type, o);
}
function on(e, t) {
  return t ? !e : e;
}
function Hr(e, t, n, r = false, o, i, s) {
  const a = r || ds(e, t), u = t.pointerEvents ?? o, l = u ?? t.defaultPointerEvents ?? "listener", c = t.pointerEventsType ?? i ?? "all", f = t.pointerEventsOrder ?? s ?? 0, h2 = fs(a, l, c), d = n.length;
  if (d === 1)
    (h2 === true || typeof h2 == "function" && h2(n[0])) && Qe(n[0], t, l, c, f);
  else if (h2 === true)
    for (let p = 0; p < d; p++)
      Qe(n[p], t, l, c, f);
  else if (typeof h2 == "function")
    for (let p = 0; p < d; p++) {
      const g = n[p];
      h2(g) && Qe(g, t, l, c, f);
    }
  if (t.children.length === 0 || t.intersectChildren === false)
    return;
  const _ = t.interactableDescendants ?? t.children, v = _.length;
  for (let p = 0; p < v; p++)
    Hr(e, _[p], n, a, u, c, f);
}
function ds(e, t) {
  if (t.ancestorsHaveListeners || e === "pointer" && t.ancestorsHavePointerListeners || e === "wheel" && t.ancestorsHaveWheelListeners || t.__r3f != null && t.__r3f?.eventCount > 0 && (e === "wheel" && t.__r3f.handlers.onWheel != null || e === "pointer" && Object.keys(t.__r3f.handlers).some((o) => o != "onWheel")))
    return true;
  if (t._listeners == null)
    return false;
  if (e === "wheel") {
    const o = t._listeners.wheel;
    return o != null && o.length > 0;
  }
  const n = Object.entries(t._listeners), r = n.length;
  for (let o = 0; o < r; o++) {
    const i = n[o];
    if (i[0] !== "wheel" && ss.includes(i[0]) && i[1] != null && i[1].length > 0)
      return true;
  }
  return false;
}
function Qe({ intersector: e, options: t }, n, r, o, i) {
  t.filter?.(n, r, o, i) !== false && e.executeIntersection(n, i);
}
function ps(e, t, { customSort: n = hs } = {}, r) {
  let o, i, s;
  const a = e.length;
  for (let u = 0; u < a; u++) {
    const l = e[u], c = t?.[u];
    (o == null || n(l, c, o, i) < 0) && (s = u, o = l, i = c);
  }
  return s;
}
function hs(e, t = 0, n, r = 0) {
  return t != r ? r - t : e.distance - n.distance;
}
var sn = 1e7;
function _s(e, t, n, r, o, i = 0) {
  const s = t.direction.clone().multiplyScalar(sn), a = sn;
  return {
    distance: a + i,
    object: Ur(e),
    point: s,
    normal: t.origin.clone().sub(s).normalize(),
    details: n(s, a),
    pointerPosition: r,
    pointerQuaternion: o,
    pointOnFace: s,
    localPoint: s
  };
}
function ms(e, t, n) {
  for (; n > 0; )
    e.push(t), --n;
}
var Ze = Symbol("buttonsDownTime");
var gs = Symbol("buttonsClickTime");
globalThis.pointerEventspointerMap ??= /* @__PURE__ */ new Map();
Object3D.prototype.setPointerCapture = function(e) {
  St(e)?.setCapture(this);
};
Object3D.prototype.releasePointerCapture = function(e) {
  const t = St(e);
  t == null || !t.hasCaptured(this) || t.setCapture(void 0);
};
Object3D.prototype.hasPointerCapture = function(e) {
  return St(e)?.hasCaptured(this) ?? false;
};
function St(e) {
  return globalThis.pointerEventspointerMap?.get(e);
}
var Es = class {
  id;
  type;
  state;
  intersector;
  getCamera;
  onMoveCommited;
  parentSetPointerCapture;
  parentReleasePointerCapture;
  options;
  //state
  prevIntersection;
  intersection;
  prevEnabled = true;
  enabled = true;
  wheelIntersection;
  //derived state
  /**
   * ordered leaf -> root (bottom -> top)
   */
  pointerEntered = [];
  pointerEnteredHelper = [];
  pointerCapture;
  buttonsDownTime = /* @__PURE__ */ new Map();
  buttonsDown = /* @__PURE__ */ new Set();
  //to handle interaction before first move (after exit)
  wasMoved = false;
  onFirstMove = [];
  constructor(t, n, r, o, i, s, a, u, l = {}) {
    this.id = t, this.type = n, this.state = r, this.intersector = o, this.getCamera = i, this.onMoveCommited = s, this.parentSetPointerCapture = a, this.parentReleasePointerCapture = u, this.options = l, globalThis.pointerEventspointerMap?.set(t, this);
  }
  getPointerCapture() {
    return this.pointerCapture;
  }
  hasCaptured(t) {
    return this.pointerCapture?.object === t;
  }
  setCapture(t) {
    this.pointerCapture?.object !== t && (this.pointerCapture != null && (this.parentReleasePointerCapture?.(), this.pointerCapture = void 0), t != null && this.intersection != null && (this.pointerCapture = { object: t, intersection: this.intersection }, this.parentSetPointerCapture?.()));
  }
  getButtonsDown() {
    return this.buttonsDown;
  }
  /**
   * @returns undefined if no intersection was executed yet
   */
  getIntersection() {
    return this.intersection;
  }
  getEnabled() {
    return this.enabled;
  }
  setEnabled(t, n, r = true) {
    this.enabled !== t && (!t && this.pointerCapture != null && (this.parentReleasePointerCapture?.(), this.pointerCapture = void 0), this.enabled = t, r && this.commit(n, false));
  }
  computeIntersection(t, n, r) {
    return this.pointerCapture != null ? this.intersector.intersectPointerCapture(this.pointerCapture, r) : (this.intersector.startIntersection(r), Hr(t, n, [this]), this.intersector.finalizeIntersection(n));
  }
  setIntersection(t) {
    this.intersection = t;
  }
  commit(t, n) {
    const r = this.getCamera(), o = this.prevEnabled ? this.prevIntersection : void 0, i = this.enabled ? this.intersection : void 0;
    o != null && o.object != i?.object && N(new L("pointerout", true, t, this, o, r));
    const s = this.pointerEntered;
    this.pointerEntered = [], this.pointerEnteredHelper.length = 0, jr(i?.object, this.pointerEntered, s, this.pointerEnteredHelper);
    const a = s.length;
    for (let u = 0; u < a; u++) {
      const l = s[u];
      N(new L("pointerleave", false, t, this, o, r, l));
    }
    i != null && o?.object != i.object && N(new L("pointerover", true, t, this, i, r));
    for (let u = this.pointerEnteredHelper.length - 1; u >= 0; u--) {
      const l = this.pointerEnteredHelper[u];
      N(new L("pointerenter", false, t, this, i, r, l));
    }
    if (n && i != null && N(new L("pointermove", true, t, this, i, r)), this.prevIntersection = this.intersection, this.prevEnabled = this.enabled, !this.wasMoved && this.intersector.isReady()) {
      this.wasMoved = true;
      const u = this.onFirstMove.length;
      for (let l = 0; l < u; l++)
        this.onFirstMove[l](r);
      this.onFirstMove.length = 0;
    }
    this.onMoveCommited?.(this);
  }
  /**
   * computes and commits a move
   */
  move(t, n) {
    this.intersection = this.computeIntersection("pointer", t, n), this.commit(n, true);
  }
  /**
   * emits a move without (re-)computing the intersection
   * just emitting a move event to the current intersection
   */
  emitMove(t) {
    this.intersection != null && N(new L("pointermove", true, t, this, this.intersection, this.getCamera()));
  }
  down(t) {
    if (this.buttonsDown.add(t.button), !this.enabled)
      return;
    if (!this.wasMoved) {
      this.onFirstMove.push(this.down.bind(this, t));
      return;
    }
    if (this.intersection == null)
      return;
    N(new L("pointerdown", true, t, this, this.intersection, this.getCamera()));
    const { object: n } = this.intersection;
    n[Ze] ??= /* @__PURE__ */ new Map(), n[Ze].set(t.button, t.timeStamp), this.buttonsDownTime.set(t.button, t.timeStamp);
  }
  up(t) {
    if (this.buttonsDown.delete(t.button), !this.enabled)
      return;
    if (!this.wasMoved) {
      this.onFirstMove.push(this.up.bind(this, t));
      return;
    }
    if (this.intersection == null)
      return;
    const { clickThesholdMs: n, contextMenuButton: r = 2, dblClickThresholdMs: o = 500, clickThresholdMs: i = n ?? 300 } = this.options;
    this.pointerCapture = void 0;
    const s = vs(this.buttonsDownTime, this.intersection.object[Ze], t.button, t.timeStamp, i), a = this.getCamera();
    if (s && t.button === r && N(new L("contextmenu", true, t, this, this.intersection, a)), N(new L("pointerup", true, t, this, this.intersection, a)), !s || t.button === r)
      return;
    N(new L("click", true, t, this, this.intersection, a));
    const { object: u } = this.intersection, l = u[gs] ??= /* @__PURE__ */ new Map(), c = l.get(t.button);
    if (c == null || t.timeStamp - c > o) {
      l.set(t.button, t.timeStamp);
      return;
    }
    N(new L("dblclick", true, t, this, this.intersection, a)), l.delete(t.button);
  }
  cancel(t) {
    if (this.enabled) {
      if (!this.wasMoved) {
        this.onFirstMove.push(this.cancel.bind(this, t));
        return;
      }
      this.intersection != null && N(new L("pointercancel", true, t, this, this.intersection, this.getCamera()));
    }
  }
  wheel(t, n, r = false) {
    if (!this.enabled)
      return;
    if (!this.wasMoved && r) {
      this.onFirstMove.push(this.wheel.bind(this, t, n, r));
      return;
    }
    r || (this.wheelIntersection = this.computeIntersection("wheel", t, n));
    const o = r ? this.intersection : this.wheelIntersection;
    o != null && N(new Be(n, this, o, this.getCamera()));
  }
  emitWheel(t, n = false) {
    if (!this.enabled)
      return;
    if (!this.wasMoved && n) {
      this.onFirstMove.push(this.emitWheel.bind(this, t, n));
      return;
    }
    const r = n ? this.intersection : this.wheelIntersection;
    r != null && N(new Be(t, this, r, this.getCamera()));
  }
  exit(t) {
    this.wasMoved && (this.pointerCapture != null && (this.parentReleasePointerCapture?.(), this.pointerCapture = void 0), this.intersection = void 0, this.commit(t, false)), this.onFirstMove.length = 0, this.wasMoved = false;
  }
};
function jr(e, t, n, r) {
  if (e == null)
    return;
  const o = n.indexOf(e);
  o != -1 ? n.splice(o, 1) : r.push(e), t.push(e), jr(e.parent, t, n, r);
}
function vs(e, t, n, r, o) {
  if (t == null)
    return false;
  const i = t.get(n);
  return !(i == null || r - i > o || i != e.get(n));
}
var he = new Triangle();
var Je = new Triangle();
var an = new Vector2();
var un = new Vector2();
var ln = new Vector2();
var et = new Vector3();
var ys = new Matrix4();
var Pe = new Vector3();
function Cs(e, t, n) {
  Pe.copy(t).applyMatrix4(ys.copy(n.matrixWorld).invert());
  const r = n.geometry.attributes.uv;
  if (r == null || !(r instanceof BufferAttribute))
    return false;
  let o;
  return bs(n, (i, s, a) => {
    n.getVertexPosition(i, he.a), n.getVertexPosition(s, he.b), n.getVertexPosition(a, he.c);
    const u = he.closestPointToPoint(Pe, et).distanceTo(Pe);
    o != null && u >= o || (o = u, Je.copy(he), an.fromBufferAttribute(r, i), un.fromBufferAttribute(r, s), ln.fromBufferAttribute(r, a));
  }), o == null ? false : (Je.closestPointToPoint(Pe, et), Je.getInterpolation(et, an, un, ln, e), true);
}
function bs(e, t) {
  const n = e.geometry.drawRange;
  if (e.geometry.index != null) {
    const s = e.geometry.index, a = Math.max(0, n.start), u = Math.min(s.count, n.start + n.count);
    for (let l = a; l < u; l += 3)
      t(s.getX(l), s.getX(l + 1), s.getX(l + 2));
    return;
  }
  const r = e.geometry.attributes.position;
  if (r == null)
    return;
  const o = Math.max(0, n.start), i = Math.min(r.count, n.start + n.count);
  for (let s = o; s < i; s += 3)
    t(s, s + 1, s + 2);
}
new Matrix4();
new Line3();
new Vector3();
new Plane();
new Ray();
new Vector2();
new Vector3(0, 0, 0), new Vector3(0, 0, 1);
var cn = new Matrix4();
var ws = new Vector3();
new Vector3(0, 0, -1);
new Plane();
var fn = new Vector2();
var As = new Vector3();
var Ts = class {
  prepareTransformation;
  options;
  raycaster = new Raycaster();
  cameraQuaternion = new Quaternion();
  fromPosition = new Vector3();
  fromQuaternion = new Quaternion();
  coords = new Vector2();
  viewPlane = new Plane();
  intersects = [];
  pointerEventsOrders = [];
  constructor(t, n) {
    this.prepareTransformation = t, this.options = n;
  }
  isReady() {
    return true;
  }
  intersectPointerCapture({ intersection: t, object: n }, r) {
    const o = t.details;
    if (o.type != "screen-ray")
      throw new Error(`unable to process a pointer capture of type "${t.details.type}" with a camera ray intersector`);
    if (!this.startIntersection(r))
      return t;
    this.viewPlane.constant -= o.distanceViewPlane;
    const i = this.raycaster.ray.intersectPlane(this.viewPlane, new Vector3());
    if (i == null)
      return t;
    t.object.updateWorldMatrix(true, false), cs(this.viewPlane, t, t.object.matrixWorld);
    let s = t.uv;
    return t.object instanceof Mesh && Cs(fn, i, t.object) && (s = fn.clone()), {
      ...t,
      details: {
        ...o,
        direction: this.raycaster.ray.direction.clone(),
        screenPoint: this.coords.clone()
      },
      uv: s,
      object: n,
      point: i,
      pointOnFace: i,
      pointerPosition: this.raycaster.ray.origin.clone(),
      pointerQuaternion: this.cameraQuaternion.clone()
    };
  }
  startIntersection(t) {
    const n = this.prepareTransformation(t, this.coords);
    return n == null ? false : (n.updateWorldMatrix(true, false), n.matrixWorld.decompose(this.fromPosition, this.fromQuaternion, ws), this.raycaster.setFromCamera(this.coords, n), this.viewPlane.setFromNormalAndCoplanarPoint(n.getWorldDirection(As), this.raycaster.ray.origin), true);
  }
  executeIntersection(t, n) {
    const r = this.intersects.length;
    t.raycast(this.raycaster, this.intersects), ms(this.pointerEventsOrders, n, this.intersects.length - r);
  }
  finalizeIntersection(t) {
    const n = this.fromPosition.clone(), r = this.cameraQuaternion.clone(), o = this.raycaster.ray.direction.clone(), i = ps(this.intersects, this.pointerEventsOrders, this.options), s = i == null ? void 0 : this.intersects[i];
    return this.intersects.length = 0, this.pointerEventsOrders.length = 0, s == null ? _s(t, this.raycaster.ray, (a, u) => ({
      type: "screen-ray",
      distanceViewPlane: u,
      screenPoint: this.coords.clone(),
      direction: o
    }), n, r) : (s.object.updateWorldMatrix(true, false), cn.copy(s.object.matrixWorld).invert(), Object.assign(s, {
      details: {
        type: "screen-ray",
        distanceViewPlane: this.viewPlane.distanceToPoint(s.point),
        screenPoint: this.coords.clone(),
        direction: o
      },
      pointOnFace: s.point,
      pointerPosition: n,
      pointerQuaternion: r,
      localPoint: s.point.clone().applyMatrix4(cn)
    }));
  }
};
new Vector3();
new Vector2();
new Matrix4();
new Vector3();
new Quaternion();
new Plane();
new Sphere();
new Vector3();
new Vector3();
new Vector3();
new Vector3(1e-4, 1e-4, 1e-4);
new Matrix4();
var Os = 23412;
function Ss() {
  return Os++;
}
function Ps(e, t, n) {
  if (!(t instanceof globalThis.MouseEvent))
    return n.set(0, 0);
  const { width: r, height: o, top: i, left: s } = e.getBoundingClientRect(), a = t.clientX - s, u = t.clientY - i;
  return n.set(a / r * 2 - 1, -(u / o) * 2 + 1);
}
function Is(e, t, n, r) {
  return Ds(
    e,
    //backwards compatibility
    typeof t == "function" ? t : () => t,
    n,
    Ps.bind(null, e),
    e.setPointerCapture.bind(e),
    (o) => {
      e.hasPointerCapture(o) && e.releasePointerCapture(o);
    },
    {
      pointerTypePrefix: "screen-",
      ...r
    }
  );
}
function Ds(e, t, n, r, o, i, s = {}) {
  const a = s?.forwardPointerCapture ?? true, u = /* @__PURE__ */ new Map(), l = s.pointerTypePrefix ?? "forward-", c = (O, T) => {
    let E = u.get(O.pointerId);
    return E != null || (E = new Es(Ss(), `${l}${O.pointerType}`, O.pointerState, new Ts((x, R) => (r(x, R), t()), s), t, void 0, a ? o.bind(null, O.pointerId) : void 0, a ? i.bind(null, O.pointerId) : void 0, s), T != "move" && T != "wheel" && (E.setIntersection(E.computeIntersection("pointer", n, O)), E.commit(O, false)), u.set(O.pointerId, E)), E;
  }, f = /* @__PURE__ */ new Map(), h2 = /* @__PURE__ */ new Map(), d = [], _ = [], v = (O, T, E) => {
    switch (O) {
      case "move":
        E.move(n, T);
        return;
      case "wheel":
        E.wheel(n, T);
        return;
      case "cancel":
        E.cancel(T);
        return;
      case "down":
        if (!dn(T))
          return;
        E.down(T);
        return;
      case "up":
        if (!dn(T))
          return;
        E.up(T);
        return;
      case "exit":
        h2.delete(E), f.delete(E), E.exit(T);
        return;
    }
  }, p = (O, T) => {
    const E = c(T, O);
    O === "move" && h2.set(E, T), O === "wheel" && f.set(E, T), s.batchEvents ?? true ? _.push({ type: O, event: T }) : v(O, T, E);
  }, g = p.bind(null, "move"), C = p.bind(null, "cancel"), b = p.bind(null, "down"), P = p.bind(null, "up"), M = p.bind(null, "wheel"), A = p.bind(null, "exit");
  return e.addEventListener("pointermove", g), e.addEventListener("pointercancel", C), e.addEventListener("pointerdown", b), e.addEventListener("pointerup", P), e.addEventListener("wheel", M), e.addEventListener("pointerleave", A), {
    destroy() {
      e.removeEventListener("pointermove", g), e.removeEventListener("pointercancel", C), e.removeEventListener("pointerdown", b), e.removeEventListener("pointerup", P), e.removeEventListener("wheel", M), e.removeEventListener("pointerleave", A), h2.clear(), f.clear();
    },
    update() {
      const O = _.length;
      for (let T = 0; T < O; T++) {
        const { type: E, event: x } = _[T], R = c(x, E);
        if (E === "move" && (d.push(R), h2.get(R) != x)) {
          R.emitMove(x);
          continue;
        }
        if (E === "wheel" && f.get(R) != x) {
          R.emitWheel(x);
          continue;
        }
        v(E, x, R);
      }
      if (_.length = 0, s.intersectEveryFrame ?? false)
        for (const [T, E] of h2.entries())
          d.includes(T) || T.move(n, E);
      d.length = 0;
    }
  };
}
function dn(e) {
  return e.button != null;
}
function ks({
  canvas: e,
  contextParts: { scene: t, camera: n, renderer: r }
}) {
  const { update: o, destroy: i } = Is(I(e), () => I(n.activeCamera), t.value), { off: s } = r.loop.onLoop(o);
  ie(i), ie(s);
  const a = Ur(t.value), u = createEventHook();
  return a.addEventListener("click", u.trigger), {
    onPointerMissed: u.on
  };
}
var xs = "useTres";
var [Rs, Ls] = createInjectionState(({
  scene: e,
  canvas: t,
  windowSize: n,
  rendererOptions: r
}) => {
  const o = it(e), i = os(n, t), s = Ji({ sizes: i }), a = rs(
    {
      scene: o,
      canvas: t,
      options: r,
      contextParts: { sizes: i, camera: s }
    }
  ), u = ks({
    canvas: t,
    contextParts: { scene: o, camera: s, renderer: a }
  }), l = {
    sizes: i,
    scene: o,
    camera: s,
    renderer: a,
    controls: Ae(null),
    extend: pt,
    events: u
  };
  return l.scene.value.__tres = {
    root: l
  }, l;
}, {
  injectionKey: "useTres"
});
var zr = () => {
  const e = Ls();
  if (!e)
    throw new Error(`useTresContext must be used together with useTresContextProvider.
 You probably tried to use it above or on the same level as a TresCanvas component.
 It should be used in child components of a TresCanvas instance.`);
  return e;
};
function Fs() {
  const { scene: e, renderer: t, camera: n, sizes: r, controls: o, extend: i, events: s } = zr();
  return {
    scene: e,
    renderer: t.instance,
    camera: n.activeCamera,
    sizes: r,
    controls: o,
    extend: i,
    events: s,
    invalidate: t.invalidate,
    advance: t.advance
  };
}
var _l = () => {
  const e = Fs(), { renderer: t } = zr(), n = nn(), r = nn();
  t.loop.onBeforeLoop((i) => {
    n.trigger({ ...e, ...i });
  }), t.loop.onLoop((i) => {
    r.trigger({ ...e, ...i });
  });
  const o = t.replaceRenderFunction;
  return {
    stop: t.loop.stop,
    start: t.loop.start,
    isActive: t.loop.isActive,
    onBeforeRender: n.on,
    onRender: r.on,
    render: o
  };
};
function Ms(e, t = {}, n = {}) {
  let r = e;
  const o = (a) => {
    r = a;
  };
  let i = new Proxy({}, {});
  const s = {
    has(a, u) {
      return u in t || u in r;
    },
    get(a, u, l) {
      return u in t ? t[u](r) : r[u];
    },
    set(a, u, l) {
      return n[u] ? n[u](l, r, i, o) : r[u] = l, true;
    }
  };
  return i = new Proxy({}, s), i;
}
var Ns = [
  "onClick",
  "onContextmenu",
  "onPointermove",
  "onPointerenter",
  "onPointerleave",
  "onPointerover",
  "onPointerout",
  "onDblclick",
  "onPointerdown",
  "onPointerup",
  "onPointercancel",
  "onLostpointercapture",
  "onWheel"
];
var Vs = {
  onClick: "click",
  onContextmenu: "contextmenu",
  onPointermove: "pointermove",
  onPointerenter: "pointerenter",
  onPointerleave: "pointerleave",
  onPointerover: "pointerover",
  onPointerout: "pointerout",
  onDblclick: "dblclick",
  onPointerdown: "pointerdown",
  onPointerup: "pointerup",
  onPointercancel: "pointercancel",
  onLostpointercapture: "lostpointercapture",
  onWheel: "wheel"
};
var pn = (e) => Ns.includes(e);
var Bs = (e) => {
  const t = e.scene.value;
  function n(c, f, h2, d) {
    if (d || (d = {}), d.args || (d.args = []), Vi(c))
      return null;
    c.includes("-") && (c = c.replace(/-([a-z])/g, (p, g) => g.toUpperCase()).replace(/^[a-z]/, (p) => p.toUpperCase()));
    let _ = c.replace("Tres", ""), v;
    if (c === "primitive") {
      (!Tt(d.object) || me(d.object)) && Jt(
        "Tres primitives need an 'object' prop, whose value is an object or shallowRef<object>"
      ), _ = d.object.type;
      const p = {};
      v = Ms(
        d.object,
        {
          object: (C) => C,
          isPrimitive: () => true,
          __tres: () => p
        },
        {
          object: (C, b, P, M) => {
            Qi(C, P, M, { patchProp: i, remove: o, insert: r }, e);
          },
          __tres: (C) => {
            Object.assign(p, C);
          }
        }
      );
    } else {
      const p = dt.value[_];
      p || Jt(
        `${_} is not defined on the THREE namespace. Use extend to add it to the catalog.`
      ), v = new p(...d.args);
    }
    return v ? (re(v) && (d?.position || v.position.set(3, 3, 3), d?.lookAt || v.lookAt(0, 0, 0)), v = X(v, {
      ...Gi(v) ? v.__tres : {},
      type: _,
      memoizedProps: d,
      primitive: c === "primitive",
      attach: d.attach
    }, e), v) : null;
  }
  function r(c, f) {
    if (!c)
      return;
    f = f || t;
    const h2 = c.__tres ? c : X(c, {}, e), d = f.__tres ? f : X(f, {}, e);
    c = se(h2), f = se(d), re(c) && e.camera?.registerCamera(c), h2.__tres.attach ? qi(d, h2, h2.__tres.attach) : lt(c) && lt(d) && (d.add(c), c.dispatchEvent({ type: "added" })), h2.__tres.parent = d, d.__tres.objects && !d.__tres.objects.includes(h2) && d.__tres.objects.push(h2);
  }
  function o(c, f) {
    if (!c)
      return;
    f = ut(f) ? "default" : f;
    const h2 = c.__tres?.dispose;
    ut(h2) || (h2 === null ? f = false : f = h2);
    const d = c.__tres?.primitive, _ = f === "default" ? !d : !!f;
    if (c.__tres && "objects" in c.__tres && [...c.__tres.objects].forEach((v) => o(v, f)), _ && c.children && [...c.children].forEach((v) => o(v, f)), Mr(c, e), Nr(c, e), _ && !Fr(c)) {
      if (Q(f))
        f(c);
      else if (Q(c.dispose))
        try {
          c.dispose();
        } catch {
        }
    }
    "__tres" in c && delete c.__tres;
  }
  function i(c, f, h2, d) {
    if (!c)
      return;
    let _ = c;
    const v = f;
    if (c.__tres && (c.__tres.memoizedProps[f] = d), f === "attach") {
      const b = c.__tres?.parent || c.parent;
      o(c), X(c, { attach: d }, e), b && r(c, b);
      return;
    }
    if (f === "dispose") {
      c.__tres || (c = X(c, {}, e)), c.__tres.dispose = d;
      return;
    }
    pn(f) && Q(d) && c.addEventListener(Vs[f], d);
    let p = Qt(v), g = _?.[p];
    if (v === "args") {
      const b = c, P = h2 ?? [], M = d ?? [], A = c.__tres?.type || c.type;
      if (A && P.length && !Or(P, M)) {
        const O = new dt.value[A](...d), T = Object.getOwnPropertyDescriptors(O);
        Object.entries(T).forEach(([E, x]) => {
          if (!(!x.writable && !x.set) && E in b)
            try {
              b[E] = O[E];
            } catch (R) {
              console.warn(`Could not set property ${E} on ${A}:`, R);
            }
        }), _ = b;
      }
      return;
    }
    if (_.type === "BufferGeometry") {
      if (v === "args")
        return;
      _.setAttribute(
        Qt(v),
        new BufferAttribute(...d)
      );
      return;
    }
    if (v.includes("-") && g === void 0) {
      const b = Ve(_, v);
      if (g = b.target, _ = b.target, p = b.key, g && p) {
        g[p] = d, re(c) && c.updateProjectionMatrix(), ft(c);
        return;
      }
    }
    let C = d;
    if (C === "" && (C = true), Q(g)) {
      pn(f) || (Array.isArray(C) ? c[p](...C) : c[p](C)), p.startsWith("on") && Q(C) && (_[p] = C);
      return;
    }
    Zt(g) && Zt(C) ? g.mask = C.mask : Dr(g) && ji(C) ? g.set(C) : zi(g) && $i(C) && g.constructor === C.constructor ? g.copy(C) : ct(g) && Array.isArray(C) ? "fromArray" in g && typeof g.fromArray == "function" ? g.fromArray(C) : g.set(...C) : ct(g) && typeof C == "number" ? "setScalar" in g && typeof g.setScalar == "function" ? g.setScalar(C) : g.set(C) : _[p] = C, re(c) && c.updateProjectionMatrix(), ft(c);
  }
  function s(c) {
    return c?.__tres?.parent || null;
  }
  function a(c) {
    const f = X(new Object3D(), { type: "Comment" }, e);
    return f.name = c, f;
  }
  function u(c) {
    const h2 = s(c)?.__tres?.objects || [], d = h2.indexOf(c);
    return d < 0 || d >= h2.length - 1 ? null : h2[d + 1];
  }
  const l = () => {
  };
  return {
    insert: r,
    remove: o,
    createElement: n,
    patchProp: i,
    parentNode: s,
    createText: l,
    createComment: a,
    setText: l,
    setElementText: l,
    nextSibling: u,
    querySelector: l,
    setScopeId: l,
    cloneNode: l,
    insertStaticContent: l
  };
};
var Us = ["asset-load"];
var Hs = class {
  subscribers = /* @__PURE__ */ new Set();
  messageQueue = [];
  maxQueueSize = 100;
  // Prevent memory leaks by limiting queue size
  /**
   * Send a message to devtools subscribers
   * If no subscribers are available, only queueable message types are queued
   */
  send(t, n) {
    const r = {
      type: t,
      data: n,
      timestamp: Date.now()
    };
    this.subscribers.size > 0 ? this.subscribers.forEach((o) => o(r)) : Us.includes(t) && this.queueMessage(r);
  }
  /**
   * Queue a message for later delivery
   */
  queueMessage(t) {
    this.messageQueue.push(t), this.messageQueue.length > this.maxQueueSize && this.messageQueue.shift();
  }
  /**
   * Flush all queued messages to current subscribers
   */
  flushQueue() {
    this.messageQueue.length === 0 || this.subscribers.size === 0 || (this.messageQueue.forEach((t) => {
      this.subscribers.forEach((n) => n(t));
    }), this.messageQueue = []);
  }
  /**
   * Subscribe to devtools messages
   * When a new subscriber is added, all queued messages (asset-load events) are immediately delivered
   */
  subscribe(t) {
    return this.subscribers.add(t), this.flushQueue(), () => {
      this.subscribers.delete(t);
    };
  }
  /**
   * Check if there are any subscribers
   */
  get hasSubscribers() {
    return this.subscribers.size > 0;
  }
  /**
   * Get the current queue size
   */
  get queueSize() {
    return this.messageQueue.length;
  }
  /**
   * Clear all queued messages
   */
  clearQueue() {
    this.messageQueue = [];
  }
};
var js = Object.create;
var $r = Object.defineProperty;
var zs = Object.getOwnPropertyDescriptor;
var Pt = Object.getOwnPropertyNames;
var $s = Object.getPrototypeOf;
var Ks = Object.prototype.hasOwnProperty;
var Ws = (e, t) => function() {
  return e && (t = (0, e[Pt(e)[0]])(e = 0)), t;
};
var Gs = (e, t) => function() {
  return t || (0, e[Pt(e)[0]])((t = { exports: {} }).exports, t), t.exports;
};
var Ys = (e, t, n, r) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let o of Pt(t))
      !Ks.call(e, o) && o !== n && $r(e, o, { get: () => t[o], enumerable: !(r = zs(t, o)) || r.enumerable });
  return e;
};
var qs = (e, t, n) => (n = e != null ? js($s(e)) : {}, Ys(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  $r(n, "default", { value: e, enumerable: true }),
  e
));
var Oe = Ws({
  "../../node_modules/.pnpm/tsup@8.4.0_@microsoft+api-extractor@7.51.1_@types+node@22.13.14__jiti@2.4.2_postcss@8.5_96eb05a9d65343021e53791dd83f3773/node_modules/tsup/assets/esm_shims.js"() {
  }
});
var Xs = Gs({
  "../../node_modules/.pnpm/rfdc@1.4.1/node_modules/rfdc/index.js"(e, t) {
    Oe(), t.exports = r;
    function n(i) {
      return i instanceof Buffer ? Buffer.from(i) : new i.constructor(i.buffer.slice(), i.byteOffset, i.length);
    }
    function r(i) {
      if (i = i || {}, i.circles) return o(i);
      const s = /* @__PURE__ */ new Map();
      if (s.set(Date, (f) => new Date(f)), s.set(Map, (f, h2) => new Map(u(Array.from(f), h2))), s.set(Set, (f, h2) => new Set(u(Array.from(f), h2))), i.constructorHandlers)
        for (const f of i.constructorHandlers)
          s.set(f[0], f[1]);
      let a = null;
      return i.proto ? c : l;
      function u(f, h2) {
        const d = Object.keys(f), _ = new Array(d.length);
        for (let v = 0; v < d.length; v++) {
          const p = d[v], g = f[p];
          typeof g != "object" || g === null ? _[p] = g : g.constructor !== Object && (a = s.get(g.constructor)) ? _[p] = a(g, h2) : ArrayBuffer.isView(g) ? _[p] = n(g) : _[p] = h2(g);
        }
        return _;
      }
      function l(f) {
        if (typeof f != "object" || f === null) return f;
        if (Array.isArray(f)) return u(f, l);
        if (f.constructor !== Object && (a = s.get(f.constructor)))
          return a(f, l);
        const h2 = {};
        for (const d in f) {
          if (Object.hasOwnProperty.call(f, d) === false) continue;
          const _ = f[d];
          typeof _ != "object" || _ === null ? h2[d] = _ : _.constructor !== Object && (a = s.get(_.constructor)) ? h2[d] = a(_, l) : ArrayBuffer.isView(_) ? h2[d] = n(_) : h2[d] = l(_);
        }
        return h2;
      }
      function c(f) {
        if (typeof f != "object" || f === null) return f;
        if (Array.isArray(f)) return u(f, c);
        if (f.constructor !== Object && (a = s.get(f.constructor)))
          return a(f, c);
        const h2 = {};
        for (const d in f) {
          const _ = f[d];
          typeof _ != "object" || _ === null ? h2[d] = _ : _.constructor !== Object && (a = s.get(_.constructor)) ? h2[d] = a(_, c) : ArrayBuffer.isView(_) ? h2[d] = n(_) : h2[d] = c(_);
        }
        return h2;
      }
    }
    function o(i) {
      const s = [], a = [], u = /* @__PURE__ */ new Map();
      if (u.set(Date, (d) => new Date(d)), u.set(Map, (d, _) => new Map(c(Array.from(d), _))), u.set(Set, (d, _) => new Set(c(Array.from(d), _))), i.constructorHandlers)
        for (const d of i.constructorHandlers)
          u.set(d[0], d[1]);
      let l = null;
      return i.proto ? h2 : f;
      function c(d, _) {
        const v = Object.keys(d), p = new Array(v.length);
        for (let g = 0; g < v.length; g++) {
          const C = v[g], b = d[C];
          if (typeof b != "object" || b === null)
            p[C] = b;
          else if (b.constructor !== Object && (l = u.get(b.constructor)))
            p[C] = l(b, _);
          else if (ArrayBuffer.isView(b))
            p[C] = n(b);
          else {
            const P = s.indexOf(b);
            P !== -1 ? p[C] = a[P] : p[C] = _(b);
          }
        }
        return p;
      }
      function f(d) {
        if (typeof d != "object" || d === null) return d;
        if (Array.isArray(d)) return c(d, f);
        if (d.constructor !== Object && (l = u.get(d.constructor)))
          return l(d, f);
        const _ = {};
        s.push(d), a.push(_);
        for (const v in d) {
          if (Object.hasOwnProperty.call(d, v) === false) continue;
          const p = d[v];
          if (typeof p != "object" || p === null)
            _[v] = p;
          else if (p.constructor !== Object && (l = u.get(p.constructor)))
            _[v] = l(p, f);
          else if (ArrayBuffer.isView(p))
            _[v] = n(p);
          else {
            const g = s.indexOf(p);
            g !== -1 ? _[v] = a[g] : _[v] = f(p);
          }
        }
        return s.pop(), a.pop(), _;
      }
      function h2(d) {
        if (typeof d != "object" || d === null) return d;
        if (Array.isArray(d)) return c(d, h2);
        if (d.constructor !== Object && (l = u.get(d.constructor)))
          return l(d, h2);
        const _ = {};
        s.push(d), a.push(_);
        for (const v in d) {
          const p = d[v];
          if (typeof p != "object" || p === null)
            _[v] = p;
          else if (p.constructor !== Object && (l = u.get(p.constructor)))
            _[v] = l(p, h2);
          else if (ArrayBuffer.isView(p))
            _[v] = n(p);
          else {
            const g = s.indexOf(p);
            g !== -1 ? _[v] = a[g] : _[v] = h2(p);
          }
        }
        return s.pop(), a.pop(), _;
      }
    }
  }
});
Oe();
Oe();
Oe();
var Kr = typeof navigator < "u";
var y = typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : {};
typeof y.chrome < "u" && y.chrome.devtools;
Kr && (y.self, y.top);
var hn;
typeof navigator < "u" && ((hn = navigator.userAgent) == null || hn.toLowerCase().includes("electron"));
Oe();
var Qs = qs(Xs());
var Zs = /(?:^|[-_/])(\w)/g;
function Js(e, t) {
  return t ? t.toUpperCase() : "";
}
function ea(e) {
  return e && `${e}`.replace(Zs, Js);
}
function ta(e, t) {
  let n = e.replace(/^[a-z]:/i, "").replace(/\\/g, "/");
  n.endsWith(`index${t}`) && (n = n.replace(`/index${t}`, t));
  const r = n.lastIndexOf("/"), o = n.substring(r + 1);
  {
    const i = o.lastIndexOf(t);
    return o.substring(0, i);
  }
}
var _n = (0, Qs.default)({ circles: true });
var na = {
  trailing: true
};
function ae(e, t = 25, n = {}) {
  if (n = { ...na, ...n }, !Number.isFinite(t))
    throw new TypeError("Expected `wait` to be a finite number");
  let r, o, i = [], s, a;
  const u = (l, c) => (s = ra(e, l, c), s.finally(() => {
    if (s = null, n.trailing && a && !o) {
      const f = u(l, a);
      return a = null, f;
    }
  }), s);
  return function(...l) {
    return s ? (n.trailing && (a = l), s) : new Promise((c) => {
      const f = !o && n.leading;
      clearTimeout(o), o = setTimeout(() => {
        o = null;
        const h2 = n.leading ? r : u(this, l);
        for (const d of i)
          d(h2);
        i = [];
      }, t), f ? (r = u(this, l), c(r)) : i.push(c);
    });
  };
}
async function ra(e, t, n) {
  return await e.apply(t, n);
}
function ht(e, t = {}, n) {
  for (const r in e) {
    const o = e[r], i = n ? `${n}:${r}` : r;
    typeof o == "object" && o !== null ? ht(o, t, i) : typeof o == "function" && (t[i] = o);
  }
  return t;
}
var oa = { run: (e) => e() };
var ia = () => oa;
var Wr = typeof console.createTask < "u" ? console.createTask : ia;
function sa(e, t) {
  const n = t.shift(), r = Wr(n);
  return e.reduce(
    (o, i) => o.then(() => r.run(() => i(...t))),
    Promise.resolve()
  );
}
function aa(e, t) {
  const n = t.shift(), r = Wr(n);
  return Promise.all(e.map((o) => r.run(() => o(...t))));
}
function tt(e, t) {
  for (const n of [...e])
    n(t);
}
var ua = class {
  constructor() {
    this._hooks = {}, this._before = void 0, this._after = void 0, this._deprecatedMessages = void 0, this._deprecatedHooks = {}, this.hook = this.hook.bind(this), this.callHook = this.callHook.bind(this), this.callHookWith = this.callHookWith.bind(this);
  }
  hook(t, n, r = {}) {
    if (!t || typeof n != "function")
      return () => {
      };
    const o = t;
    let i;
    for (; this._deprecatedHooks[t]; )
      i = this._deprecatedHooks[t], t = i.to;
    if (i && !r.allowDeprecated) {
      let s = i.message;
      s || (s = `${o} hook has been deprecated` + (i.to ? `, please use ${i.to}` : "")), this._deprecatedMessages || (this._deprecatedMessages = /* @__PURE__ */ new Set()), this._deprecatedMessages.has(s) || (console.warn(s), this._deprecatedMessages.add(s));
    }
    if (!n.name)
      try {
        Object.defineProperty(n, "name", {
          get: () => "_" + t.replace(/\W+/g, "_") + "_hook_cb",
          configurable: true
        });
      } catch {
      }
    return this._hooks[t] = this._hooks[t] || [], this._hooks[t].push(n), () => {
      n && (this.removeHook(t, n), n = void 0);
    };
  }
  hookOnce(t, n) {
    let r, o = (...i) => (typeof r == "function" && r(), r = void 0, o = void 0, n(...i));
    return r = this.hook(t, o), r;
  }
  removeHook(t, n) {
    if (this._hooks[t]) {
      const r = this._hooks[t].indexOf(n);
      r !== -1 && this._hooks[t].splice(r, 1), this._hooks[t].length === 0 && delete this._hooks[t];
    }
  }
  deprecateHook(t, n) {
    this._deprecatedHooks[t] = typeof n == "string" ? { to: n } : n;
    const r = this._hooks[t] || [];
    delete this._hooks[t];
    for (const o of r)
      this.hook(t, o);
  }
  deprecateHooks(t) {
    Object.assign(this._deprecatedHooks, t);
    for (const n in t)
      this.deprecateHook(n, t[n]);
  }
  addHooks(t) {
    const n = ht(t), r = Object.keys(n).map(
      (o) => this.hook(o, n[o])
    );
    return () => {
      for (const o of r.splice(0, r.length))
        o();
    };
  }
  removeHooks(t) {
    const n = ht(t);
    for (const r in n)
      this.removeHook(r, n[r]);
  }
  removeAllHooks() {
    for (const t in this._hooks)
      delete this._hooks[t];
  }
  callHook(t, ...n) {
    return n.unshift(t), this.callHookWith(sa, t, ...n);
  }
  callHookParallel(t, ...n) {
    return n.unshift(t), this.callHookWith(aa, t, ...n);
  }
  callHookWith(t, n, ...r) {
    const o = this._before || this._after ? { name: n, args: r, context: {} } : void 0;
    this._before && tt(this._before, o);
    const i = t(
      n in this._hooks ? [...this._hooks[n]] : [],
      r
    );
    return i instanceof Promise ? i.finally(() => {
      this._after && o && tt(this._after, o);
    }) : (this._after && o && tt(this._after, o), i);
  }
  beforeEach(t) {
    return this._before = this._before || [], this._before.push(t), () => {
      if (this._before !== void 0) {
        const n = this._before.indexOf(t);
        n !== -1 && this._before.splice(n, 1);
      }
    };
  }
  afterEach(t) {
    return this._after = this._after || [], this._after.push(t), () => {
      if (this._after !== void 0) {
        const n = this._after.indexOf(t);
        n !== -1 && this._after.splice(n, 1);
      }
    };
  }
};
function Gr() {
  return new ua();
}
var la = Object.create;
var Yr = Object.defineProperty;
var ca = Object.getOwnPropertyDescriptor;
var It = Object.getOwnPropertyNames;
var fa = Object.getPrototypeOf;
var da = Object.prototype.hasOwnProperty;
var pa = (e, t) => function() {
  return e && (t = (0, e[It(e)[0]])(e = 0)), t;
};
var qr = (e, t) => function() {
  return t || (0, e[It(e)[0]])((t = { exports: {} }).exports, t), t.exports;
};
var ha = (e, t, n, r) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let o of It(t))
      !da.call(e, o) && o !== n && Yr(e, o, { get: () => t[o], enumerable: !(r = ca(t, o)) || r.enumerable });
  return e;
};
var _a = (e, t, n) => (n = e != null ? la(fa(e)) : {}, ha(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  Yr(n, "default", { value: e, enumerable: true }),
  e
));
var m = pa({
  "../../node_modules/.pnpm/tsup@8.4.0_@microsoft+api-extractor@7.51.1_@types+node@22.13.14__jiti@2.4.2_postcss@8.5_96eb05a9d65343021e53791dd83f3773/node_modules/tsup/assets/esm_shims.js"() {
  }
});
var ma = qr({
  "../../node_modules/.pnpm/speakingurl@14.0.1/node_modules/speakingurl/lib/speakingurl.js"(e, t) {
    m(), (function(n) {
      var r = {
        // latin
        À: "A",
        Á: "A",
        Â: "A",
        Ã: "A",
        Ä: "Ae",
        Å: "A",
        Æ: "AE",
        Ç: "C",
        È: "E",
        É: "E",
        Ê: "E",
        Ë: "E",
        Ì: "I",
        Í: "I",
        Î: "I",
        Ï: "I",
        Ð: "D",
        Ñ: "N",
        Ò: "O",
        Ó: "O",
        Ô: "O",
        Õ: "O",
        Ö: "Oe",
        Ő: "O",
        Ø: "O",
        Ù: "U",
        Ú: "U",
        Û: "U",
        Ü: "Ue",
        Ű: "U",
        Ý: "Y",
        Þ: "TH",
        ß: "ss",
        à: "a",
        á: "a",
        â: "a",
        ã: "a",
        ä: "ae",
        å: "a",
        æ: "ae",
        ç: "c",
        è: "e",
        é: "e",
        ê: "e",
        ë: "e",
        ì: "i",
        í: "i",
        î: "i",
        ï: "i",
        ð: "d",
        ñ: "n",
        ò: "o",
        ó: "o",
        ô: "o",
        õ: "o",
        ö: "oe",
        ő: "o",
        ø: "o",
        ù: "u",
        ú: "u",
        û: "u",
        ü: "ue",
        ű: "u",
        ý: "y",
        þ: "th",
        ÿ: "y",
        "ẞ": "SS",
        // language specific
        // Arabic
        ا: "a",
        أ: "a",
        إ: "i",
        آ: "aa",
        ؤ: "u",
        ئ: "e",
        ء: "a",
        ب: "b",
        ت: "t",
        ث: "th",
        ج: "j",
        ح: "h",
        خ: "kh",
        د: "d",
        ذ: "th",
        ر: "r",
        ز: "z",
        س: "s",
        ش: "sh",
        ص: "s",
        ض: "dh",
        ط: "t",
        ظ: "z",
        ع: "a",
        غ: "gh",
        ف: "f",
        ق: "q",
        ك: "k",
        ل: "l",
        م: "m",
        ن: "n",
        ه: "h",
        و: "w",
        ي: "y",
        ى: "a",
        ة: "h",
        ﻻ: "la",
        ﻷ: "laa",
        ﻹ: "lai",
        ﻵ: "laa",
        // Persian additional characters than Arabic
        گ: "g",
        چ: "ch",
        پ: "p",
        ژ: "zh",
        ک: "k",
        ی: "y",
        // Arabic diactrics
        "َ": "a",
        "ً": "an",
        "ِ": "e",
        "ٍ": "en",
        "ُ": "u",
        "ٌ": "on",
        "ْ": "",
        // Arabic numbers
        "٠": "0",
        "١": "1",
        "٢": "2",
        "٣": "3",
        "٤": "4",
        "٥": "5",
        "٦": "6",
        "٧": "7",
        "٨": "8",
        "٩": "9",
        // Persian numbers
        "۰": "0",
        "۱": "1",
        "۲": "2",
        "۳": "3",
        "۴": "4",
        "۵": "5",
        "۶": "6",
        "۷": "7",
        "۸": "8",
        "۹": "9",
        // Burmese consonants
        က: "k",
        ခ: "kh",
        ဂ: "g",
        ဃ: "ga",
        င: "ng",
        စ: "s",
        ဆ: "sa",
        ဇ: "z",
        "စျ": "za",
        ည: "ny",
        ဋ: "t",
        ဌ: "ta",
        ဍ: "d",
        ဎ: "da",
        ဏ: "na",
        တ: "t",
        ထ: "ta",
        ဒ: "d",
        ဓ: "da",
        န: "n",
        ပ: "p",
        ဖ: "pa",
        ဗ: "b",
        ဘ: "ba",
        မ: "m",
        ယ: "y",
        ရ: "ya",
        လ: "l",
        ဝ: "w",
        သ: "th",
        ဟ: "h",
        ဠ: "la",
        အ: "a",
        // consonant character combos
        "ြ": "y",
        "ျ": "ya",
        "ွ": "w",
        "ြွ": "yw",
        "ျွ": "ywa",
        "ှ": "h",
        // independent vowels
        ဧ: "e",
        "၏": "-e",
        ဣ: "i",
        ဤ: "-i",
        ဉ: "u",
        ဦ: "-u",
        ဩ: "aw",
        "သြော": "aw",
        ဪ: "aw",
        // numbers
        "၀": "0",
        "၁": "1",
        "၂": "2",
        "၃": "3",
        "၄": "4",
        "၅": "5",
        "၆": "6",
        "၇": "7",
        "၈": "8",
        "၉": "9",
        // virama and tone marks which are silent in transliteration
        "္": "",
        "့": "",
        "း": "",
        // Czech
        č: "c",
        ď: "d",
        ě: "e",
        ň: "n",
        ř: "r",
        š: "s",
        ť: "t",
        ů: "u",
        ž: "z",
        Č: "C",
        Ď: "D",
        Ě: "E",
        Ň: "N",
        Ř: "R",
        Š: "S",
        Ť: "T",
        Ů: "U",
        Ž: "Z",
        // Dhivehi
        ހ: "h",
        ށ: "sh",
        ނ: "n",
        ރ: "r",
        ބ: "b",
        ޅ: "lh",
        ކ: "k",
        އ: "a",
        ވ: "v",
        މ: "m",
        ފ: "f",
        ދ: "dh",
        ތ: "th",
        ލ: "l",
        ގ: "g",
        ޏ: "gn",
        ސ: "s",
        ޑ: "d",
        ޒ: "z",
        ޓ: "t",
        ޔ: "y",
        ޕ: "p",
        ޖ: "j",
        ޗ: "ch",
        ޘ: "tt",
        ޙ: "hh",
        ޚ: "kh",
        ޛ: "th",
        ޜ: "z",
        ޝ: "sh",
        ޞ: "s",
        ޟ: "d",
        ޠ: "t",
        ޡ: "z",
        ޢ: "a",
        ޣ: "gh",
        ޤ: "q",
        ޥ: "w",
        "ަ": "a",
        "ާ": "aa",
        "ި": "i",
        "ީ": "ee",
        "ު": "u",
        "ޫ": "oo",
        "ެ": "e",
        "ޭ": "ey",
        "ޮ": "o",
        "ޯ": "oa",
        "ް": "",
        // Georgian https://en.wikipedia.org/wiki/Romanization_of_Georgian
        // National system (2002)
        ა: "a",
        ბ: "b",
        გ: "g",
        დ: "d",
        ე: "e",
        ვ: "v",
        ზ: "z",
        თ: "t",
        ი: "i",
        კ: "k",
        ლ: "l",
        მ: "m",
        ნ: "n",
        ო: "o",
        პ: "p",
        ჟ: "zh",
        რ: "r",
        ს: "s",
        ტ: "t",
        უ: "u",
        ფ: "p",
        ქ: "k",
        ღ: "gh",
        ყ: "q",
        შ: "sh",
        ჩ: "ch",
        ც: "ts",
        ძ: "dz",
        წ: "ts",
        ჭ: "ch",
        ხ: "kh",
        ჯ: "j",
        ჰ: "h",
        // Greek
        α: "a",
        β: "v",
        γ: "g",
        δ: "d",
        ε: "e",
        ζ: "z",
        η: "i",
        θ: "th",
        ι: "i",
        κ: "k",
        λ: "l",
        μ: "m",
        ν: "n",
        ξ: "ks",
        ο: "o",
        π: "p",
        ρ: "r",
        σ: "s",
        τ: "t",
        υ: "y",
        φ: "f",
        χ: "x",
        ψ: "ps",
        ω: "o",
        ά: "a",
        έ: "e",
        ί: "i",
        ό: "o",
        ύ: "y",
        ή: "i",
        ώ: "o",
        ς: "s",
        ϊ: "i",
        ΰ: "y",
        ϋ: "y",
        ΐ: "i",
        Α: "A",
        Β: "B",
        Γ: "G",
        Δ: "D",
        Ε: "E",
        Ζ: "Z",
        Η: "I",
        Θ: "TH",
        Ι: "I",
        Κ: "K",
        Λ: "L",
        Μ: "M",
        Ν: "N",
        Ξ: "KS",
        Ο: "O",
        Π: "P",
        Ρ: "R",
        Σ: "S",
        Τ: "T",
        Υ: "Y",
        Φ: "F",
        Χ: "X",
        Ψ: "PS",
        Ω: "O",
        Ά: "A",
        Έ: "E",
        Ί: "I",
        Ό: "O",
        Ύ: "Y",
        Ή: "I",
        Ώ: "O",
        Ϊ: "I",
        Ϋ: "Y",
        // Latvian
        ā: "a",
        // 'č': 'c', // duplicate
        ē: "e",
        ģ: "g",
        ī: "i",
        ķ: "k",
        ļ: "l",
        ņ: "n",
        // 'š': 's', // duplicate
        ū: "u",
        // 'ž': 'z', // duplicate
        Ā: "A",
        // 'Č': 'C', // duplicate
        Ē: "E",
        Ģ: "G",
        Ī: "I",
        Ķ: "k",
        Ļ: "L",
        Ņ: "N",
        // 'Š': 'S', // duplicate
        Ū: "U",
        // 'Ž': 'Z', // duplicate
        // Macedonian
        Ќ: "Kj",
        ќ: "kj",
        Љ: "Lj",
        љ: "lj",
        Њ: "Nj",
        њ: "nj",
        Тс: "Ts",
        тс: "ts",
        // Polish
        ą: "a",
        ć: "c",
        ę: "e",
        ł: "l",
        ń: "n",
        // 'ó': 'o', // duplicate
        ś: "s",
        ź: "z",
        ż: "z",
        Ą: "A",
        Ć: "C",
        Ę: "E",
        Ł: "L",
        Ń: "N",
        Ś: "S",
        Ź: "Z",
        Ż: "Z",
        // Ukranian
        Є: "Ye",
        І: "I",
        Ї: "Yi",
        Ґ: "G",
        є: "ye",
        і: "i",
        ї: "yi",
        ґ: "g",
        // Romanian
        ă: "a",
        Ă: "A",
        ș: "s",
        Ș: "S",
        // 'ş': 's', // duplicate
        // 'Ş': 'S', // duplicate
        ț: "t",
        Ț: "T",
        ţ: "t",
        Ţ: "T",
        // Russian https://en.wikipedia.org/wiki/Romanization_of_Russian
        // ICAO
        а: "a",
        б: "b",
        в: "v",
        г: "g",
        д: "d",
        е: "e",
        ё: "yo",
        ж: "zh",
        з: "z",
        и: "i",
        й: "i",
        к: "k",
        л: "l",
        м: "m",
        н: "n",
        о: "o",
        п: "p",
        р: "r",
        с: "s",
        т: "t",
        у: "u",
        ф: "f",
        х: "kh",
        ц: "c",
        ч: "ch",
        ш: "sh",
        щ: "sh",
        ъ: "",
        ы: "y",
        ь: "",
        э: "e",
        ю: "yu",
        я: "ya",
        А: "A",
        Б: "B",
        В: "V",
        Г: "G",
        Д: "D",
        Е: "E",
        Ё: "Yo",
        Ж: "Zh",
        З: "Z",
        И: "I",
        Й: "I",
        К: "K",
        Л: "L",
        М: "M",
        Н: "N",
        О: "O",
        П: "P",
        Р: "R",
        С: "S",
        Т: "T",
        У: "U",
        Ф: "F",
        Х: "Kh",
        Ц: "C",
        Ч: "Ch",
        Ш: "Sh",
        Щ: "Sh",
        Ъ: "",
        Ы: "Y",
        Ь: "",
        Э: "E",
        Ю: "Yu",
        Я: "Ya",
        // Serbian
        ђ: "dj",
        ј: "j",
        // 'љ': 'lj',  // duplicate
        // 'њ': 'nj', // duplicate
        ћ: "c",
        џ: "dz",
        Ђ: "Dj",
        Ј: "j",
        // 'Љ': 'Lj', // duplicate
        // 'Њ': 'Nj', // duplicate
        Ћ: "C",
        Џ: "Dz",
        // Slovak
        ľ: "l",
        ĺ: "l",
        ŕ: "r",
        Ľ: "L",
        Ĺ: "L",
        Ŕ: "R",
        // Turkish
        ş: "s",
        Ş: "S",
        ı: "i",
        İ: "I",
        // 'ç': 'c', // duplicate
        // 'Ç': 'C', // duplicate
        // 'ü': 'u', // duplicate, see langCharMap
        // 'Ü': 'U', // duplicate, see langCharMap
        // 'ö': 'o', // duplicate, see langCharMap
        // 'Ö': 'O', // duplicate, see langCharMap
        ğ: "g",
        Ğ: "G",
        // Vietnamese
        ả: "a",
        Ả: "A",
        ẳ: "a",
        Ẳ: "A",
        ẩ: "a",
        Ẩ: "A",
        đ: "d",
        Đ: "D",
        ẹ: "e",
        Ẹ: "E",
        ẽ: "e",
        Ẽ: "E",
        ẻ: "e",
        Ẻ: "E",
        ế: "e",
        Ế: "E",
        ề: "e",
        Ề: "E",
        ệ: "e",
        Ệ: "E",
        ễ: "e",
        Ễ: "E",
        ể: "e",
        Ể: "E",
        ỏ: "o",
        ọ: "o",
        Ọ: "o",
        ố: "o",
        Ố: "O",
        ồ: "o",
        Ồ: "O",
        ổ: "o",
        Ổ: "O",
        ộ: "o",
        Ộ: "O",
        ỗ: "o",
        Ỗ: "O",
        ơ: "o",
        Ơ: "O",
        ớ: "o",
        Ớ: "O",
        ờ: "o",
        Ờ: "O",
        ợ: "o",
        Ợ: "O",
        ỡ: "o",
        Ỡ: "O",
        Ở: "o",
        ở: "o",
        ị: "i",
        Ị: "I",
        ĩ: "i",
        Ĩ: "I",
        ỉ: "i",
        Ỉ: "i",
        ủ: "u",
        Ủ: "U",
        ụ: "u",
        Ụ: "U",
        ũ: "u",
        Ũ: "U",
        ư: "u",
        Ư: "U",
        ứ: "u",
        Ứ: "U",
        ừ: "u",
        Ừ: "U",
        ự: "u",
        Ự: "U",
        ữ: "u",
        Ữ: "U",
        ử: "u",
        Ử: "ư",
        ỷ: "y",
        Ỷ: "y",
        ỳ: "y",
        Ỳ: "Y",
        ỵ: "y",
        Ỵ: "Y",
        ỹ: "y",
        Ỹ: "Y",
        ạ: "a",
        Ạ: "A",
        ấ: "a",
        Ấ: "A",
        ầ: "a",
        Ầ: "A",
        ậ: "a",
        Ậ: "A",
        ẫ: "a",
        Ẫ: "A",
        // 'ă': 'a', // duplicate
        // 'Ă': 'A', // duplicate
        ắ: "a",
        Ắ: "A",
        ằ: "a",
        Ằ: "A",
        ặ: "a",
        Ặ: "A",
        ẵ: "a",
        Ẵ: "A",
        "⓪": "0",
        "①": "1",
        "②": "2",
        "③": "3",
        "④": "4",
        "⑤": "5",
        "⑥": "6",
        "⑦": "7",
        "⑧": "8",
        "⑨": "9",
        "⑩": "10",
        "⑪": "11",
        "⑫": "12",
        "⑬": "13",
        "⑭": "14",
        "⑮": "15",
        "⑯": "16",
        "⑰": "17",
        "⑱": "18",
        "⑲": "18",
        "⑳": "18",
        "⓵": "1",
        "⓶": "2",
        "⓷": "3",
        "⓸": "4",
        "⓹": "5",
        "⓺": "6",
        "⓻": "7",
        "⓼": "8",
        "⓽": "9",
        "⓾": "10",
        "⓿": "0",
        "⓫": "11",
        "⓬": "12",
        "⓭": "13",
        "⓮": "14",
        "⓯": "15",
        "⓰": "16",
        "⓱": "17",
        "⓲": "18",
        "⓳": "19",
        "⓴": "20",
        "Ⓐ": "A",
        "Ⓑ": "B",
        "Ⓒ": "C",
        "Ⓓ": "D",
        "Ⓔ": "E",
        "Ⓕ": "F",
        "Ⓖ": "G",
        "Ⓗ": "H",
        "Ⓘ": "I",
        "Ⓙ": "J",
        "Ⓚ": "K",
        "Ⓛ": "L",
        "Ⓜ": "M",
        "Ⓝ": "N",
        "Ⓞ": "O",
        "Ⓟ": "P",
        "Ⓠ": "Q",
        "Ⓡ": "R",
        "Ⓢ": "S",
        "Ⓣ": "T",
        "Ⓤ": "U",
        "Ⓥ": "V",
        "Ⓦ": "W",
        "Ⓧ": "X",
        "Ⓨ": "Y",
        "Ⓩ": "Z",
        "ⓐ": "a",
        "ⓑ": "b",
        "ⓒ": "c",
        "ⓓ": "d",
        "ⓔ": "e",
        "ⓕ": "f",
        "ⓖ": "g",
        "ⓗ": "h",
        "ⓘ": "i",
        "ⓙ": "j",
        "ⓚ": "k",
        "ⓛ": "l",
        "ⓜ": "m",
        "ⓝ": "n",
        "ⓞ": "o",
        "ⓟ": "p",
        "ⓠ": "q",
        "ⓡ": "r",
        "ⓢ": "s",
        "ⓣ": "t",
        "ⓤ": "u",
        "ⓦ": "v",
        "ⓥ": "w",
        "ⓧ": "x",
        "ⓨ": "y",
        "ⓩ": "z",
        // symbols
        "“": '"',
        "”": '"',
        "‘": "'",
        "’": "'",
        "∂": "d",
        ƒ: "f",
        "™": "(TM)",
        "©": "(C)",
        œ: "oe",
        Œ: "OE",
        "®": "(R)",
        "†": "+",
        "℠": "(SM)",
        "…": "...",
        "˚": "o",
        º: "o",
        ª: "a",
        "•": "*",
        "၊": ",",
        "။": ".",
        // currency
        $: "USD",
        "€": "EUR",
        "₢": "BRN",
        "₣": "FRF",
        "£": "GBP",
        "₤": "ITL",
        "₦": "NGN",
        "₧": "ESP",
        "₩": "KRW",
        "₪": "ILS",
        "₫": "VND",
        "₭": "LAK",
        "₮": "MNT",
        "₯": "GRD",
        "₱": "ARS",
        "₲": "PYG",
        "₳": "ARA",
        "₴": "UAH",
        "₵": "GHS",
        "¢": "cent",
        "¥": "CNY",
        元: "CNY",
        円: "YEN",
        "﷼": "IRR",
        "₠": "EWE",
        "฿": "THB",
        "₨": "INR",
        "₹": "INR",
        "₰": "PF",
        "₺": "TRY",
        "؋": "AFN",
        "₼": "AZN",
        лв: "BGN",
        "៛": "KHR",
        "₡": "CRC",
        "₸": "KZT",
        ден: "MKD",
        zł: "PLN",
        "₽": "RUB",
        "₾": "GEL"
      }, o = [
        // burmese
        "်",
        // Dhivehi
        "ް"
      ], i = {
        // Burmese
        // dependent vowels
        "ာ": "a",
        "ါ": "a",
        "ေ": "e",
        "ဲ": "e",
        "ိ": "i",
        "ီ": "i",
        "ို": "o",
        "ု": "u",
        "ူ": "u",
        "ေါင်": "aung",
        "ော": "aw",
        "ော်": "aw",
        "ေါ": "aw",
        "ေါ်": "aw",
        "်": "်",
        // this is special case but the character will be converted to latin in the code
        "က်": "et",
        "ိုက်": "aik",
        "ောက်": "auk",
        "င်": "in",
        "ိုင်": "aing",
        "ောင်": "aung",
        "စ်": "it",
        "ည်": "i",
        "တ်": "at",
        "ိတ်": "eik",
        "ုတ်": "ok",
        "ွတ်": "ut",
        "ေတ်": "it",
        "ဒ်": "d",
        "ိုဒ်": "ok",
        "ုဒ်": "ait",
        "န်": "an",
        "ာန်": "an",
        "ိန်": "ein",
        "ုန်": "on",
        "ွန်": "un",
        "ပ်": "at",
        "ိပ်": "eik",
        "ုပ်": "ok",
        "ွပ်": "ut",
        "န်ုပ်": "nub",
        "မ်": "an",
        "ိမ်": "ein",
        "ုမ်": "on",
        "ွမ်": "un",
        "ယ်": "e",
        "ိုလ်": "ol",
        "ဉ်": "in",
        "ံ": "an",
        "ိံ": "ein",
        "ုံ": "on",
        // Dhivehi
        "ައް": "ah",
        "ަށް": "ah"
      }, s = {
        en: {},
        // default language
        az: {
          // Azerbaijani
          ç: "c",
          ə: "e",
          ğ: "g",
          ı: "i",
          ö: "o",
          ş: "s",
          ü: "u",
          Ç: "C",
          Ə: "E",
          Ğ: "G",
          İ: "I",
          Ö: "O",
          Ş: "S",
          Ü: "U"
        },
        cs: {
          // Czech
          č: "c",
          ď: "d",
          ě: "e",
          ň: "n",
          ř: "r",
          š: "s",
          ť: "t",
          ů: "u",
          ž: "z",
          Č: "C",
          Ď: "D",
          Ě: "E",
          Ň: "N",
          Ř: "R",
          Š: "S",
          Ť: "T",
          Ů: "U",
          Ž: "Z"
        },
        fi: {
          // Finnish
          // 'å': 'a', duplicate see charMap/latin
          // 'Å': 'A', duplicate see charMap/latin
          ä: "a",
          // ok
          Ä: "A",
          // ok
          ö: "o",
          // ok
          Ö: "O"
          // ok
        },
        hu: {
          // Hungarian
          ä: "a",
          // ok
          Ä: "A",
          // ok
          // 'á': 'a', duplicate see charMap/latin
          // 'Á': 'A', duplicate see charMap/latin
          ö: "o",
          // ok
          Ö: "O",
          // ok
          // 'ő': 'o', duplicate see charMap/latin
          // 'Ő': 'O', duplicate see charMap/latin
          ü: "u",
          Ü: "U",
          ű: "u",
          Ű: "U"
        },
        lt: {
          // Lithuanian
          ą: "a",
          č: "c",
          ę: "e",
          ė: "e",
          į: "i",
          š: "s",
          ų: "u",
          ū: "u",
          ž: "z",
          Ą: "A",
          Č: "C",
          Ę: "E",
          Ė: "E",
          Į: "I",
          Š: "S",
          Ų: "U",
          Ū: "U"
        },
        lv: {
          // Latvian
          ā: "a",
          č: "c",
          ē: "e",
          ģ: "g",
          ī: "i",
          ķ: "k",
          ļ: "l",
          ņ: "n",
          š: "s",
          ū: "u",
          ž: "z",
          Ā: "A",
          Č: "C",
          Ē: "E",
          Ģ: "G",
          Ī: "i",
          Ķ: "k",
          Ļ: "L",
          Ņ: "N",
          Š: "S",
          Ū: "u",
          Ž: "Z"
        },
        pl: {
          // Polish
          ą: "a",
          ć: "c",
          ę: "e",
          ł: "l",
          ń: "n",
          ó: "o",
          ś: "s",
          ź: "z",
          ż: "z",
          Ą: "A",
          Ć: "C",
          Ę: "e",
          Ł: "L",
          Ń: "N",
          Ó: "O",
          Ś: "S",
          Ź: "Z",
          Ż: "Z"
        },
        sv: {
          // Swedish
          // 'å': 'a', duplicate see charMap/latin
          // 'Å': 'A', duplicate see charMap/latin
          ä: "a",
          // ok
          Ä: "A",
          // ok
          ö: "o",
          // ok
          Ö: "O"
          // ok
        },
        sk: {
          // Slovak
          ä: "a",
          Ä: "A"
        },
        sr: {
          // Serbian
          љ: "lj",
          њ: "nj",
          Љ: "Lj",
          Њ: "Nj",
          đ: "dj",
          Đ: "Dj"
        },
        tr: {
          // Turkish
          Ü: "U",
          Ö: "O",
          ü: "u",
          ö: "o"
        }
      }, a = {
        ar: {
          "∆": "delta",
          "∞": "la-nihaya",
          "♥": "hob",
          "&": "wa",
          "|": "aw",
          "<": "aqal-men",
          ">": "akbar-men",
          "∑": "majmou",
          "¤": "omla"
        },
        az: {},
        ca: {
          "∆": "delta",
          "∞": "infinit",
          "♥": "amor",
          "&": "i",
          "|": "o",
          "<": "menys que",
          ">": "mes que",
          "∑": "suma dels",
          "¤": "moneda"
        },
        cs: {
          "∆": "delta",
          "∞": "nekonecno",
          "♥": "laska",
          "&": "a",
          "|": "nebo",
          "<": "mensi nez",
          ">": "vetsi nez",
          "∑": "soucet",
          "¤": "mena"
        },
        de: {
          "∆": "delta",
          "∞": "unendlich",
          "♥": "Liebe",
          "&": "und",
          "|": "oder",
          "<": "kleiner als",
          ">": "groesser als",
          "∑": "Summe von",
          "¤": "Waehrung"
        },
        dv: {
          "∆": "delta",
          "∞": "kolunulaa",
          "♥": "loabi",
          "&": "aai",
          "|": "noonee",
          "<": "ah vure kuda",
          ">": "ah vure bodu",
          "∑": "jumula",
          "¤": "faisaa"
        },
        en: {
          "∆": "delta",
          "∞": "infinity",
          "♥": "love",
          "&": "and",
          "|": "or",
          "<": "less than",
          ">": "greater than",
          "∑": "sum",
          "¤": "currency"
        },
        es: {
          "∆": "delta",
          "∞": "infinito",
          "♥": "amor",
          "&": "y",
          "|": "u",
          "<": "menos que",
          ">": "mas que",
          "∑": "suma de los",
          "¤": "moneda"
        },
        fa: {
          "∆": "delta",
          "∞": "bi-nahayat",
          "♥": "eshgh",
          "&": "va",
          "|": "ya",
          "<": "kamtar-az",
          ">": "bishtar-az",
          "∑": "majmooe",
          "¤": "vahed"
        },
        fi: {
          "∆": "delta",
          "∞": "aarettomyys",
          "♥": "rakkaus",
          "&": "ja",
          "|": "tai",
          "<": "pienempi kuin",
          ">": "suurempi kuin",
          "∑": "summa",
          "¤": "valuutta"
        },
        fr: {
          "∆": "delta",
          "∞": "infiniment",
          "♥": "Amour",
          "&": "et",
          "|": "ou",
          "<": "moins que",
          ">": "superieure a",
          "∑": "somme des",
          "¤": "monnaie"
        },
        ge: {
          "∆": "delta",
          "∞": "usasruloba",
          "♥": "siqvaruli",
          "&": "da",
          "|": "an",
          "<": "naklebi",
          ">": "meti",
          "∑": "jami",
          "¤": "valuta"
        },
        gr: {},
        hu: {
          "∆": "delta",
          "∞": "vegtelen",
          "♥": "szerelem",
          "&": "es",
          "|": "vagy",
          "<": "kisebb mint",
          ">": "nagyobb mint",
          "∑": "szumma",
          "¤": "penznem"
        },
        it: {
          "∆": "delta",
          "∞": "infinito",
          "♥": "amore",
          "&": "e",
          "|": "o",
          "<": "minore di",
          ">": "maggiore di",
          "∑": "somma",
          "¤": "moneta"
        },
        lt: {
          "∆": "delta",
          "∞": "begalybe",
          "♥": "meile",
          "&": "ir",
          "|": "ar",
          "<": "maziau nei",
          ">": "daugiau nei",
          "∑": "suma",
          "¤": "valiuta"
        },
        lv: {
          "∆": "delta",
          "∞": "bezgaliba",
          "♥": "milestiba",
          "&": "un",
          "|": "vai",
          "<": "mazak neka",
          ">": "lielaks neka",
          "∑": "summa",
          "¤": "valuta"
        },
        my: {
          "∆": "kwahkhyaet",
          "∞": "asaonasme",
          "♥": "akhyait",
          "&": "nhin",
          "|": "tho",
          "<": "ngethaw",
          ">": "kyithaw",
          "∑": "paungld",
          "¤": "ngwekye"
        },
        mk: {},
        nl: {
          "∆": "delta",
          "∞": "oneindig",
          "♥": "liefde",
          "&": "en",
          "|": "of",
          "<": "kleiner dan",
          ">": "groter dan",
          "∑": "som",
          "¤": "valuta"
        },
        pl: {
          "∆": "delta",
          "∞": "nieskonczonosc",
          "♥": "milosc",
          "&": "i",
          "|": "lub",
          "<": "mniejsze niz",
          ">": "wieksze niz",
          "∑": "suma",
          "¤": "waluta"
        },
        pt: {
          "∆": "delta",
          "∞": "infinito",
          "♥": "amor",
          "&": "e",
          "|": "ou",
          "<": "menor que",
          ">": "maior que",
          "∑": "soma",
          "¤": "moeda"
        },
        ro: {
          "∆": "delta",
          "∞": "infinit",
          "♥": "dragoste",
          "&": "si",
          "|": "sau",
          "<": "mai mic ca",
          ">": "mai mare ca",
          "∑": "suma",
          "¤": "valuta"
        },
        ru: {
          "∆": "delta",
          "∞": "beskonechno",
          "♥": "lubov",
          "&": "i",
          "|": "ili",
          "<": "menshe",
          ">": "bolshe",
          "∑": "summa",
          "¤": "valjuta"
        },
        sk: {
          "∆": "delta",
          "∞": "nekonecno",
          "♥": "laska",
          "&": "a",
          "|": "alebo",
          "<": "menej ako",
          ">": "viac ako",
          "∑": "sucet",
          "¤": "mena"
        },
        sr: {},
        tr: {
          "∆": "delta",
          "∞": "sonsuzluk",
          "♥": "ask",
          "&": "ve",
          "|": "veya",
          "<": "kucuktur",
          ">": "buyuktur",
          "∑": "toplam",
          "¤": "para birimi"
        },
        uk: {
          "∆": "delta",
          "∞": "bezkinechnist",
          "♥": "lubov",
          "&": "i",
          "|": "abo",
          "<": "menshe",
          ">": "bilshe",
          "∑": "suma",
          "¤": "valjuta"
        },
        vn: {
          "∆": "delta",
          "∞": "vo cuc",
          "♥": "yeu",
          "&": "va",
          "|": "hoac",
          "<": "nho hon",
          ">": "lon hon",
          "∑": "tong",
          "¤": "tien te"
        }
      }, u = [";", "?", ":", "@", "&", "=", "+", "$", ",", "/"].join(""), l = [";", "?", ":", "@", "&", "=", "+", "$", ","].join(""), c = [".", "!", "~", "*", "'", "(", ")"].join(""), f = function(p, g) {
        var C = "-", b = "", P = "", M = true, A = {}, O, T, E, x, R, Ut, de, te, Ht, z, w, Se, H, ne, K = "";
        if (typeof p != "string")
          return "";
        if (typeof g == "string" && (C = g), de = a.en, te = s.en, typeof g == "object") {
          O = g.maintainCase || false, A = g.custom && typeof g.custom == "object" ? g.custom : A, E = +g.truncate > 1 && g.truncate || false, x = g.uric || false, R = g.uricNoSlash || false, Ut = g.mark || false, M = !(g.symbols === false || g.lang === false), C = g.separator || C, x && (K += u), R && (K += l), Ut && (K += c), de = g.lang && a[g.lang] && M ? a[g.lang] : M ? a.en : {}, te = g.lang && s[g.lang] ? s[g.lang] : g.lang === false || g.lang === true ? {} : s.en, g.titleCase && typeof g.titleCase.length == "number" && Array.prototype.toString.call(g.titleCase) ? (g.titleCase.forEach(function(U) {
            A[U + ""] = U + "";
          }), T = true) : T = !!g.titleCase, g.custom && typeof g.custom.length == "number" && Array.prototype.toString.call(g.custom) && g.custom.forEach(function(U) {
            A[U + ""] = U + "";
          }), Object.keys(A).forEach(function(U) {
            var pe;
            U.length > 1 ? pe = new RegExp("\\b" + d(U) + "\\b", "gi") : pe = new RegExp(d(U), "gi"), p = p.replace(pe, A[U]);
          });
          for (w in A)
            K += w;
        }
        for (K += C, K = d(K), p = p.replace(/(^\s+|\s+$)/g, ""), H = false, ne = false, z = 0, Se = p.length; z < Se; z++)
          w = p[z], _(w, A) ? H = false : te[w] ? (w = H && te[w].match(/[A-Za-z0-9]/) ? " " + te[w] : te[w], H = false) : w in r ? (z + 1 < Se && o.indexOf(p[z + 1]) >= 0 ? (P += w, w = "") : ne === true ? (w = i[P] + r[w], P = "") : w = H && r[w].match(/[A-Za-z0-9]/) ? " " + r[w] : r[w], H = false, ne = false) : w in i ? (P += w, w = "", z === Se - 1 && (w = i[P]), ne = true) : (
            /* process symbol chars */
            de[w] && !(x && u.indexOf(w) !== -1) && !(R && l.indexOf(w) !== -1) ? (w = H || b.substr(-1).match(/[A-Za-z0-9]/) ? C + de[w] : de[w], w += p[z + 1] !== void 0 && p[z + 1].match(/[A-Za-z0-9]/) ? C : "", H = true) : (ne === true ? (w = i[P] + w, P = "", ne = false) : H && (/[A-Za-z0-9]/.test(w) || b.substr(-1).match(/A-Za-z0-9]/)) && (w = " " + w), H = false)
          ), b += w.replace(new RegExp("[^\\w\\s" + K + "_-]", "g"), C);
        return T && (b = b.replace(/(\w)(\S*)/g, function(U, pe, jt) {
          var Ye = pe.toUpperCase() + (jt !== null ? jt : "");
          return Object.keys(A).indexOf(Ye.toLowerCase()) < 0 ? Ye : Ye.toLowerCase();
        })), b = b.replace(/\s+/g, C).replace(new RegExp("\\" + C + "+", "g"), C).replace(new RegExp("(^\\" + C + "+|\\" + C + "+$)", "g"), ""), E && b.length > E && (Ht = b.charAt(E) === C, b = b.slice(0, E), Ht || (b = b.slice(0, b.lastIndexOf(C)))), !O && !T && (b = b.toLowerCase()), b;
      }, h2 = function(p) {
        return function(C) {
          return f(C, p);
        };
      }, d = function(p) {
        return p.replace(/[-\\^$*+?.()|[\]{}\/]/g, "\\$&");
      }, _ = function(v, p) {
        for (var g in p)
          if (p[g] === v)
            return true;
      };
      if (typeof t < "u" && t.exports)
        t.exports = f, t.exports.createSlug = h2;
      else if (typeof define < "u" && define.amd)
        define([], function() {
          return f;
        });
      else
        try {
          if (n.getSlug || n.createSlug)
            throw "speakingurl: globals exists /(getSlug|createSlug)/";
          n.getSlug = f, n.createSlug = h2;
        } catch {
        }
    })(e);
  }
});
var ga = qr({
  "../../node_modules/.pnpm/speakingurl@14.0.1/node_modules/speakingurl/index.js"(e, t) {
    m(), t.exports = ma();
  }
});
m();
m();
m();
m();
m();
m();
m();
m();
function Ea(e) {
  var t;
  const n = e.name || e._componentTag || e.__VUE_DEVTOOLS_COMPONENT_GUSSED_NAME__ || e.__name;
  return n === "index" && ((t = e.__file) != null && t.endsWith("index.vue")) ? "" : n;
}
function va(e) {
  const t = e.__file;
  if (t)
    return ea(ta(t, ".vue"));
}
function mn(e, t) {
  return e.type.__VUE_DEVTOOLS_COMPONENT_GUSSED_NAME__ = t, t;
}
function Dt(e) {
  if (e.__VUE_DEVTOOLS_NEXT_APP_RECORD__)
    return e.__VUE_DEVTOOLS_NEXT_APP_RECORD__;
  if (e.root)
    return e.appContext.app.__VUE_DEVTOOLS_NEXT_APP_RECORD__;
}
function Xr(e) {
  var t, n;
  const r = (t = e.subTree) == null ? void 0 : t.type, o = Dt(e);
  return o ? ((n = o?.types) == null ? void 0 : n.Fragment) === r : false;
}
function Ke(e) {
  var t, n, r;
  const o = Ea(e?.type || {});
  if (o)
    return o;
  if (e?.root === e)
    return "Root";
  for (const s in (n = (t = e.parent) == null ? void 0 : t.type) == null ? void 0 : n.components)
    if (e.parent.type.components[s] === e?.type)
      return mn(e, s);
  for (const s in (r = e.appContext) == null ? void 0 : r.components)
    if (e.appContext.components[s] === e?.type)
      return mn(e, s);
  const i = va(e?.type || {});
  return i || "Anonymous Component";
}
function ya(e) {
  var t, n, r;
  const o = (r = (n = (t = e?.appContext) == null ? void 0 : t.app) == null ? void 0 : n.__VUE_DEVTOOLS_NEXT_APP_RECORD_ID__) != null ? r : 0, i = e === e?.root ? "root" : e.uid;
  return `${o}:${i}`;
}
function _t(e, t) {
  return t = t || `${e.id}:root`, e.instanceMap.get(t) || e.instanceMap.get(":root");
}
function Ca() {
  const e = {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    get width() {
      return e.right - e.left;
    },
    get height() {
      return e.bottom - e.top;
    }
  };
  return e;
}
var Ie;
function ba(e) {
  return Ie || (Ie = document.createRange()), Ie.selectNode(e), Ie.getBoundingClientRect();
}
function wa(e) {
  const t = Ca();
  if (!e.children)
    return t;
  for (let n = 0, r = e.children.length; n < r; n++) {
    const o = e.children[n];
    let i;
    if (o.component)
      i = ee(o.component);
    else if (o.el) {
      const s = o.el;
      s.nodeType === 1 || s.getBoundingClientRect ? i = s.getBoundingClientRect() : s.nodeType === 3 && s.data.trim() && (i = ba(s));
    }
    i && Aa(t, i);
  }
  return t;
}
function Aa(e, t) {
  return (!e.top || t.top < e.top) && (e.top = t.top), (!e.bottom || t.bottom > e.bottom) && (e.bottom = t.bottom), (!e.left || t.left < e.left) && (e.left = t.left), (!e.right || t.right > e.right) && (e.right = t.right), e;
}
var gn = {
  top: 0,
  left: 0,
  right: 0,
  bottom: 0,
  width: 0,
  height: 0
};
function ee(e) {
  const t = e.subTree.el;
  return typeof window > "u" ? gn : Xr(e) ? wa(e.subTree) : t?.nodeType === 1 ? t?.getBoundingClientRect() : e.subTree.component ? ee(e.subTree.component) : gn;
}
m();
function kt(e) {
  return Xr(e) ? Ta(e.subTree) : e.subTree ? [e.subTree.el] : [];
}
function Ta(e) {
  if (!e.children)
    return [];
  const t = [];
  return e.children.forEach((n) => {
    n.component ? t.push(...kt(n.component)) : n?.el && t.push(n.el);
  }), t;
}
var Qr = "__vue-devtools-component-inspector__";
var Zr = "__vue-devtools-component-inspector__card__";
var Jr = "__vue-devtools-component-inspector__name__";
var eo = "__vue-devtools-component-inspector__indicator__";
var to = {
  display: "block",
  zIndex: 2147483640,
  position: "fixed",
  backgroundColor: "#42b88325",
  border: "1px solid #42b88350",
  borderRadius: "5px",
  transition: "all 0.1s ease-in",
  pointerEvents: "none"
};
var Oa = {
  fontFamily: "Arial, Helvetica, sans-serif",
  padding: "5px 8px",
  borderRadius: "4px",
  textAlign: "left",
  position: "absolute",
  left: 0,
  color: "#e9e9e9",
  fontSize: "14px",
  fontWeight: 600,
  lineHeight: "24px",
  backgroundColor: "#42b883",
  boxShadow: "0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.1)"
};
var Sa = {
  display: "inline-block",
  fontWeight: 400,
  fontStyle: "normal",
  fontSize: "12px",
  opacity: 0.7
};
function ce() {
  return document.getElementById(Qr);
}
function Pa() {
  return document.getElementById(Zr);
}
function Ia() {
  return document.getElementById(eo);
}
function Da() {
  return document.getElementById(Jr);
}
function xt(e) {
  return {
    left: `${Math.round(e.left * 100) / 100}px`,
    top: `${Math.round(e.top * 100) / 100}px`,
    width: `${Math.round(e.width * 100) / 100}px`,
    height: `${Math.round(e.height * 100) / 100}px`
  };
}
function Rt(e) {
  var t;
  const n = document.createElement("div");
  n.id = (t = e.elementId) != null ? t : Qr, Object.assign(n.style, {
    ...to,
    ...xt(e.bounds),
    ...e.style
  });
  const r = document.createElement("span");
  r.id = Zr, Object.assign(r.style, {
    ...Oa,
    top: e.bounds.top < 35 ? 0 : "-35px"
  });
  const o = document.createElement("span");
  o.id = Jr, o.innerHTML = `&lt;${e.name}&gt;&nbsp;&nbsp;`;
  const i = document.createElement("i");
  return i.id = eo, i.innerHTML = `${Math.round(e.bounds.width * 100) / 100} x ${Math.round(e.bounds.height * 100) / 100}`, Object.assign(i.style, Sa), r.appendChild(o), r.appendChild(i), n.appendChild(r), document.body.appendChild(n), n;
}
function Lt(e) {
  const t = ce(), n = Pa(), r = Da(), o = Ia();
  t && (Object.assign(t.style, {
    ...to,
    ...xt(e.bounds)
  }), Object.assign(n.style, {
    top: e.bounds.top < 35 ? 0 : "-35px"
  }), r.innerHTML = `&lt;${e.name}&gt;&nbsp;&nbsp;`, o.innerHTML = `${Math.round(e.bounds.width * 100) / 100} x ${Math.round(e.bounds.height * 100) / 100}`);
}
function ka(e) {
  const t = ee(e);
  if (!t.width && !t.height)
    return;
  const n = Ke(e);
  ce() ? Lt({ bounds: t, name: n }) : Rt({ bounds: t, name: n });
}
function no() {
  const e = ce();
  e && (e.style.display = "none");
}
var mt = null;
function gt(e) {
  const t = e.target;
  if (t) {
    const n = t.__vueParentComponent;
    if (n && (mt = n, n.vnode.el)) {
      const o = ee(n), i = Ke(n);
      ce() ? Lt({ bounds: o, name: i }) : Rt({ bounds: o, name: i });
    }
  }
}
function xa(e, t) {
  if (e.preventDefault(), e.stopPropagation(), mt) {
    const n = ya(mt);
    t(n);
  }
}
var Ue = null;
function Ra() {
  no(), window.removeEventListener("mouseover", gt), window.removeEventListener("click", Ue, true), Ue = null;
}
function La() {
  return window.addEventListener("mouseover", gt), new Promise((e) => {
    function t(n) {
      n.preventDefault(), n.stopPropagation(), xa(n, (r) => {
        window.removeEventListener("click", t, true), Ue = null, window.removeEventListener("mouseover", gt);
        const o = ce();
        o && (o.style.display = "none"), e(JSON.stringify({ id: r }));
      });
    }
    Ue = t, window.addEventListener("click", t, true);
  });
}
function Fa(e) {
  const t = _t(F.value, e.id);
  if (t) {
    const [n] = kt(t);
    if (typeof n.scrollIntoView == "function")
      n.scrollIntoView({
        behavior: "smooth"
      });
    else {
      const r = ee(t), o = document.createElement("div"), i = {
        ...xt(r),
        position: "absolute"
      };
      Object.assign(o.style, i), document.body.appendChild(o), o.scrollIntoView({
        behavior: "smooth"
      }), setTimeout(() => {
        document.body.removeChild(o);
      }, 2e3);
    }
    setTimeout(() => {
      const r = ee(t);
      if (r.width || r.height) {
        const o = Ke(t), i = ce();
        i ? Lt({ ...e, name: o, bounds: r }) : Rt({ ...e, name: o, bounds: r }), setTimeout(() => {
          i && (i.style.display = "none");
        }, 1500);
      }
    }, 1200);
  }
}
m();
var En;
var vn;
(vn = (En = y).__VUE_DEVTOOLS_COMPONENT_INSPECTOR_ENABLED__) != null || (En.__VUE_DEVTOOLS_COMPONENT_INSPECTOR_ENABLED__ = true);
function Ma(e) {
  let t = 0;
  const n = setInterval(() => {
    y.__VUE_INSPECTOR__ && (clearInterval(n), t += 30, e()), t >= /* 5s */
    5e3 && clearInterval(n);
  }, 30);
}
function Na() {
  const e = y.__VUE_INSPECTOR__, t = e.openInEditor;
  e.openInEditor = async (...n) => {
    e.disable(), t(...n);
  };
}
function Va() {
  return new Promise((e) => {
    function t() {
      Na(), e(y.__VUE_INSPECTOR__);
    }
    y.__VUE_INSPECTOR__ ? t() : Ma(() => {
      t();
    });
  });
}
m();
m();
function Ba(e) {
  return !!(e && e.__v_isReadonly);
}
function ro(e) {
  return Ba(e) ? ro(e.__v_raw) : !!(e && e.__v_isReactive);
}
function nt(e) {
  return !!(e && e.__v_isRef === true);
}
function _e(e) {
  const t = e && e.__v_raw;
  return t ? _e(t) : e;
}
var Ua = class {
  constructor() {
    this.refEditor = new Ha();
  }
  set(e, t, n, r) {
    const o = Array.isArray(t) ? t : t.split(".");
    for (; o.length > 1; ) {
      const a = o.shift();
      e instanceof Map ? e = e.get(a) : e instanceof Set ? e = Array.from(e.values())[a] : e = e[a], this.refEditor.isRef(e) && (e = this.refEditor.get(e));
    }
    const i = o[0], s = this.refEditor.get(e)[i];
    r ? r(e, i, n) : this.refEditor.isRef(s) ? this.refEditor.set(s, n) : e[i] = n;
  }
  get(e, t) {
    const n = Array.isArray(t) ? t : t.split(".");
    for (let r = 0; r < n.length; r++)
      if (e instanceof Map ? e = e.get(n[r]) : e = e[n[r]], this.refEditor.isRef(e) && (e = this.refEditor.get(e)), !e)
        return;
    return e;
  }
  has(e, t, n = false) {
    if (typeof e > "u")
      return false;
    const r = Array.isArray(t) ? t.slice() : t.split("."), o = n ? 2 : 1;
    for (; e && r.length > o; ) {
      const i = r.shift();
      e = e[i], this.refEditor.isRef(e) && (e = this.refEditor.get(e));
    }
    return e != null && Object.prototype.hasOwnProperty.call(e, r[0]);
  }
  createDefaultSetCallback(e) {
    return (t, n, r) => {
      if ((e.remove || e.newKey) && (Array.isArray(t) ? t.splice(n, 1) : _e(t) instanceof Map ? t.delete(n) : _e(t) instanceof Set ? t.delete(Array.from(t.values())[n]) : Reflect.deleteProperty(t, n)), !e.remove) {
        const o = t[e.newKey || n];
        this.refEditor.isRef(o) ? this.refEditor.set(o, r) : _e(t) instanceof Map ? t.set(e.newKey || n, r) : _e(t) instanceof Set ? t.add(r) : t[e.newKey || n] = r;
      }
    };
  }
};
var Ha = class {
  set(e, t) {
    if (nt(e))
      e.value = t;
    else {
      if (e instanceof Set && Array.isArray(t)) {
        e.clear(), t.forEach((o) => e.add(o));
        return;
      }
      const n = Object.keys(t);
      if (e instanceof Map) {
        const o = new Set(e.keys());
        n.forEach((i) => {
          e.set(i, Reflect.get(t, i)), o.delete(i);
        }), o.forEach((i) => e.delete(i));
        return;
      }
      const r = new Set(Object.keys(e));
      n.forEach((o) => {
        Reflect.set(e, o, Reflect.get(t, o)), r.delete(o);
      }), r.forEach((o) => Reflect.deleteProperty(e, o));
    }
  }
  get(e) {
    return nt(e) ? e.value : e;
  }
  isRef(e) {
    return nt(e) || ro(e);
  }
};
m();
m();
m();
var ja = "__VUE_DEVTOOLS_KIT_TIMELINE_LAYERS_STATE__";
function za() {
  if (!Kr || typeof localStorage > "u" || localStorage === null)
    return {
      recordingState: false,
      mouseEventEnabled: false,
      keyboardEventEnabled: false,
      componentEventEnabled: false,
      performanceEventEnabled: false,
      selected: ""
    };
  const e = localStorage.getItem(ja);
  return e ? JSON.parse(e) : {
    recordingState: false,
    mouseEventEnabled: false,
    keyboardEventEnabled: false,
    componentEventEnabled: false,
    performanceEventEnabled: false,
    selected: ""
  };
}
m();
m();
m();
var yn;
var Cn;
(Cn = (yn = y).__VUE_DEVTOOLS_KIT_TIMELINE_LAYERS) != null || (yn.__VUE_DEVTOOLS_KIT_TIMELINE_LAYERS = []);
var $a = new Proxy(y.__VUE_DEVTOOLS_KIT_TIMELINE_LAYERS, {
  get(e, t, n) {
    return Reflect.get(e, t, n);
  }
});
function Ka(e, t) {
  k.timelineLayersState[t.id] = false, $a.push({
    ...e,
    descriptorId: t.id,
    appRecord: Dt(t.app)
  });
}
var bn;
var wn;
(wn = (bn = y).__VUE_DEVTOOLS_KIT_INSPECTOR__) != null || (bn.__VUE_DEVTOOLS_KIT_INSPECTOR__ = []);
var Ft = new Proxy(y.__VUE_DEVTOOLS_KIT_INSPECTOR__, {
  get(e, t, n) {
    return Reflect.get(e, t, n);
  }
});
var oo = ae(() => {
  fe.hooks.callHook("sendInspectorToClient", io());
});
function Wa(e, t) {
  var n, r;
  Ft.push({
    options: e,
    descriptor: t,
    treeFilterPlaceholder: (n = e.treeFilterPlaceholder) != null ? n : "Search tree...",
    stateFilterPlaceholder: (r = e.stateFilterPlaceholder) != null ? r : "Search state...",
    treeFilter: "",
    selectedNodeId: "",
    appRecord: Dt(t.app)
  }), oo();
}
function io() {
  return Ft.filter((e) => e.descriptor.app === F.value.app).filter((e) => e.descriptor.id !== "components").map((e) => {
    var t;
    const n = e.descriptor, r = e.options;
    return {
      id: r.id,
      label: r.label,
      logo: n.logo,
      icon: `custom-ic-baseline-${(t = r?.icon) == null ? void 0 : t.replace(/_/g, "-")}`,
      packageName: n.packageName,
      homepage: n.homepage,
      pluginId: n.id
    };
  });
}
function Re(e, t) {
  return Ft.find((n) => n.options.id === e && (t ? n.descriptor.app === t : true));
}
function Ga() {
  const e = Gr();
  e.hook("addInspector", ({ inspector: r, plugin: o }) => {
    Wa(r, o.descriptor);
  });
  const t = ae(async ({ inspectorId: r, plugin: o }) => {
    var i;
    if (!r || !((i = o?.descriptor) != null && i.app) || k.highPerfModeEnabled)
      return;
    const s = Re(r, o.descriptor.app), a = {
      app: o.descriptor.app,
      inspectorId: r,
      filter: s?.treeFilter || "",
      rootNodes: []
    };
    await new Promise((u) => {
      e.callHookWith(
        async (l) => {
          await Promise.all(l.map((c) => c(a))), u();
        },
        "getInspectorTree"
        /* GET_INSPECTOR_TREE */
      );
    }), e.callHookWith(
      async (u) => {
        await Promise.all(u.map((l) => l({
          inspectorId: r,
          rootNodes: a.rootNodes
        })));
      },
      "sendInspectorTreeToClient"
      /* SEND_INSPECTOR_TREE_TO_CLIENT */
    );
  }, 120);
  e.hook("sendInspectorTree", t);
  const n = ae(async ({ inspectorId: r, plugin: o }) => {
    var i;
    if (!r || !((i = o?.descriptor) != null && i.app) || k.highPerfModeEnabled)
      return;
    const s = Re(r, o.descriptor.app), a = {
      app: o.descriptor.app,
      inspectorId: r,
      nodeId: s?.selectedNodeId || "",
      state: null
    }, u = {
      currentTab: `custom-inspector:${r}`
    };
    a.nodeId && await new Promise((l) => {
      e.callHookWith(
        async (c) => {
          await Promise.all(c.map((f) => f(a, u))), l();
        },
        "getInspectorState"
        /* GET_INSPECTOR_STATE */
      );
    }), e.callHookWith(
      async (l) => {
        await Promise.all(l.map((c) => c({
          inspectorId: r,
          nodeId: a.nodeId,
          state: a.state
        })));
      },
      "sendInspectorStateToClient"
      /* SEND_INSPECTOR_STATE_TO_CLIENT */
    );
  }, 120);
  return e.hook("sendInspectorState", n), e.hook("customInspectorSelectNode", ({ inspectorId: r, nodeId: o, plugin: i }) => {
    const s = Re(r, i.descriptor.app);
    s && (s.selectedNodeId = o);
  }), e.hook("timelineLayerAdded", ({ options: r, plugin: o }) => {
    Ka(r, o.descriptor);
  }), e.hook("timelineEventAdded", ({ options: r, plugin: o }) => {
    var i;
    const s = ["performance", "component-event", "keyboard", "mouse"];
    k.highPerfModeEnabled || !((i = k.timelineLayersState) != null && i[o.descriptor.id]) && !s.includes(r.layerId) || e.callHookWith(
      async (a) => {
        await Promise.all(a.map((u) => u(r)));
      },
      "sendTimelineEventToClient"
      /* SEND_TIMELINE_EVENT_TO_CLIENT */
    );
  }), e.hook("getComponentInstances", async ({ app: r }) => {
    const o = r.__VUE_DEVTOOLS_NEXT_APP_RECORD__;
    if (!o)
      return null;
    const i = o.id.toString();
    return [...o.instanceMap].filter(([a]) => a.split(":")[0] === i).map(([, a]) => a);
  }), e.hook("getComponentBounds", async ({ instance: r }) => ee(r)), e.hook("getComponentName", ({ instance: r }) => Ke(r)), e.hook("componentHighlight", ({ uid: r }) => {
    const o = F.value.instanceMap.get(r);
    o && ka(o);
  }), e.hook("componentUnhighlight", () => {
    no();
  }), e;
}
var An;
var Tn;
(Tn = (An = y).__VUE_DEVTOOLS_KIT_APP_RECORDS__) != null || (An.__VUE_DEVTOOLS_KIT_APP_RECORDS__ = []);
var On;
var Sn;
(Sn = (On = y).__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD__) != null || (On.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD__ = {});
var Pn;
var In;
(In = (Pn = y).__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD_ID__) != null || (Pn.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD_ID__ = "");
var Dn;
var kn;
(kn = (Dn = y).__VUE_DEVTOOLS_KIT_CUSTOM_TABS__) != null || (Dn.__VUE_DEVTOOLS_KIT_CUSTOM_TABS__ = []);
var xn;
var Rn;
(Rn = (xn = y).__VUE_DEVTOOLS_KIT_CUSTOM_COMMANDS__) != null || (xn.__VUE_DEVTOOLS_KIT_CUSTOM_COMMANDS__ = []);
var Z = "__VUE_DEVTOOLS_KIT_GLOBAL_STATE__";
function Ya() {
  return {
    connected: false,
    clientConnected: false,
    vitePluginDetected: true,
    appRecords: [],
    activeAppRecordId: "",
    tabs: [],
    commands: [],
    highPerfModeEnabled: true,
    devtoolsClientDetected: {},
    perfUniqueGroupId: 0,
    timelineLayersState: za()
  };
}
var Ln;
var Fn;
(Fn = (Ln = y)[Z]) != null || (Ln[Z] = Ya());
var qa = ae((e) => {
  fe.hooks.callHook("devtoolsStateUpdated", { state: e });
});
ae((e, t) => {
  fe.hooks.callHook("devtoolsConnectedUpdated", { state: e, oldState: t });
});
var We = new Proxy(y.__VUE_DEVTOOLS_KIT_APP_RECORDS__, {
  get(e, t, n) {
    return t === "value" ? y.__VUE_DEVTOOLS_KIT_APP_RECORDS__ : y.__VUE_DEVTOOLS_KIT_APP_RECORDS__[t];
  }
});
var F = new Proxy(y.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD__, {
  get(e, t, n) {
    return t === "value" ? y.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD__ : t === "id" ? y.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD_ID__ : y.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD__[t];
  }
});
function so() {
  qa({
    ...y[Z],
    appRecords: We.value,
    activeAppRecordId: F.id,
    tabs: y.__VUE_DEVTOOLS_KIT_CUSTOM_TABS__,
    commands: y.__VUE_DEVTOOLS_KIT_CUSTOM_COMMANDS__
  });
}
function Xa(e) {
  y.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD__ = e, so();
}
function Qa(e) {
  y.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD_ID__ = e, so();
}
var k = new Proxy(y[Z], {
  get(e, t) {
    return t === "appRecords" ? We : t === "activeAppRecordId" ? F.id : t === "tabs" ? y.__VUE_DEVTOOLS_KIT_CUSTOM_TABS__ : t === "commands" ? y.__VUE_DEVTOOLS_KIT_CUSTOM_COMMANDS__ : y[Z][t];
  },
  deleteProperty(e, t) {
    return delete e[t], true;
  },
  set(e, t, n) {
    return { ...y[Z] }, e[t] = n, y[Z][t] = n, true;
  }
});
function Za(e = {}) {
  var t, n, r;
  const { file: o, host: i, baseUrl: s = window.location.origin, line: a = 0, column: u = 0 } = e;
  if (o) {
    if (i === "chrome-extension") {
      const l = o.replace(/\\/g, "\\\\"), c = (n = (t = window.VUE_DEVTOOLS_CONFIG) == null ? void 0 : t.openInEditorHost) != null ? n : "/";
      fetch(`${c}__open-in-editor?file=${encodeURI(o)}`).then((f) => {
        if (!f.ok) {
          const h2 = `Opening component ${l} failed`;
          console.log(`%c${h2}`, "color:red");
        }
      });
    } else if (k.vitePluginDetected) {
      const l = (r = y.__VUE_DEVTOOLS_OPEN_IN_EDITOR_BASE_URL__) != null ? r : s;
      y.__VUE_INSPECTOR__.openInEditor(l, o, a, u);
    }
  }
}
m();
m();
m();
m();
m();
var Mn;
var Nn;
(Nn = (Mn = y).__VUE_DEVTOOLS_KIT_PLUGIN_BUFFER__) != null || (Mn.__VUE_DEVTOOLS_KIT_PLUGIN_BUFFER__ = []);
var Mt = new Proxy(y.__VUE_DEVTOOLS_KIT_PLUGIN_BUFFER__, {
  get(e, t, n) {
    return Reflect.get(e, t, n);
  }
});
function Et(e) {
  const t = {};
  return Object.keys(e).forEach((n) => {
    t[n] = e[n].defaultValue;
  }), t;
}
function Nt(e) {
  return `__VUE_DEVTOOLS_NEXT_PLUGIN_SETTINGS__${e}__`;
}
function Ja(e) {
  var t, n, r;
  const o = (n = (t = Mt.find((i) => {
    var s;
    return i[0].id === e && !!((s = i[0]) != null && s.settings);
  })) == null ? void 0 : t[0]) != null ? n : null;
  return (r = o?.settings) != null ? r : null;
}
function ao(e, t) {
  var n, r, o;
  const i = Nt(e);
  if (i) {
    const s = localStorage.getItem(i);
    if (s)
      return JSON.parse(s);
  }
  if (e) {
    const s = (r = (n = Mt.find((a) => a[0].id === e)) == null ? void 0 : n[0]) != null ? r : null;
    return Et((o = s?.settings) != null ? o : {});
  }
  return Et(t);
}
function eu(e, t) {
  const n = Nt(e);
  localStorage.getItem(n) || localStorage.setItem(n, JSON.stringify(Et(t)));
}
function tu(e, t, n) {
  const r = Nt(e), o = localStorage.getItem(r), i = JSON.parse(o || "{}"), s = {
    ...i,
    [t]: n
  };
  localStorage.setItem(r, JSON.stringify(s)), fe.hooks.callHookWith(
    (a) => {
      a.forEach((u) => u({
        pluginId: e,
        key: t,
        oldValue: i[t],
        newValue: n,
        settings: s
      }));
    },
    "setPluginSettings"
    /* SET_PLUGIN_SETTINGS */
  );
}
m();
m();
m();
m();
m();
m();
m();
m();
m();
m();
m();
var Vn;
var Bn;
var V = (Bn = (Vn = y).__VUE_DEVTOOLS_HOOK) != null ? Bn : Vn.__VUE_DEVTOOLS_HOOK = Gr();
var nu = {
  vueAppInit(e) {
    V.hook("app:init", e);
  },
  vueAppUnmount(e) {
    V.hook("app:unmount", e);
  },
  vueAppConnected(e) {
    V.hook("app:connected", e);
  },
  componentAdded(e) {
    return V.hook("component:added", e);
  },
  componentEmit(e) {
    return V.hook("component:emit", e);
  },
  componentUpdated(e) {
    return V.hook("component:updated", e);
  },
  componentRemoved(e) {
    return V.hook("component:removed", e);
  },
  setupDevtoolsPlugin(e) {
    V.hook("devtools-plugin:setup", e);
  },
  perfStart(e) {
    return V.hook("perf:start", e);
  },
  perfEnd(e) {
    return V.hook("perf:end", e);
  }
};
var uo = {
  on: nu,
  setupDevToolsPlugin(e, t) {
    return V.callHook("devtools-plugin:setup", e, t);
  }
};
var ru = class {
  constructor({ plugin: e, ctx: t }) {
    this.hooks = t.hooks, this.plugin = e;
  }
  get on() {
    return {
      // component inspector
      visitComponentTree: (e) => {
        this.hooks.hook("visitComponentTree", e);
      },
      inspectComponent: (e) => {
        this.hooks.hook("inspectComponent", e);
      },
      editComponentState: (e) => {
        this.hooks.hook("editComponentState", e);
      },
      // custom inspector
      getInspectorTree: (e) => {
        this.hooks.hook("getInspectorTree", e);
      },
      getInspectorState: (e) => {
        this.hooks.hook("getInspectorState", e);
      },
      editInspectorState: (e) => {
        this.hooks.hook("editInspectorState", e);
      },
      // timeline
      inspectTimelineEvent: (e) => {
        this.hooks.hook("inspectTimelineEvent", e);
      },
      timelineCleared: (e) => {
        this.hooks.hook("timelineCleared", e);
      },
      // settings
      setPluginSettings: (e) => {
        this.hooks.hook("setPluginSettings", e);
      }
    };
  }
  // component inspector
  notifyComponentUpdate(e) {
    var t;
    if (k.highPerfModeEnabled)
      return;
    const n = io().find((r) => r.packageName === this.plugin.descriptor.packageName);
    if (n?.id) {
      if (e) {
        const r = [
          e.appContext.app,
          e.uid,
          (t = e.parent) == null ? void 0 : t.uid,
          e
        ];
        V.callHook("component:updated", ...r);
      } else
        V.callHook(
          "component:updated"
          /* COMPONENT_UPDATED */
        );
      this.hooks.callHook("sendInspectorState", { inspectorId: n.id, plugin: this.plugin });
    }
  }
  // custom inspector
  addInspector(e) {
    this.hooks.callHook("addInspector", { inspector: e, plugin: this.plugin }), this.plugin.descriptor.settings && eu(e.id, this.plugin.descriptor.settings);
  }
  sendInspectorTree(e) {
    k.highPerfModeEnabled || this.hooks.callHook("sendInspectorTree", { inspectorId: e, plugin: this.plugin });
  }
  sendInspectorState(e) {
    k.highPerfModeEnabled || this.hooks.callHook("sendInspectorState", { inspectorId: e, plugin: this.plugin });
  }
  selectInspectorNode(e, t) {
    this.hooks.callHook("customInspectorSelectNode", { inspectorId: e, nodeId: t, plugin: this.plugin });
  }
  visitComponentTree(e) {
    return this.hooks.callHook("visitComponentTree", e);
  }
  // timeline
  now() {
    return k.highPerfModeEnabled ? 0 : Date.now();
  }
  addTimelineLayer(e) {
    this.hooks.callHook("timelineLayerAdded", { options: e, plugin: this.plugin });
  }
  addTimelineEvent(e) {
    k.highPerfModeEnabled || this.hooks.callHook("timelineEventAdded", { options: e, plugin: this.plugin });
  }
  // settings
  getSettings(e) {
    return ao(e ?? this.plugin.descriptor.id, this.plugin.descriptor.settings);
  }
  // utilities
  getComponentInstances(e) {
    return this.hooks.callHook("getComponentInstances", { app: e });
  }
  getComponentBounds(e) {
    return this.hooks.callHook("getComponentBounds", { instance: e });
  }
  getComponentName(e) {
    return this.hooks.callHook("getComponentName", { instance: e });
  }
  highlightElement(e) {
    const t = e.__VUE_DEVTOOLS_NEXT_UID__;
    return this.hooks.callHook("componentHighlight", { uid: t });
  }
  unhighlightElement() {
    return this.hooks.callHook(
      "componentUnhighlight"
      /* COMPONENT_UNHIGHLIGHT */
    );
  }
};
var ou = ru;
m();
m();
m();
m();
var iu = "__vue_devtool_undefined__";
var su = "__vue_devtool_infinity__";
var au = "__vue_devtool_negative_infinity__";
var uu = "__vue_devtool_nan__";
m();
m();
var lu = {
  [iu]: "undefined",
  [uu]: "NaN",
  [su]: "Infinity",
  [au]: "-Infinity"
};
Object.entries(lu).reduce((e, [t, n]) => (e[n] = t, e), {});
m();
m();
m();
m();
m();
var Un;
var Hn;
(Hn = (Un = y).__VUE_DEVTOOLS_KIT__REGISTERED_PLUGIN_APPS__) != null || (Un.__VUE_DEVTOOLS_KIT__REGISTERED_PLUGIN_APPS__ = /* @__PURE__ */ new Set());
function cu(e, t) {
  return uo.setupDevToolsPlugin(e, t);
}
function fu(e, t) {
  const [n, r] = e;
  if (n.app !== t)
    return;
  const o = new ou({
    plugin: {
      setupFn: r,
      descriptor: n
    },
    ctx: fe
  });
  n.packageName === "vuex" && o.on.editInspectorState((i) => {
    o.sendInspectorState(i.inspectorId);
  }), r(o);
}
function lo(e, t) {
  y.__VUE_DEVTOOLS_KIT__REGISTERED_PLUGIN_APPS__.has(e) || k.highPerfModeEnabled && !t?.inspectingComponent || (y.__VUE_DEVTOOLS_KIT__REGISTERED_PLUGIN_APPS__.add(e), Mt.forEach((n) => {
    fu(n, e);
  }));
}
m();
m();
var ve = "__VUE_DEVTOOLS_ROUTER__";
var ue = "__VUE_DEVTOOLS_ROUTER_INFO__";
var jn;
var zn;
(zn = (jn = y)[ue]) != null || (jn[ue] = {
  currentRoute: null,
  routes: []
});
var $n;
var Kn;
(Kn = ($n = y)[ve]) != null || ($n[ve] = {});
new Proxy(y[ue], {
  get(e, t) {
    return y[ue][t];
  }
});
new Proxy(y[ve], {
  get(e, t) {
    if (t === "value")
      return y[ve];
  }
});
function du(e) {
  const t = /* @__PURE__ */ new Map();
  return (e?.getRoutes() || []).filter((n) => !t.has(n.path) && t.set(n.path, 1));
}
function Vt(e) {
  return e.map((t) => {
    let { path: n, name: r, children: o, meta: i } = t;
    return o?.length && (o = Vt(o)), {
      path: n,
      name: r,
      children: o,
      meta: i
    };
  });
}
function pu(e) {
  if (e) {
    const { fullPath: t, hash: n, href: r, path: o, name: i, matched: s, params: a, query: u } = e;
    return {
      fullPath: t,
      hash: n,
      href: r,
      path: o,
      name: i,
      params: a,
      query: u,
      matched: Vt(s)
    };
  }
  return e;
}
function hu(e, t) {
  function n() {
    var r;
    const o = (r = e.app) == null ? void 0 : r.config.globalProperties.$router, i = pu(o?.currentRoute.value), s = Vt(du(o)), a = console.warn;
    console.warn = () => {
    }, y[ue] = {
      currentRoute: i ? _n(i) : {},
      routes: _n(s)
    }, y[ve] = o, console.warn = a;
  }
  n(), uo.on.componentUpdated(ae(() => {
    var r;
    ((r = t.value) == null ? void 0 : r.app) === e.app && (n(), !k.highPerfModeEnabled && fe.hooks.callHook("routerInfoUpdated", { state: y[ue] }));
  }, 200));
}
function _u(e) {
  return {
    // get inspector tree
    async getInspectorTree(t) {
      const n = {
        ...t,
        app: F.value.app,
        rootNodes: []
      };
      return await new Promise((r) => {
        e.callHookWith(
          async (o) => {
            await Promise.all(o.map((i) => i(n))), r();
          },
          "getInspectorTree"
          /* GET_INSPECTOR_TREE */
        );
      }), n.rootNodes;
    },
    // get inspector state
    async getInspectorState(t) {
      const n = {
        ...t,
        app: F.value.app,
        state: null
      }, r = {
        currentTab: `custom-inspector:${t.inspectorId}`
      };
      return await new Promise((o) => {
        e.callHookWith(
          async (i) => {
            await Promise.all(i.map((s) => s(n, r))), o();
          },
          "getInspectorState"
          /* GET_INSPECTOR_STATE */
        );
      }), n.state;
    },
    // edit inspector state
    editInspectorState(t) {
      const n = new Ua(), r = {
        ...t,
        app: F.value.app,
        set: (o, i = t.path, s = t.state.value, a) => {
          n.set(o, i, s, a || n.createDefaultSetCallback(t.state));
        }
      };
      e.callHookWith(
        (o) => {
          o.forEach((i) => i(r));
        },
        "editInspectorState"
        /* EDIT_INSPECTOR_STATE */
      );
    },
    // send inspector state
    sendInspectorState(t) {
      const n = Re(t);
      e.callHook("sendInspectorState", { inspectorId: t, plugin: {
        descriptor: n.descriptor,
        setupFn: () => ({})
      } });
    },
    // inspect component inspector
    inspectComponentInspector() {
      return La();
    },
    // cancel inspect component inspector
    cancelInspectComponentInspector() {
      return Ra();
    },
    // get component render code
    getComponentRenderCode(t) {
      const n = _t(F.value, t);
      if (n)
        return typeof n?.type != "function" ? n.render.toString() : n.type.toString();
    },
    // scroll to component
    scrollToComponent(t) {
      return Fa({ id: t });
    },
    // open in editor
    openInEditor: Za,
    // get vue inspector
    getVueInspector: Va,
    // toggle app
    toggleApp(t, n) {
      const r = We.value.find((o) => o.id === t);
      r && (Qa(t), Xa(r), hu(r, F), oo(), lo(r.app, n));
    },
    // inspect dom
    inspectDOM(t) {
      const n = _t(F.value, t);
      if (n) {
        const [r] = kt(n);
        r && (y.__VUE_DEVTOOLS_INSPECT_DOM_TARGET__ = r);
      }
    },
    updatePluginSettings(t, n, r) {
      tu(t, n, r);
    },
    getPluginSettings(t) {
      return {
        options: Ja(t),
        values: ao(t)
      };
    }
  };
}
m();
var Wn;
var Gn;
(Gn = (Wn = y).__VUE_DEVTOOLS_ENV__) != null || (Wn.__VUE_DEVTOOLS_ENV__ = {
  vitePluginDetected: false
});
var Yn = Ga();
var qn;
var Xn;
(Xn = (qn = y).__VUE_DEVTOOLS_KIT_CONTEXT__) != null || (qn.__VUE_DEVTOOLS_KIT_CONTEXT__ = {
  hooks: Yn,
  get state() {
    return {
      ...k,
      activeAppRecordId: F.id,
      activeAppRecord: F.value,
      appRecords: We.value
    };
  },
  api: _u(Yn)
});
var fe = y.__VUE_DEVTOOLS_KIT_CONTEXT__;
m();
_a(ga());
var Qn;
var Zn;
(Zn = (Qn = y).__VUE_DEVTOOLS_NEXT_APP_RECORD_INFO__) != null || (Qn.__VUE_DEVTOOLS_NEXT_APP_RECORD_INFO__ = {
  id: 0,
  appIds: /* @__PURE__ */ new Set()
});
m();
m();
function mu(e) {
  k.highPerfModeEnabled = e ?? !k.highPerfModeEnabled, !e && F.value && lo(F.value.app);
}
m();
m();
m();
function gu(e) {
  k.devtoolsClientDetected = {
    ...k.devtoolsClientDetected,
    ...e
  };
  const t = Object.values(k.devtoolsClientDetected).some(Boolean);
  mu(!t);
}
var Jn;
var er;
(er = (Jn = y).__VUE_DEVTOOLS_UPDATE_CLIENT_DETECTED__) != null || (Jn.__VUE_DEVTOOLS_UPDATE_CLIENT_DETECTED__ = gu);
m();
m();
m();
m();
m();
m();
m();
var Eu = class {
  constructor() {
    this.keyToValue = /* @__PURE__ */ new Map(), this.valueToKey = /* @__PURE__ */ new Map();
  }
  set(e, t) {
    this.keyToValue.set(e, t), this.valueToKey.set(t, e);
  }
  getByKey(e) {
    return this.keyToValue.get(e);
  }
  getByValue(e) {
    return this.valueToKey.get(e);
  }
  clear() {
    this.keyToValue.clear(), this.valueToKey.clear();
  }
};
var co = class {
  constructor(e) {
    this.generateIdentifier = e, this.kv = new Eu();
  }
  register(e, t) {
    this.kv.getByValue(e) || (t || (t = this.generateIdentifier(e)), this.kv.set(t, e));
  }
  clear() {
    this.kv.clear();
  }
  getIdentifier(e) {
    return this.kv.getByValue(e);
  }
  getValue(e) {
    return this.kv.getByKey(e);
  }
};
var vu = class extends co {
  constructor() {
    super((e) => e.name), this.classToAllowedProps = /* @__PURE__ */ new Map();
  }
  register(e, t) {
    typeof t == "object" ? (t.allowProps && this.classToAllowedProps.set(e, t.allowProps), super.register(e, t.identifier)) : super.register(e, t);
  }
  getAllowedProps(e) {
    return this.classToAllowedProps.get(e);
  }
};
m();
m();
function yu(e) {
  if ("values" in Object)
    return Object.values(e);
  const t = [];
  for (const n in e)
    e.hasOwnProperty(n) && t.push(e[n]);
  return t;
}
function Cu(e, t) {
  const n = yu(e);
  if ("find" in n)
    return n.find(t);
  const r = n;
  for (let o = 0; o < r.length; o++) {
    const i = r[o];
    if (t(i))
      return i;
  }
}
function le(e, t) {
  Object.entries(e).forEach(([n, r]) => t(r, n));
}
function Le(e, t) {
  return e.indexOf(t) !== -1;
}
function tr(e, t) {
  for (let n = 0; n < e.length; n++) {
    const r = e[n];
    if (t(r))
      return r;
  }
}
var bu = class {
  constructor() {
    this.transfomers = {};
  }
  register(e) {
    this.transfomers[e.name] = e;
  }
  findApplicable(e) {
    return Cu(this.transfomers, (t) => t.isApplicable(e));
  }
  findByName(e) {
    return this.transfomers[e];
  }
};
m();
m();
var wu = (e) => Object.prototype.toString.call(e).slice(8, -1);
var fo = (e) => typeof e > "u";
var Au = (e) => e === null;
var ye = (e) => typeof e != "object" || e === null || e === Object.prototype ? false : Object.getPrototypeOf(e) === null ? true : Object.getPrototypeOf(e) === Object.prototype;
var vt = (e) => ye(e) && Object.keys(e).length === 0;
var G = (e) => Array.isArray(e);
var Tu = (e) => typeof e == "string";
var Ou = (e) => typeof e == "number" && !isNaN(e);
var Su = (e) => typeof e == "boolean";
var Pu = (e) => e instanceof RegExp;
var Ce = (e) => e instanceof Map;
var be = (e) => e instanceof Set;
var po = (e) => wu(e) === "Symbol";
var Iu = (e) => e instanceof Date && !isNaN(e.valueOf());
var Du = (e) => e instanceof Error;
var nr = (e) => typeof e == "number" && isNaN(e);
var ku = (e) => Su(e) || Au(e) || fo(e) || Ou(e) || Tu(e) || po(e);
var xu = (e) => typeof e == "bigint";
var Ru = (e) => e === 1 / 0 || e === -1 / 0;
var Lu = (e) => ArrayBuffer.isView(e) && !(e instanceof DataView);
var Fu = (e) => e instanceof URL;
m();
var ho = (e) => e.replace(/\./g, "\\.");
var rt = (e) => e.map(String).map(ho).join(".");
var ge = (e) => {
  const t = [];
  let n = "";
  for (let o = 0; o < e.length; o++) {
    let i = e.charAt(o);
    if (i === "\\" && e.charAt(o + 1) === ".") {
      n += ".", o++;
      continue;
    }
    if (i === ".") {
      t.push(n), n = "";
      continue;
    }
    n += i;
  }
  const r = n;
  return t.push(r), t;
};
m();
function j(e, t, n, r) {
  return {
    isApplicable: e,
    annotation: t,
    transform: n,
    untransform: r
  };
}
var _o = [
  j(fo, "undefined", () => null, () => {
  }),
  j(xu, "bigint", (e) => e.toString(), (e) => typeof BigInt < "u" ? BigInt(e) : (console.error("Please add a BigInt polyfill."), e)),
  j(Iu, "Date", (e) => e.toISOString(), (e) => new Date(e)),
  j(Du, "Error", (e, t) => {
    const n = {
      name: e.name,
      message: e.message
    };
    return t.allowedErrorProps.forEach((r) => {
      n[r] = e[r];
    }), n;
  }, (e, t) => {
    const n = new Error(e.message);
    return n.name = e.name, n.stack = e.stack, t.allowedErrorProps.forEach((r) => {
      n[r] = e[r];
    }), n;
  }),
  j(Pu, "regexp", (e) => "" + e, (e) => {
    const t = e.slice(1, e.lastIndexOf("/")), n = e.slice(e.lastIndexOf("/") + 1);
    return new RegExp(t, n);
  }),
  j(
    be,
    "set",
    // (sets only exist in es6+)
    // eslint-disable-next-line es5/no-es6-methods
    (e) => [...e.values()],
    (e) => new Set(e)
  ),
  j(Ce, "map", (e) => [...e.entries()], (e) => new Map(e)),
  j((e) => nr(e) || Ru(e), "number", (e) => nr(e) ? "NaN" : e > 0 ? "Infinity" : "-Infinity", Number),
  j((e) => e === 0 && 1 / e === -1 / 0, "number", () => "-0", Number),
  j(Fu, "URL", (e) => e.toString(), (e) => new URL(e))
];
function Ge(e, t, n, r) {
  return {
    isApplicable: e,
    annotation: t,
    transform: n,
    untransform: r
  };
}
var mo = Ge((e, t) => po(e) ? !!t.symbolRegistry.getIdentifier(e) : false, (e, t) => ["symbol", t.symbolRegistry.getIdentifier(e)], (e) => e.description, (e, t, n) => {
  const r = n.symbolRegistry.getValue(t[1]);
  if (!r)
    throw new Error("Trying to deserialize unknown symbol");
  return r;
});
var Mu = [
  Int8Array,
  Uint8Array,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
  Uint8ClampedArray
].reduce((e, t) => (e[t.name] = t, e), {});
var go = Ge(Lu, (e) => ["typed-array", e.constructor.name], (e) => [...e], (e, t) => {
  const n = Mu[t[1]];
  if (!n)
    throw new Error("Trying to deserialize unknown typed array");
  return new n(e);
});
function Eo(e, t) {
  return e?.constructor ? !!t.classRegistry.getIdentifier(e.constructor) : false;
}
var vo = Ge(Eo, (e, t) => ["class", t.classRegistry.getIdentifier(e.constructor)], (e, t) => {
  const n = t.classRegistry.getAllowedProps(e.constructor);
  if (!n)
    return { ...e };
  const r = {};
  return n.forEach((o) => {
    r[o] = e[o];
  }), r;
}, (e, t, n) => {
  const r = n.classRegistry.getValue(t[1]);
  if (!r)
    throw new Error(`Trying to deserialize unknown class '${t[1]}' - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564`);
  return Object.assign(Object.create(r.prototype), e);
});
var yo = Ge((e, t) => !!t.customTransformerRegistry.findApplicable(e), (e, t) => ["custom", t.customTransformerRegistry.findApplicable(e).name], (e, t) => t.customTransformerRegistry.findApplicable(e).serialize(e), (e, t, n) => {
  const r = n.customTransformerRegistry.findByName(t[1]);
  if (!r)
    throw new Error("Trying to deserialize unknown custom value");
  return r.deserialize(e);
});
var Nu = [vo, mo, yo, go];
var rr = (e, t) => {
  const n = tr(Nu, (o) => o.isApplicable(e, t));
  if (n)
    return {
      value: n.transform(e, t),
      type: n.annotation(e, t)
    };
  const r = tr(_o, (o) => o.isApplicable(e, t));
  if (r)
    return {
      value: r.transform(e, t),
      type: r.annotation
    };
};
var Co = {};
_o.forEach((e) => {
  Co[e.annotation] = e;
});
var Vu = (e, t, n) => {
  if (G(t))
    switch (t[0]) {
      case "symbol":
        return mo.untransform(e, t, n);
      case "class":
        return vo.untransform(e, t, n);
      case "custom":
        return yo.untransform(e, t, n);
      case "typed-array":
        return go.untransform(e, t, n);
      default:
        throw new Error("Unknown transformation: " + t);
    }
  else {
    const r = Co[t];
    if (!r)
      throw new Error("Unknown transformation: " + t);
    return r.untransform(e, n);
  }
};
m();
var oe = (e, t) => {
  if (t > e.size)
    throw new Error("index out of bounds");
  const n = e.keys();
  for (; t > 0; )
    n.next(), t--;
  return n.next().value;
};
function bo(e) {
  if (Le(e, "__proto__"))
    throw new Error("__proto__ is not allowed as a property");
  if (Le(e, "prototype"))
    throw new Error("prototype is not allowed as a property");
  if (Le(e, "constructor"))
    throw new Error("constructor is not allowed as a property");
}
var Bu = (e, t) => {
  bo(t);
  for (let n = 0; n < t.length; n++) {
    const r = t[n];
    if (be(e))
      e = oe(e, +r);
    else if (Ce(e)) {
      const o = +r, i = +t[++n] == 0 ? "key" : "value", s = oe(e, o);
      switch (i) {
        case "key":
          e = s;
          break;
        case "value":
          e = e.get(s);
          break;
      }
    } else
      e = e[r];
  }
  return e;
};
var yt = (e, t, n) => {
  if (bo(t), t.length === 0)
    return n(e);
  let r = e;
  for (let i = 0; i < t.length - 1; i++) {
    const s = t[i];
    if (G(r)) {
      const a = +s;
      r = r[a];
    } else if (ye(r))
      r = r[s];
    else if (be(r)) {
      const a = +s;
      r = oe(r, a);
    } else if (Ce(r)) {
      if (i === t.length - 2)
        break;
      const u = +s, l = +t[++i] == 0 ? "key" : "value", c = oe(r, u);
      switch (l) {
        case "key":
          r = c;
          break;
        case "value":
          r = r.get(c);
          break;
      }
    }
  }
  const o = t[t.length - 1];
  if (G(r) ? r[+o] = n(r[+o]) : ye(r) && (r[o] = n(r[o])), be(r)) {
    const i = oe(r, +o), s = n(i);
    i !== s && (r.delete(i), r.add(s));
  }
  if (Ce(r)) {
    const i = +t[t.length - 2], s = oe(r, i);
    switch (+o == 0 ? "key" : "value") {
      case "key": {
        const u = n(s);
        r.set(u, r.get(s)), u !== s && r.delete(s);
        break;
      }
      case "value": {
        r.set(s, n(r.get(s)));
        break;
      }
    }
  }
  return e;
};
function Ct(e, t, n = []) {
  if (!e)
    return;
  if (!G(e)) {
    le(e, (i, s) => Ct(i, t, [...n, ...ge(s)]));
    return;
  }
  const [r, o] = e;
  o && le(o, (i, s) => {
    Ct(i, t, [...n, ...ge(s)]);
  }), t(r, n);
}
function Uu(e, t, n) {
  return Ct(t, (r, o) => {
    e = yt(e, o, (i) => Vu(i, r, n));
  }), e;
}
function Hu(e, t) {
  function n(r, o) {
    const i = Bu(e, ge(o));
    r.map(ge).forEach((s) => {
      e = yt(e, s, () => i);
    });
  }
  if (G(t)) {
    const [r, o] = t;
    r.forEach((i) => {
      e = yt(e, ge(i), () => e);
    }), o && le(o, n);
  } else
    le(t, n);
  return e;
}
var ju = (e, t) => ye(e) || G(e) || Ce(e) || be(e) || Eo(e, t);
function zu(e, t, n) {
  const r = n.get(e);
  r ? r.push(t) : n.set(e, [t]);
}
function $u(e, t) {
  const n = {};
  let r;
  return e.forEach((o) => {
    if (o.length <= 1)
      return;
    t || (o = o.map((a) => a.map(String)).sort((a, u) => a.length - u.length));
    const [i, ...s] = o;
    i.length === 0 ? r = s.map(rt) : n[rt(i)] = s.map(rt);
  }), r ? vt(n) ? [r] : [r, n] : vt(n) ? void 0 : n;
}
var wo = (e, t, n, r, o = [], i = [], s = /* @__PURE__ */ new Map()) => {
  var a;
  const u = ku(e);
  if (!u) {
    zu(e, o, t);
    const _ = s.get(e);
    if (_)
      return r ? {
        transformedValue: null
      } : _;
  }
  if (!ju(e, n)) {
    const _ = rr(e, n), v = _ ? {
      transformedValue: _.value,
      annotations: [_.type]
    } : {
      transformedValue: e
    };
    return u || s.set(e, v), v;
  }
  if (Le(i, e))
    return {
      transformedValue: null
    };
  const l = rr(e, n), c = (a = l?.value) != null ? a : e, f = G(c) ? [] : {}, h2 = {};
  le(c, (_, v) => {
    if (v === "__proto__" || v === "constructor" || v === "prototype")
      throw new Error(`Detected property ${v}. This is a prototype pollution risk, please remove it from your object.`);
    const p = wo(_, t, n, r, [...o, v], [...i, e], s);
    f[v] = p.transformedValue, G(p.annotations) ? h2[v] = p.annotations : ye(p.annotations) && le(p.annotations, (g, C) => {
      h2[ho(v) + "." + C] = g;
    });
  });
  const d = vt(h2) ? {
    transformedValue: f,
    annotations: l ? [l.type] : void 0
  } : {
    transformedValue: f,
    annotations: l ? [l.type, h2] : h2
  };
  return u || s.set(e, d), d;
};
m();
m();
function Ao(e) {
  return Object.prototype.toString.call(e).slice(8, -1);
}
function or(e) {
  return Ao(e) === "Array";
}
function Ku(e) {
  if (Ao(e) !== "Object")
    return false;
  const t = Object.getPrototypeOf(e);
  return !!t && t.constructor === Object && t === Object.prototype;
}
function Wu(e, t, n, r, o) {
  const i = {}.propertyIsEnumerable.call(r, t) ? "enumerable" : "nonenumerable";
  i === "enumerable" && (e[t] = n), o && i === "nonenumerable" && Object.defineProperty(e, t, {
    value: n,
    enumerable: false,
    writable: true,
    configurable: true
  });
}
function bt(e, t = {}) {
  if (or(e))
    return e.map((o) => bt(o, t));
  if (!Ku(e))
    return e;
  const n = Object.getOwnPropertyNames(e), r = Object.getOwnPropertySymbols(e);
  return [...n, ...r].reduce((o, i) => {
    if (or(t.props) && !t.props.includes(i))
      return o;
    const s = e[i], a = bt(s, t);
    return Wu(o, i, a, e, t.nonenumerable), o;
  }, {});
}
var S = class {
  /**
   * @param dedupeReferentialEqualities  If true, SuperJSON will make sure only one instance of referentially equal objects are serialized and the rest are replaced with `null`.
   */
  constructor({ dedupe: e = false } = {}) {
    this.classRegistry = new vu(), this.symbolRegistry = new co((t) => {
      var n;
      return (n = t.description) != null ? n : "";
    }), this.customTransformerRegistry = new bu(), this.allowedErrorProps = [], this.dedupe = e;
  }
  serialize(e) {
    const t = /* @__PURE__ */ new Map(), n = wo(e, t, this, this.dedupe), r = {
      json: n.transformedValue
    };
    n.annotations && (r.meta = {
      ...r.meta,
      values: n.annotations
    });
    const o = $u(t, this.dedupe);
    return o && (r.meta = {
      ...r.meta,
      referentialEqualities: o
    }), r;
  }
  deserialize(e) {
    const { json: t, meta: n } = e;
    let r = bt(t);
    return n?.values && (r = Uu(r, n.values, this)), n?.referentialEqualities && (r = Hu(r, n.referentialEqualities)), r;
  }
  stringify(e) {
    return JSON.stringify(this.serialize(e));
  }
  parse(e) {
    return this.deserialize(JSON.parse(e));
  }
  registerClass(e, t) {
    this.classRegistry.register(e, t);
  }
  registerSymbol(e, t) {
    this.symbolRegistry.register(e, t);
  }
  registerCustom(e, t) {
    this.customTransformerRegistry.register({
      name: t,
      ...e
    });
  }
  allowErrorProps(...e) {
    this.allowedErrorProps.push(...e);
  }
};
S.defaultInstance = new S();
S.serialize = S.defaultInstance.serialize.bind(S.defaultInstance);
S.deserialize = S.defaultInstance.deserialize.bind(S.defaultInstance);
S.stringify = S.defaultInstance.stringify.bind(S.defaultInstance);
S.parse = S.defaultInstance.parse.bind(S.defaultInstance);
S.registerClass = S.defaultInstance.registerClass.bind(S.defaultInstance);
S.registerSymbol = S.defaultInstance.registerSymbol.bind(S.defaultInstance);
S.registerCustom = S.defaultInstance.registerCustom.bind(S.defaultInstance);
S.allowErrorProps = S.defaultInstance.allowErrorProps.bind(S.defaultInstance);
m();
m();
m();
m();
m();
m();
m();
m();
m();
m();
m();
m();
m();
m();
m();
m();
m();
m();
m();
m();
m();
m();
m();
var ir;
var sr;
(sr = (ir = y).__VUE_DEVTOOLS_KIT_MESSAGE_CHANNELS__) != null || (ir.__VUE_DEVTOOLS_KIT_MESSAGE_CHANNELS__ = []);
var ar;
var ur;
(ur = (ar = y).__VUE_DEVTOOLS_KIT_RPC_CLIENT__) != null || (ar.__VUE_DEVTOOLS_KIT_RPC_CLIENT__ = null);
var lr;
var cr;
(cr = (lr = y).__VUE_DEVTOOLS_KIT_RPC_SERVER__) != null || (lr.__VUE_DEVTOOLS_KIT_RPC_SERVER__ = null);
var fr;
var dr;
(dr = (fr = y).__VUE_DEVTOOLS_KIT_VITE_RPC_CLIENT__) != null || (fr.__VUE_DEVTOOLS_KIT_VITE_RPC_CLIENT__ = null);
var pr;
var hr;
(hr = (pr = y).__VUE_DEVTOOLS_KIT_VITE_RPC_SERVER__) != null || (pr.__VUE_DEVTOOLS_KIT_VITE_RPC_SERVER__ = null);
var _r;
var mr;
(mr = (_r = y).__VUE_DEVTOOLS_KIT_BROADCAST_RPC_SERVER__) != null || (_r.__VUE_DEVTOOLS_KIT_BROADCAST_RPC_SERVER__ = null);
m();
m();
m();
m();
m();
m();
m();
function Gu(e, t) {
  const n = `▲ ■ ●${e}`;
  typeof gr == "function" ? gr(n, t) : console.log(n);
}
function gr(e, t) {
  throw new Error(e + t);
}
function Bt(e) {
  let t = 0;
  return e.traverse((n) => {
    if ($e(n) && n.type !== "HightlightMesh") {
      const r = n.geometry, o = r.attributes.position.count * 3 * Float32Array.BYTES_PER_ELEMENT, i = r.index ? r.index.count * Uint32Array.BYTES_PER_ELEMENT : 0, s = r.attributes.normal ? r.attributes.normal.count * 3 * Float32Array.BYTES_PER_ELEMENT : 0, a = r.attributes.uv ? r.attributes.uv.count * 2 * Float32Array.BYTES_PER_ELEMENT : 0, u = o + i + s + a;
      t += u;
    }
  }), t;
}
function Er(e, t, n) {
  e.push(t), e.length > n && e.shift();
}
function Yu(e) {
  return (e / 1024).toFixed(2);
}
function qu(e) {
  if (!e)
    return;
  typeof window < "u" && !window.__TRES__DEVTOOLS__ && (window.__TRES__DEVTOOLS__ = new Hs());
  const t = {
    maxFrames: 160,
    fps: {
      value: 0,
      accumulator: []
    },
    memory: {
      currentMem: 0,
      allocatedMem: 0,
      accumulator: []
    }
  }, n = 100, r = useFps({ every: n }), { isSupported: o, memory: i } = useMemory({ interval: n }), s = 160;
  let a = performance.now(), u = 0;
  const l = 1, c = ({ timestamp: h2 }) => {
    e.scene.value && (t.memory.allocatedMem = Bt(e.scene.value)), h2 - a >= n && (a = h2, Er(t.fps.accumulator, r.value, s), t.fps.value = r.value, o.value && i.value?.usedJSHeapSize && (Er(t.memory.accumulator, i.value.usedJSHeapSize / 1024 / 1024, s), t.memory.accumulator.length > 0 && (t.memory.currentMem = t.memory.accumulator.reduce((d, _) => d + _, 0) / t.memory.accumulator.length)));
  }, { pause: f } = useRafFn(({ delta: h2 }) => {
    window.__TRES__DEVTOOLS__ && (c({ timestamp: performance.now() }), u += h2, u >= l && (window.__TRES__DEVTOOLS__.send("context", e), window.__TRES__DEVTOOLS__.send("performance", t), u = 0));
  }, { immediate: true });
  ie(() => {
    f();
  });
}
var To = (e, t) => {
  if (e.uuid === t)
    return e;
  for (const n of e.children) {
    const r = To(n, t);
    if (r)
      return r;
  }
};
var Xu = class extends Mesh {
  type = "HightlightMesh";
  createTime;
  constructor(...t) {
    super(...t), this.createTime = Date.now();
  }
  onBeforeRender() {
    const n = (Date.now() - this.createTime) / 1e3, i = 1 + 0.07 * Math.sin(2.5 * n);
    this.scale.set(i, i, i);
  }
};
var Oo = (e) => {
  const t = {
    id: `scene-${e.uuid}`,
    label: e.type,
    children: [],
    tags: []
  };
  e.name !== "" && t.tags.push({
    label: e.name,
    textColor: 5750629,
    backgroundColor: 15793395
  });
  const n = Bt(e);
  return n > 0 && t.tags.push({
    label: `${Yu(n)} KB`,
    textColor: 15707189,
    backgroundColor: 16775644,
    tooltip: "Memory usage"
  }), e.type.includes("Light") && (Rr(e) && t.tags.push({
    label: `${e.intensity}`,
    textColor: 9738662,
    backgroundColor: 16316922,
    tooltip: "Intensity"
  }), t.tags.push({
    label: `#${new Color(e.color).getHexString()}`,
    textColor: 9738662,
    backgroundColor: 16316922,
    tooltip: "Color"
  })), e.type.includes("Camera") && (t.tags.push({
    label: `${e.fov}°`,
    textColor: 9738662,
    backgroundColor: 16316922,
    tooltip: "Field of view"
  }), t.tags.push({
    label: `x: ${Math.round(e.position.x)} y: ${Math.round(e.position.y)} z: ${Math.round(e.position.z)}`,
    textColor: 9738662,
    backgroundColor: 16316922,
    tooltip: "Position"
  })), t;
};
function Qu(e, t, n = "") {
  const r = n ? `${n}.${e}` : e;
  return {
    id: `context-${t}-${r}`,
    label: e,
    children: [],
    tags: []
  };
}
function So(e, t, n = "") {
  e.children.forEach((r) => {
    if (r.type === "HightlightMesh" || n && !r.type.includes(n) && !r.name.includes(n))
      return;
    const o = Oo(r);
    t.children.push(o), So(r, o, n);
  });
}
function wt(e, t, n = /* @__PURE__ */ new WeakSet(), r = 0, o = 4, i, s = "") {
  if (r >= o || !e || n.has(e))
    return;
  const a = r === 0 ? e?.scene?.value?.uuid || Math.random().toString(36).slice(2, 11) : i;
  n.add(e), Object.entries(e).forEach(([u, l]) => {
    if (u.startsWith("_") || typeof l == "function")
      return;
    const c = s ? `${s}.${u}` : u, f = Qu(u, a, s);
    u !== "scene" && (me(l) ? (f.tags.push({
      label: `Ref<${typeof l.value}>`,
      textColor: 4372611,
      backgroundColor: 15793395
    }), l.value && typeof l.value == "object" ? wt(l.value, f, n, r + 1, o, a, c) : f.label = `${u}: ${JSON.stringify(l.value)}`) : l && typeof l == "object" && !Array.isArray(l) ? Object.keys(l).length > 0 ? n.has(l) ? f.tags.push({
      label: "Circular",
      textColor: 16711680,
      backgroundColor: 16773360
    }) : wt(l, f, n, r + 1, o, a, c) : f.label = `${u}: {}` : Array.isArray(l) ? (f.label = `${u}: Array(${l.length})`, f.tags.push({
      label: `length: ${l.length}`,
      textColor: 9738662,
      backgroundColor: 16316922
    })) : f.label = `${u}: ${JSON.stringify(l)}`, t.children.push(f));
  });
}
var Zu = (e) => (t) => {
  if (t.inspectorId === we) {
    const n = Oo(e.scene.value);
    So(e.scene.value, n, t.filter);
    const r = {
      id: "context-root",
      label: "Context",
      children: [],
      tags: []
    };
    wt(e, r), t.rootNodes = [n, r];
  }
};
var Ju = (e, { highlightMesh: t, prevInstance: n }) => (r) => {
  if (r.inspectorId !== we)
    return;
  const o = new MeshBasicMaterial({
    color: 11003607,
    // Highlight color, e.g., yellow
    transparent: true,
    opacity: 0.2,
    depthTest: false,
    // So the highlight is always visible
    side: DoubleSide
    // To ensure the highlight is visible from all angles
  });
  if (r.nodeId.includes("scene")) {
    const i = r.nodeId.match(/^scene-(.+)$/), s = i ? i[1] : null;
    if (!s)
      return;
    const [a] = e.scene.value.getObjectsByProperty("uuid", s);
    if (!a)
      return;
    if (n && t && t.parent && n.remove(t), $e(a)) {
      const u = new Xu(a.geometry.clone(), o);
      a.add(u), t = u, n = a;
    }
    if (r.state = {
      object: Object.entries(a).map(([u, l]) => u === "children" ? { key: u, value: l.filter((c) => c.type !== "HightlightMesh") } : { key: u, value: l, editable: true }).filter(({ key: u }) => u !== "parent")
    }, Fr(a)) {
      const u = {
        ...r.state,
        state: [
          {
            key: "Scene Info",
            value: {
              objects: a.children.length,
              memory: Bt(a),
              calls: e.renderer.instance.info.render.calls,
              triangles: e.renderer.instance.info.render.triangles,
              points: e.renderer.instance.info.render.points,
              lines: e.renderer.instance.info.render.lines
            }
          }
        ]
      };
      "programs" in e.renderer.instance.info && u.state.push({
        key: "Programs",
        value: e.renderer.instance.info.programs?.map((l) => ({
          ...l,
          programName: l.name
        }))
      }), r.state = u;
    }
  } else if (r.nodeId.includes("context")) {
    const i = r.nodeId.match(/^context-([^-]+(?:-[^-]+)*)-(.+)$/), s = i ? i[2] : "context";
    if (!s || s === "context") {
      r.state = {
        object: Object.entries(e).filter(([l]) => !l.startsWith("_") && l !== "parent").map(([l, c]) => ({
          key: l,
          value: me(c) ? c.value : c,
          editable: false
        }))
      };
      return;
    }
    const a = s.split(".");
    let u = e;
    for (const l of a) {
      if (!u || typeof u != "object")
        break;
      u = me(u[l]) ? u[l].value : u[l];
    }
    u !== void 0 && (r.state = {
      object: Object.entries(u).filter(([l]) => !l.startsWith("_") && l !== "parent").map(([l, c]) => me(c) ? {
        key: l,
        value: c.value,
        editable: false
      } : typeof c == "function" ? {
        key: l,
        value: "ƒ()",
        editable: false
      } : c && typeof c == "object" ? {
        key: l,
        value: Array.isArray(c) ? `Array(${c.length})` : "Object",
        editable: false
      } : {
        key: l,
        value: c,
        editable: false
      })
    });
  }
};
var el = (e, t, n, r) => {
  const o = To(e, t);
  if (!o) {
    console.warn("Object with UUID not found in the scene.");
    return;
  }
  let i = o;
  for (let a = 0; a < n.length - 1; a++)
    if (i[n[a]] !== void 0)
      i = i[n[a]];
    else {
      console.warn(`Property path is not valid: ${n.join(".")}`);
      return;
    }
  const s = n[n.length - 1];
  i[s] !== void 0 ? i[s] = r : console.warn(`Property path is not valid: ${n.join(".")}`);
};
var tl = (e) => (t) => {
  if (t.inspectorId === we && t.nodeId.includes("scene")) {
    const n = t.nodeId.match(/^scene-(.+)$/), r = n ? n[1] : null;
    if (!r)
      return;
    el(e.scene.value, r, t.path, t.state.value);
  }
};
var we = "tres:inspector";
function nl(e, t) {
  const n = {
    id: "dev.esm.tres",
    label: "TresJS 🪐",
    logo: "https://raw.githubusercontent.com/Tresjs/tres/main/public/favicon.svg",
    packageName: "tresjs",
    homepage: "https://docs.tresjs.org",
    app: e
  }, r = null, o = null;
  qu(t), cu(
    n,
    (i) => {
      typeof i.now != "function" && Gu(
        "You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."
      ), i.addInspector({
        id: we,
        label: "TresJS 🪐",
        icon: "account_tree",
        treeFilterPlaceholder: "Search instances"
      }), setInterval(() => {
        i.sendInspectorTree(we);
      }, 1e3), setInterval(() => {
        i.notifyComponentUpdate();
      }, 5e3), i.on.getInspectorTree(Zu(t)), i.on.getInspectorState(Ju(t, {
        highlightMesh: r,
        prevInstance: o
      })), i.on.editInspectorState(tl(t));
    }
  );
}
var rl = ["data-scene", "data-tres"];
var ol = ot({
  __name: "TresCanvas",
  props: {
    camera: {},
    windowSize: { type: Boolean, default: void 0 },
    enableProvideBridge: { type: Boolean, default: true },
    antialias: { type: Boolean, default: true },
    stencil: { type: Boolean, default: void 0 },
    depth: { type: Boolean, default: void 0 },
    precision: {},
    logarithmicDepthBuffer: { type: Boolean, default: void 0 },
    preserveDrawingBuffer: { type: Boolean, default: void 0 },
    powerPreference: {},
    alpha: { type: Boolean, default: void 0 },
    premultipliedAlpha: { type: Boolean },
    failIfMajorPerformanceCaveat: { type: Boolean, default: void 0 },
    clearColor: { default: "#000000" },
    clearAlpha: { default: 1 },
    shadows: { type: Boolean, default: void 0 },
    toneMapping: { default: ACESFilmicToneMapping },
    shadowMapType: { default: PCFSoftShadowMap },
    useLegacyLights: { type: Boolean, default: void 0 },
    outputColorSpace: {},
    toneMappingExposure: {},
    renderMode: { default: "always" },
    dpr: {},
    renderer: {}
  },
  emits: ["ready", "pointermissed", "render", "beforeLoop", "loop", "click", "contextmenu", "pointermove", "pointerenter", "pointerleave", "pointerover", "pointerout", "dblclick", "pointerdown", "pointerup", "pointercancel", "lostpointercapture", "wheel"],
  setup(e, { expose: t, emit: n }) {
    const r = e, o = n, i = ko(), s = Ae(), a = it(new Scene()), u = $t();
    pt(three_module_exports);
    const l = (_, v = false) => ot({
      setup() {
        const p = $t()?.appContext;
        p && (p.app = u?.appContext.app);
        const g = {};
        function C(b) {
          b && (b.parent && C(b.parent), b.provides && Object.assign(g, b.provides));
        }
        return u?.parent && r.enableProvideBridge && (C(u.parent), Reflect.ownKeys(g).forEach((b) => {
          qe(b, g[b]);
        })), qe(xs, _), qe("extend", pt), typeof window < "u" && p?.app && nl(p?.app, _), () => Wt(No, null, v ? [] : i.default());
      }
    }), c = (_, v = false) => {
      const p = l(_, v), { render: g } = Mo(Bs(_));
      g(Wt(p), a.value);
    }, f = (_, v = false) => {
      Ne(_.scene.value), v && (_.renderer.instance.dispose(), _.renderer.instance instanceof WebGLRenderer && (_.renderer.instance.renderLists.dispose(), _.renderer.instance.forceContextLoss())), a.value.__tres = {
        root: _
      };
    }, h2 = it(null);
    t({ context: h2, dispose: () => f(h2.value, true) });
    const d = () => {
      f(h2.value), c(h2.value, true);
    };
    return Kt(() => {
      const _ = s;
      h2.value = Rs({
        scene: a.value,
        canvas: _,
        windowSize: r.windowSize ?? false,
        rendererOptions: r
      });
      const { camera: v, renderer: p } = h2.value, { registerCamera: g, cameras: C, activeCamera: b, deregisterCamera: P } = v;
      c(h2.value);
      const M = () => {
        const A = new PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          1e3
        );
        A.position.set(3, 3, 3), A.lookAt(0, 0, 0), g(A);
        const O = $(() => {
          C.value.length >= 2 && (A.removeFromParent(), P(A), O?.());
        });
      };
      h2.value.events.onPointerMissed((A) => {
        o("pointermissed", A);
      }), At(
        () => r.camera,
        (A, O) => {
          A && g(I(A), true), O && (I(O).removeFromParent(), P(I(O)));
        },
        {
          immediate: true
        }
      ), b.value || M(), p.onRender(() => {
        h2.value && o("render", h2.value);
      }), p.loop.onLoop((A) => {
        h2.value && o("loop", { ...h2.value, ...A });
      }), p.loop.onBeforeLoop((A) => {
        h2.value && o("beforeLoop", { ...h2.value, ...A });
      }), p.onReady(() => {
        o("ready", h2.value);
      });
    }), Kt(async () => {
      await promiseTimeout(3e3), h2.value && (!h2.value.sizes.width || !h2.value.sizes.height.value) && console.warn("TresCanvas: The canvas has no area, so nothing can be rendered. Set it manually on the parent element or use the prop windowSize.");
    }), ie(d), (_, v) => (Ro(), xo("canvas", {
      ref_key: "canvasRef",
      ref: s,
      "data-scene": a.value.uuid,
      class: Fo(_.$attrs.class),
      "data-tres": `tresjs ${ke(Fi).version}`,
      style: Lo({
        display: "block",
        width: "100%",
        height: "100%",
        position: e.windowSize ? "fixed" : "relative",
        top: 0,
        left: 0,
        pointerEvents: "auto",
        touchAction: "none",
        ..._.$attrs.style
      })
    }, null, 14, rl));
  }
});
function ml(e) {
  return typeof e == "number" ? [e, e, e] : e instanceof Vector3 ? [e.x, e.y, e.z] : e;
}
function gl(e) {
  return e instanceof Color ? e : Array.isArray(e) ? new Color(...e) : new Color(e);
}
var il = [
  "TresCanvas",
  "TresLeches",
  "TresScene"
];
var El = {
  template: {
    compilerOptions: {
      isCustomElement: (e) => (/^Tres[A-Z]/.test(e) || e.startsWith("tres-")) && !il.includes(e) || e === "primitive"
    }
  }
};
var q = null;
var vl = {
  updated: (e, t) => {
    const r = ((i) => {
      let s = i.value;
      return i.value && $e(i.value) && (s = i.value.position), Array.isArray(i.value) && (s = new Vector3(...s)), s;
    })(t);
    if (!r) {
      Me(`v-distance-to: problem with binding value: ${t.value}`);
      return;
    }
    q && (q.dispose(), e.parent.remove(q));
    const o = r.clone().sub(e.position);
    o.normalize(), q = new ArrowHelper(o, e.position, e.position.distanceTo(r), 16776960), e.parent.add(q), console.table(
      [
        ["Distance:", e.position.distanceTo(r)],
        [`origin: ${e.name || e.type}`, `x:${e.position.x}, y:${e.position.y}, z:${e.position?.z}`],
        [`Destiny: ${e.name || e.type}`, `x:${r.x}, y:${r.y}, z:${r?.z}`]
      ]
    );
  },
  unmounted: (e) => {
    q?.dispose(), e.parent && e.parent.remove(q);
  }
};
var Po = class extends Line {
  constructor(t, n) {
    const r = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], o = new BufferGeometry();
    o.setAttribute("position", new Float32BufferAttribute(r, 3)), o.computeBoundingSphere();
    const i = new LineBasicMaterial({ fog: false });
    super(o, i), this.light = t, this.color = n, this.type = "RectAreaLightHelper";
    const s = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], a = new BufferGeometry();
    a.setAttribute("position", new Float32BufferAttribute(s, 3)), a.computeBoundingSphere(), this.add(new Mesh(a, new MeshBasicMaterial({ side: BackSide, fog: false })));
  }
  updateMatrixWorld() {
    if (this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1), this.color !== void 0)
      this.material.color.set(this.color), this.children[0].material.color.set(this.color);
    else {
      this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      const t = this.material.color, n = Math.max(t.r, t.g, t.b);
      n > 1 && t.multiplyScalar(1 / n), this.children[0].material.color.copy(this.material.color);
    }
    this.matrixWorld.extractRotation(this.light.matrixWorld).scale(this.scale).copyPosition(this.light.matrixWorld), this.children[0].matrixWorld.copy(this.matrixWorld);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
};
var De;
var W;
var sl = {
  DirectionalLight: DirectionalLightHelper,
  PointLight: PointLightHelper,
  SpotLight: SpotLightHelper,
  HemisphereLight: HemisphereLightHelper,
  RectAreaLight: Po
};
var yl = {
  mounted: (e) => {
    if (!Rr(e)) {
      Me(`${e.type} is not a light`);
      return;
    }
    De = sl[e.type], e.parent?.add(new De(e, 1, e.color.getHex()));
  },
  updated: (e) => {
    W = e.parent.children.find((t) => t instanceof De), !(W instanceof Po) && W.update();
  },
  unmounted: (e) => {
    if (!e.isLight) {
      Me(`${e.type} is not a light`);
      return;
    }
    W = e.parent.children.find((t) => t instanceof De), W && W.dispose && W.dispose(), e.parent && e.parent.remove(W);
  }
};
var Cl = {
  mounted: (e, t) => {
    if (t.arg) {
      console.log(`v-log:${t.arg}`, e[t.arg]);
      return;
    }
    console.log("v-log", e);
  }
};
var bl = {
  install(e) {
    e.component("TresCanvas", ol);
  }
};

export {
  useDevicePixelRatio,
  lt,
  $e,
  Pr,
  Hi,
  Ir,
  Dr,
  ji,
  Zt,
  kr,
  xr,
  Rr,
  Lr,
  Fr,
  cl,
  ct,
  zi,
  $i,
  re,
  Ki,
  Wi,
  Gi,
  fl,
  Jt,
  Me,
  dl,
  Ne,
  Zi,
  pl,
  Ji,
  es,
  hl,
  dt,
  pt,
  rs,
  Rs,
  zr,
  Fs,
  _l,
  Hs,
  nl,
  ol,
  ml,
  gl,
  El,
  vl,
  yl,
  Cl,
  bl
};
/*! Bundled license information:

@tresjs/core/dist/tres.js:
  (*! #__NO_SIDE_EFFECTS__ *)
*/
//# sourceMappingURL=chunk-BFSGLJGR.js.map
